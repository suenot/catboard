   1               		.file	"catboard.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.init_ports,"ax",@progbits
  11               	.global	init_ports
  13               	init_ports:
  14               	.LFB8:
  15               		.file 1 "at90usb162mu.h"
   1:at90usb162mu.h **** #define LED_CONFIG		(DDRD	|= (1<<6))
   2:at90usb162mu.h **** #define LED_OFF			(PORTD	|= (1<<6))
   3:at90usb162mu.h **** #define LED_ON			(PORTD	&= ~(1<<6))
   4:at90usb162mu.h **** 
   5:at90usb162mu.h **** #define LED_BLUE_CONFIG	(DDRD	|= (1<<1))
   6:at90usb162mu.h **** #define LED_BLUE_OFF		(PORTD	&= ~(1<<1))
   7:at90usb162mu.h **** #define LED_BLUE_ON		(PORTD	|= (1<<1))
   8:at90usb162mu.h **** 
   9:at90usb162mu.h **** #define LED_RED_CONFIG	(DDRC	|= (1<<6))
  10:at90usb162mu.h **** #define LED_RED_OFF	(PORTC	|= (1<<6))
  11:at90usb162mu.h **** #define LED_RED_ON		(PORTC	&= ~(1<<6))
  12:at90usb162mu.h **** 
  13:at90usb162mu.h **** #define FN_KEY_ID			7*5+4
  14:at90usb162mu.h **** 
  15:at90usb162mu.h **** // Init ports
  16:at90usb162mu.h **** void init_ports(void) {
  16               		.loc 1 16 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  17:at90usb162mu.h **** 	DDRB  = 0b01001010; DDRC  = 0b00100000; DDRD  = 0b00000100;
  22               		.loc 1 17 0
  23 0000 8AE4      		ldi r24,lo8(74)
  24 0002 84B9      		out 0x4,r24
  25 0004 80E2      		ldi r24,lo8(32)
  26 0006 87B9      		out 0x7,r24
  27 0008 84E0      		ldi r24,lo8(4)
  28 000a 8AB9      		out 0xa,r24
  18:at90usb162mu.h **** 	PORTB = 0xFF;		PORTC = 0xFF; 		PORTD = 0xFF;
  29               		.loc 1 18 0
  30 000c 8FEF      		ldi r24,lo8(-1)
  31 000e 85B9      		out 0x5,r24
  32 0010 88B9      		out 0x8,r24
  33 0012 8BB9      		out 0xb,r24
  34 0014 0895      		ret
  35               		.cfi_endproc
  36               	.LFE8:
  38               		.section	.text.init,"ax",@progbits
  39               	.global	init
  41               	init:
  42               	.LFB10:
  43               		.file 2 "catboard.c"
   1:catboard.c    **** /*
   2:catboard.c    **** * Project: CatBoard ][
   3:catboard.c    **** * Version: 3.2 beta
   4:catboard.c    **** * Date: 2013-09-07
   5:catboard.c    **** * Author: Vladimir Romanovich <ibnteo@gmail.com>
   6:catboard.c    **** * License: GPL2
   7:catboard.c    **** * Blog: http://ibnteo.klava.org/tag/catboard
   8:catboard.c    **** * Site: http://catboard.klava.org/
   9:catboard.c    **** * 
  10:catboard.c    **** * Board: AVR-USB162MU (http://microsin.net/programming/AVR/avr-usb162mu.html) analogue Teensy 1.0
  11:catboard.c    **** */
  12:catboard.c    **** 
  13:catboard.c    **** #include <avr/io.h>
  14:catboard.c    **** #include <avr/pgmspace.h>
  15:catboard.c    **** #include <avr/interrupt.h>
  16:catboard.c    **** #include <avr/wdt.h>
  17:catboard.c    **** #include <avr/power.h>
  18:catboard.c    **** #include <util/delay.h>
  19:catboard.c    **** #include "usb_keyboard.h"
  20:catboard.c    **** 
  21:catboard.c    **** #define STR_MANUFACTURER	L"ibnTeo"
  22:catboard.c    **** #define STR_PRODUCT		L"CatBoard"
  23:catboard.c    **** 
  24:catboard.c    **** #define _PINC		(uint8_t *const)&PINC
  25:catboard.c    **** #define _PORTC		(uint8_t *const)&PORTC
  26:catboard.c    **** #define _PIND		(uint8_t *const)&PIND
  27:catboard.c    **** #define _PORTD		(uint8_t *const)&PORTD
  28:catboard.c    **** #define _PORTB		(uint8_t *const)&PORTB
  29:catboard.c    **** #define _PINB		(uint8_t *const)&PINB
  30:catboard.c    **** 
  31:catboard.c    **** #define ROWS	5
  32:catboard.c    **** #define COLS	12
  33:catboard.c    **** #define KEYS	COLS*ROWS
  34:catboard.c    **** 
  35:catboard.c    **** //1=num lock, 2=caps lock, 4=scroll lock, 8=compose, 16=kana
  36:catboard.c    **** #define LED_NUM_LOCK		1
  37:catboard.c    **** #define LED_CAPS_LOCK		2
  38:catboard.c    **** #define LED_SCROLL_LOCK		4
  39:catboard.c    **** #define LED_COMPOSE			8
  40:catboard.c    **** #define LED_KANA			16
  41:catboard.c    **** 
  42:catboard.c    **** #define NULL				0
  43:catboard.c    **** #define NA					0
  44:catboard.c    **** // 109-127 - catboard
  45:catboard.c    **** #define KEY_CB_START		109
  46:catboard.c    **** #define KEY_LAYER1			109
  47:catboard.c    **** #define KEY_LAYER2			110
  48:catboard.c    **** #define KEY_MACRO			111
  49:catboard.c    **** // ...
  50:catboard.c    **** #define KEY_ALT_ENTER		118
  51:catboard.c    **** #define KEY_MY_SHIFT		119
  52:catboard.c    **** #define KEY_TYPO_MODE		120
  53:catboard.c    **** #define KEY_LED				121 // (+Shift)
  54:catboard.c    **** #define KEY_LOCK			122
  55:catboard.c    **** #define KEY_TURBO_REPEAT	123
  56:catboard.c    **** #define KEY_OS_MODE			124 // (+Shift)
  57:catboard.c    **** #define KEY_ALT_TAB			125
  58:catboard.c    **** #define KEY_FN_LOCK			126 // (+Shift)
  59:catboard.c    **** #define KEY_FN				127
  60:catboard.c    **** #define KEY_NULL			0
  61:catboard.c    **** 
  62:catboard.c    **** #define KEY_LCTRL	101
  63:catboard.c    **** #define KEY_LSHIFT	102
  64:catboard.c    **** #define KEY_LALT	103
  65:catboard.c    **** #define KEY_LGUI	104
  66:catboard.c    **** #define KEY_RCTRL	105
  67:catboard.c    **** #define KEY_RSHIFT	106
  68:catboard.c    **** #define KEY_RALT	107
  69:catboard.c    **** #define KEY_RGUI	108
  70:catboard.c    **** 
  71:catboard.c    **** 
  72:catboard.c    **** #define KEY_PRESSED_FN		1
  73:catboard.c    **** #define KEY_PRESSED_MODS	2
  74:catboard.c    **** #define KEY_PRESSED_ALT		3
  75:catboard.c    **** #define KEY_PRESSED_SHIFT	4
  76:catboard.c    **** #define KEY_PRESSED_CTRL	5
  77:catboard.c    **** #define KEY_PRESSED_PREV	6
  78:catboard.c    **** 
  79:catboard.c    **** #include "qwerty.h"
  80:catboard.c    **** //#include "dvorak.h"
  81:catboard.c    **** //#include "jcuken.h"
  82:catboard.c    **** 
  83:catboard.c    **** //#include "at90usb162.h"
  84:catboard.c    **** #include "at90usb162mu.h"
  85:catboard.c    **** 
  86:catboard.c    **** //#include "my_macros.h"
  87:catboard.c    **** 
  88:catboard.c    **** // 0 - shorcuts my layout; 1 - shorcuts qwerty layout
  89:catboard.c    **** #define KEY_SHORTCUTS_LAYER1	1
  90:catboard.c    **** 
  91:catboard.c    **** // Nonstandart hardware layout
  92:catboard.c    **** #define KEY_LAYOUT_ALT_SHIFT	1
  93:catboard.c    **** #define KEY_LAYOUT_CTRL_SHIFT	2
  94:catboard.c    **** #define KEY_LAYOUT_GUI_SPACE	3
  95:catboard.c    **** 
  96:catboard.c    **** //#define KEY_LAYOUT		0
  97:catboard.c    **** #define KEY_LAYOUT		KEY_LAYOUT_ALT_SHIFT
  98:catboard.c    **** 
  99:catboard.c    **** // OS mode: 0 - Windows, 1 - Linux, 2 - Mac
 100:catboard.c    **** uint8_t os_mode = 1;
 101:catboard.c    **** 
 102:catboard.c    **** uint8_t caps_lock_led = 0;
 103:catboard.c    **** uint8_t  disable_key_my_shift = 0;
 104:catboard.c    **** // 0x00-0x7F - normal keys
 105:catboard.c    **** // 0x80-0xF0 - mod_keys | 0x80
 106:catboard.c    **** // 0xF1-0xFF - catboard keys
 107:catboard.c    **** 
 108:catboard.c    **** // TODO: think...
 109:catboard.c    **** // 4-99 - Normal keys (96 keys)
 110:catboard.c    **** // 101-108|KEY_MOD - Mod keys (8 keys)
 111:catboard.c    **** // 109-127|KEY_MOD - CatBoard keys (19 keys)
 112:catboard.c    **** // n|0x80 - Shift inverse keys
 113:catboard.c    **** 
 114:catboard.c    **** 
 115:catboard.c    **** // Start layout
 116:catboard.c    **** uint8_t *layout = &layer2;
 117:catboard.c    **** 
 118:catboard.c    **** int8_t pressed[KEYS];
 119:catboard.c    **** uint8_t queue[7] = {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF};
 120:catboard.c    **** uint8_t mod_keys = 0;
 121:catboard.c    **** uint8_t *prev_layer = 0;
 122:catboard.c    **** 
 123:catboard.c    **** uint8_t turbo_repeat = 0;
 124:catboard.c    **** uint8_t locked = 0;
 125:catboard.c    **** uint8_t led = 1; // LED light
 126:catboard.c    **** 
 127:catboard.c    **** uint8_t last_key = 0xFF;
 128:catboard.c    **** uint16_t press_time = 0;
 129:catboard.c    **** uint16_t press_time2 = 0;
 130:catboard.c    **** uint16_t release_time = 0;
 131:catboard.c    **** uint16_t repeat_time = 0;
 132:catboard.c    **** 
 133:catboard.c    **** void init(void);
 134:catboard.c    **** void send(void);
 135:catboard.c    **** void poll(void);
 136:catboard.c    **** void repeat_tick(void);
 137:catboard.c    **** void key_press(uint8_t key_id);
 138:catboard.c    **** void key_release(uint8_t key_id);
 139:catboard.c    **** uint8_t get_code(uint8_t key_id);
 140:catboard.c    **** 
 141:catboard.c    **** /*
 142:catboard.c    **** rus
 143:catboard.c    **** §!@#$%^&*()–»
 144:catboard.c    **** јџќ®†њѓѕў‘“ъ
 145:catboard.c    **** ƒыћ÷©}°љ∆…эё
 146:catboard.c    **** ]ђ≈≠µи™~≤≥“
 147:catboard.c    **** 
 148:catboard.c    **** rus shift
 149:catboard.c    **** ±|"£€∞¬¶√'`—«
 150:catboard.c    **** ЈЏЌ®†ЊЃЅЎ’”Ъ
 151:catboard.c    **** ƒЫЋ÷©{•Љ∆…ЭЁ
 152:catboard.c    **** [Ђ≈≠µИ™~<>„
 153:catboard.c    **** 
 154:catboard.c    **** lat
 155:catboard.c    **** §¡™£¢∞§¶•ªº–≠
 156:catboard.c    **** œ∑´®†¥¨ˆøπ“‘
 157:catboard.c    **** åß∂ƒ©˙∆˚¬…æ«
 158:catboard.c    **** `Ω≈ç√∫˜µ≤≥÷
 159:catboard.c    **** 
 160:catboard.c    **** lat shift
 161:catboard.c    **** ±⁄€‹›ﬁﬂ‡°·‚—±
 162:catboard.c    **** Œ„´‰ˇÁ¨ˆØ∏”’
 163:catboard.c    **** ÅÍÎÏ˝ÓÔÒÚÆ»
 164:catboard.c    **** `¸˛Ç◊ı˜Â¯˘¿
 165:catboard.c    **** */
 166:catboard.c    **** 
 167:catboard.c    **** 
 168:catboard.c    **** int main(void) {
 169:catboard.c    **** 	// Disable watchdog if enabled by bootloader/fuses
 170:catboard.c    **** 	MCUSR &= ~(1 << WDRF);
 171:catboard.c    **** 	wdt_disable();
 172:catboard.c    **** 
 173:catboard.c    **** 	// Disable clock division
 174:catboard.c    **** 	clock_prescale_set(clock_div_1);
 175:catboard.c    **** 
 176:catboard.c    **** 	init();
 177:catboard.c    **** 	for (;;) {
 178:catboard.c    **** 		poll();
 179:catboard.c    **** 	}
 180:catboard.c    **** }
 181:catboard.c    **** 
 182:catboard.c    **** void init(void) {
  44               		.loc 2 182 0
  45               		.cfi_startproc
  46               	/* prologue: function */
  47               	/* frame size = 0 */
  48               	/* stack size = 0 */
  49               	.L__stack_usage = 0
 183:catboard.c    **** 	// Set for 16 MHz clock
 184:catboard.c    **** 	CLKPR = 0x80; CLKPR = 0;
  50               		.loc 2 184 0
  51 0000 80E8      		ldi r24,lo8(-128)
  52 0002 8093 6100 		sts 97,r24
  53 0006 1092 6100 		sts 97,__zero_reg__
 185:catboard.c    **** 
 186:catboard.c    **** 	init_ports();
  54               		.loc 2 186 0
  55 000a 0E94 0000 		call init_ports
  56               	.LVL0:
 187:catboard.c    **** 
 188:catboard.c    **** 	LED_CONFIG;
  57               		.loc 2 188 0
  58 000e 569A      		sbi 0xa,6
 189:catboard.c    **** 	LED_RED_CONFIG;
  59               		.loc 2 189 0
  60 0010 3E9A      		sbi 0x7,6
 190:catboard.c    **** 	LED_BLUE_CONFIG;
  61               		.loc 2 190 0
  62 0012 519A      		sbi 0xa,1
 191:catboard.c    **** 
 192:catboard.c    **** 	LED_RED_OFF;
  63               		.loc 2 192 0
  64 0014 469A      		sbi 0x8,6
 193:catboard.c    **** 	LED_BLUE_OFF;
  65               		.loc 2 193 0
  66 0016 5998      		cbi 0xb,1
 194:catboard.c    **** 	if (led) LED_ON;
  67               		.loc 2 194 0
  68 0018 8091 0000 		lds r24,led
  69 001c 8111      		cpse r24,__zero_reg__
  70               		.loc 2 194 0 is_stmt 0 discriminator 1
  71 001e 5E98      		cbi 0xb,6
  72               	.L3:
  73               	.LVL1:
  74 0020 E0E0      		ldi r30,lo8(pressed)
  75 0022 F0E0      		ldi r31,hi8(pressed)
  76               	.LVL2:
  77               	.L5:
  78               	.LBB25:
 195:catboard.c    **** 
 196:catboard.c    **** 	for (uint8_t i=0; i<KEYS; i++) {
 197:catboard.c    **** 		pressed[i] = 0;
  79               		.loc 2 197 0 is_stmt 1 discriminator 2
  80 0024 1192      		st Z+,__zero_reg__
  81               	.LVL3:
 196:catboard.c    **** 	for (uint8_t i=0; i<KEYS; i++) {
  82               		.loc 2 196 0 discriminator 2
  83 0026 80E0      		ldi r24,hi8(pressed+60)
  84 0028 E030      		cpi r30,lo8(pressed+60)
  85 002a F807      		cpc r31,r24
  86 002c 01F4      		brne .L5
  87               	.LBE25:
 198:catboard.c    **** 	}
 199:catboard.c    **** 
 200:catboard.c    **** 	usb_init();
  88               		.loc 2 200 0
  89 002e 0E94 0000 		call usb_init
  90               	.LVL4:
  91               	.L7:
 201:catboard.c    **** 	while(!usb_configured());
  92               		.loc 2 201 0 discriminator 1
  93 0032 0E94 0000 		call usb_configured
  94               	.LVL5:
  95 0036 8823      		tst r24
  96 0038 01F0      		breq .L7
 202:catboard.c    **** 	LED_OFF;
  97               		.loc 2 202 0
  98 003a 5E9A      		sbi 0xb,6
 203:catboard.c    **** 	if (led) LED_RED_ON;
  99               		.loc 2 203 0
 100 003c 8091 0000 		lds r24,led
 101 0040 8111      		cpse r24,__zero_reg__
 102               		.loc 2 203 0 is_stmt 0 discriminator 1
 103 0042 4698      		cbi 0x8,6
 104               	.L8:
 204:catboard.c    **** 	caps_lock_led = keyboard_leds;
 105               		.loc 2 204 0 is_stmt 1
 106 0044 8091 0000 		lds r24,keyboard_leds
 107 0048 8093 0000 		sts caps_lock_led,r24
 108 004c 0895      		ret
 109               		.cfi_endproc
 110               	.LFE10:
 112               		.section	.text.caps_lock_change_layer,"ax",@progbits
 113               	.global	caps_lock_change_layer
 115               	caps_lock_change_layer:
 116               	.LFB12:
 205:catboard.c    **** }
 206:catboard.c    **** 
 207:catboard.c    **** void poll() {
 208:catboard.c    **** 	uint8_t row, col, key_id;
 209:catboard.c    **** 	for (row=0; row<ROWS; row++) { // scan rows
 210:catboard.c    **** 		*row_port[row] &= ~row_bit[row];
 211:catboard.c    **** 		_delay_us(1);
 212:catboard.c    **** 		for (col=0; col<COLS; col++) { // read columns
 213:catboard.c    **** 			key_id = col*ROWS+row;
 214:catboard.c    **** 			if (! (*col_pin[col] & col_bit[col])) { // press key
 215:catboard.c    **** 				if (! pressed[key_id]) {
 216:catboard.c    **** 					key_press(key_id);
 217:catboard.c    **** 				}
 218:catboard.c    **** 			} else if (pressed[key_id]) { // release key
 219:catboard.c    **** 				key_release(key_id);
 220:catboard.c    **** 			}
 221:catboard.c    **** 		}
 222:catboard.c    **** 		*row_port[row] |= row_bit[row];
 223:catboard.c    **** 	}
 224:catboard.c    **** 	if (caps_lock_led != (keyboard_leds & LED_CAPS_LOCK)) { // change layout
 225:catboard.c    **** 		caps_lock_change_layer();
 226:catboard.c    **** 	}
 227:catboard.c    **** 	//if (keyboard_leds) LED_ON; else LED_OFF;
 228:catboard.c    **** 	repeat_tick();
 229:catboard.c    **** 	_delay_ms(5);
 230:catboard.c    **** }
 231:catboard.c    **** 
 232:catboard.c    **** void caps_lock_change_layer() {
 117               		.loc 2 232 0
 118               		.cfi_startproc
 119               	/* prologue: function */
 120               	/* frame size = 0 */
 121               	/* stack size = 0 */
 122               	.L__stack_usage = 0
 233:catboard.c    **** 	caps_lock_led = (keyboard_leds & LED_CAPS_LOCK);
 123               		.loc 2 233 0
 124 0000 2091 0000 		lds r18,keyboard_leds
 125 0004 2270      		andi r18,lo8(2)
 126 0006 2093 0000 		sts caps_lock_led,r18
 127 000a 8091 0000 		lds r24,layout
 128 000e 9091 0000 		lds r25,layout+1
 234:catboard.c    **** 	if ((caps_lock_led) && (layout != layer1)) {
 129               		.loc 2 234 0
 130 0012 2223      		tst r18
 131 0014 01F0      		breq .L17
 132               		.loc 2 234 0 is_stmt 0 discriminator 1
 133 0016 20E0      		ldi r18,hi8(layer1)
 134 0018 8030      		cpi r24,lo8(layer1)
 135 001a 9207      		cpc r25,r18
 136 001c 01F0      		breq .L16
 235:catboard.c    **** 		if (layout==layer_fn) {
 137               		.loc 2 235 0 is_stmt 1
 138 001e 8050      		subi r24,lo8(layer_fn)
 139 0020 9040      		sbci r25,hi8(layer_fn)
 140 0022 01F4      		brne .L20
 236:catboard.c    **** 			prev_layer = layer1;
 141               		.loc 2 236 0
 142 0024 80E0      		ldi r24,lo8(layer1)
 143 0026 90E0      		ldi r25,hi8(layer1)
 144 0028 9093 0000 		sts prev_layer+1,r25
 145 002c 8093 0000 		sts prev_layer,r24
 146 0030 00C0      		rjmp .L21
 147               	.L20:
 237:catboard.c    **** 		} else {
 238:catboard.c    **** 			layout = layer1;
 148               		.loc 2 238 0
 149 0032 80E0      		ldi r24,lo8(layer1)
 150 0034 90E0      		ldi r25,hi8(layer1)
 151 0036 9093 0000 		sts layout+1,r25
 152 003a 8093 0000 		sts layout,r24
 153               	.L21:
 239:catboard.c    **** 		}
 240:catboard.c    **** 		LED_RED_OFF;
 154               		.loc 2 240 0
 155 003e 469A      		sbi 0x8,6
 241:catboard.c    **** 		if (led) LED_BLUE_ON;
 156               		.loc 2 241 0
 157 0040 8091 0000 		lds r24,led
 158 0044 8823      		tst r24
 159 0046 01F0      		breq .L16
 160               		.loc 2 241 0 is_stmt 0 discriminator 1
 161 0048 599A      		sbi 0xb,1
 162 004a 0895      		ret
 163               	.L17:
 242:catboard.c    **** 	} else if ((! caps_lock_led) && (layout != layer2)) {
 164               		.loc 2 242 0 is_stmt 1 discriminator 1
 165 004c 20E0      		ldi r18,hi8(layer2)
 166 004e 8030      		cpi r24,lo8(layer2)
 167 0050 9207      		cpc r25,r18
 168 0052 01F0      		breq .L16
 243:catboard.c    **** 		if (layout==layer_fn) {
 169               		.loc 2 243 0
 170 0054 8050      		subi r24,lo8(layer_fn)
 171 0056 9040      		sbci r25,hi8(layer_fn)
 172 0058 01F4      		brne .L23
 244:catboard.c    **** 			prev_layer = layer2;
 173               		.loc 2 244 0
 174 005a 80E0      		ldi r24,lo8(layer2)
 175 005c 90E0      		ldi r25,hi8(layer2)
 176 005e 9093 0000 		sts prev_layer+1,r25
 177 0062 8093 0000 		sts prev_layer,r24
 178 0066 00C0      		rjmp .L24
 179               	.L23:
 245:catboard.c    **** 		} else {
 246:catboard.c    **** 			layout = layer2;
 180               		.loc 2 246 0
 181 0068 80E0      		ldi r24,lo8(layer2)
 182 006a 90E0      		ldi r25,hi8(layer2)
 183 006c 9093 0000 		sts layout+1,r25
 184 0070 8093 0000 		sts layout,r24
 185               	.L24:
 247:catboard.c    **** 		}
 248:catboard.c    **** 		LED_BLUE_OFF;
 186               		.loc 2 248 0
 187 0074 5998      		cbi 0xb,1
 249:catboard.c    **** 		if (led) LED_RED_ON;
 188               		.loc 2 249 0
 189 0076 8091 0000 		lds r24,led
 190 007a 8111      		cpse r24,__zero_reg__
 191               		.loc 2 249 0 is_stmt 0 discriminator 1
 192 007c 4698      		cbi 0x8,6
 193               	.L16:
 194 007e 0895      		ret
 195               		.cfi_endproc
 196               	.LFE12:
 198               		.section	.text.change_layout,"ax",@progbits
 199               	.global	change_layout
 201               	change_layout:
 202               	.LFB16:
 250:catboard.c    **** 	}
 251:catboard.c    **** }
 252:catboard.c    **** 
 253:catboard.c    **** void repeat_tick(void) {
 254:catboard.c    **** 	if (repeat_time) { // repeat pause
 255:catboard.c    **** 		if (repeat_time<(release_time>>2)) {
 256:catboard.c    **** 			repeat_time++;
 257:catboard.c    **** 		} else { // repeat press
 258:catboard.c    **** 			repeat_time = 1;
 259:catboard.c    **** 			if (turbo_repeat) {
 260:catboard.c    **** 				keyboard_modifier_keys = mod_keys;
 261:catboard.c    **** 				keyboard_keys[0] = get_code(last_key);
 262:catboard.c    **** 				if (! usb_keyboard_send()) { // repeat release
 263:catboard.c    **** 					keyboard_keys[0] = 0;
 264:catboard.c    **** 					usb_keyboard_send();
 265:catboard.c    **** 				}
 266:catboard.c    **** 			}
 267:catboard.c    **** 		}
 268:catboard.c    **** 	} else if (press_time2) { // press2 pause
 269:catboard.c    **** 		if (press_time2<(press_time+(pressed[FN_KEY_ID] ? 5 : 30))) {
 270:catboard.c    **** 			press_time2++;
 271:catboard.c    **** 		} else {
 272:catboard.c    **** 			repeat_time = 1;
 273:catboard.c    **** 		}
 274:catboard.c    **** 	} else if (release_time) { // release pause
 275:catboard.c    **** 		if (release_time<(press_time+50)) {
 276:catboard.c    **** 			release_time++;
 277:catboard.c    **** 		} else {
 278:catboard.c    **** 			last_key = 0xFF;
 279:catboard.c    **** 			release_time = 0;
 280:catboard.c    **** 			press_time = 0;
 281:catboard.c    **** 			press_time2 = 0;
 282:catboard.c    **** 			release_time = 0;
 283:catboard.c    **** 		}
 284:catboard.c    **** 	} else if (press_time) { // press1 pause
 285:catboard.c    **** 		if (press_time<250) {
 286:catboard.c    **** 			press_time++;
 287:catboard.c    **** 		} else {
 288:catboard.c    **** 			press_time = 0;
 289:catboard.c    **** 		}
 290:catboard.c    **** 	}	
 291:catboard.c    **** }
 292:catboard.c    **** 
 293:catboard.c    **** void key_press(uint8_t key_id) {
 294:catboard.c    **** 	uint8_t i;
 295:catboard.c    **** 	uint8_t mods_pressed = (mod_keys & (KEY_CTRL|KEY_RIGHT_CTRL|KEY_ALT|KEY_RIGHT_ALT|KEY_GUI|KEY_RIGH
 296:catboard.c    **** 	pressed[key_id] = (pressed[FN_KEY_ID] ? KEY_PRESSED_FN : (mods_pressed ? KEY_PRESSED_MODS : -1));
 297:catboard.c    **** 	
 298:catboard.c    **** 	if (key_id==FN_KEY_ID && led==1)	{
 299:catboard.c    **** 		LED_ON;
 300:catboard.c    **** 	}
 301:catboard.c    **** 	
 302:catboard.c    **** 	uint8_t key_code = ((pressed[key_id]==KEY_PRESSED_FN) ? layer_fn[key_id] : layout[key_id]);
 303:catboard.c    **** 	if (key_code==NULL) {
 304:catboard.c    **** 		key_code = layout[key_id];
 305:catboard.c    **** 		pressed[key_id] = (mods_pressed ? KEY_PRESSED_MODS : -1);
 306:catboard.c    **** 		if (key_code==NULL && prev_layer && ! mod_keys) {
 307:catboard.c    **** 			key_code = prev_layer[key_id];
 308:catboard.c    **** 			pressed[key_id] = KEY_PRESSED_PREV;
 309:catboard.c    **** 		}
 310:catboard.c    **** 	}
 311:catboard.c    **** 
 312:catboard.c    **** 	if (locked && key_code!=KEY_LOCK) return;
 313:catboard.c    **** 	
 314:catboard.c    **** 	if (key_code>=KEY_CB_START) { // Catboard keys
 315:catboard.c    **** 		if (key_code==KEY_ALT_TAB) { // AltTab press
 316:catboard.c    **** 			if (pressed[key_id]==KEY_PRESSED_FN) { // Fn + AltTab
 317:catboard.c    **** 				usb_keyboard_press(KEY_TAB, KEY_ALT);
 318:catboard.c    **** 			} else { // Alt press, Tab press and release
 319:catboard.c    **** 				if (! mod_keys) {
 320:catboard.c    **** 					mod_keys |= (KEY_ALT);
 321:catboard.c    **** 				} else {
 322:catboard.c    **** 					pressed[key_id] = KEY_PRESSED_ALT;
 323:catboard.c    **** 				}
 324:catboard.c    **** 				keyboard_modifier_keys = mod_keys;
 325:catboard.c    **** 				keyboard_keys[0] = KEY_TAB;
 326:catboard.c    **** 				usb_keyboard_send();
 327:catboard.c    **** 				_delay_ms(50);
 328:catboard.c    **** 				send();
 329:catboard.c    **** 			}
 330:catboard.c    **** 		} else if (key_code==KEY_ALT_ENTER) {
 331:catboard.c    **** 			if (!mod_keys) {
 332:catboard.c    **** 				mod_keys |= (KEY_ALT);
 333:catboard.c    **** 			} else {
 334:catboard.c    **** 					pressed[key_id] = KEY_PRESSED_ALT;
 335:catboard.c    **** 				}
 336:catboard.c    **** 				keyboard_modifier_keys = mod_keys;
 337:catboard.c    **** 				keyboard_keys[0] = KEY_ENTER;
 338:catboard.c    **** 				usb_keyboard_send();
 339:catboard.c    **** 				_delay_ms(50);
 340:catboard.c    **** 				send();			
 341:catboard.c    **** 		} else if (key_code==KEY_FN_LOCK) { // FnLock
 342:catboard.c    **** 			if (pressed[key_id]==KEY_PRESSED_FN && (mod_keys & (KEY_SHIFT|KEY_RIGHT_SHIFT))) {
 343:catboard.c    **** 				if (prev_layer) { // FnLock Off
 344:catboard.c    **** 					layout = prev_layer;
 345:catboard.c    **** 					restore_leds();
 346:catboard.c    **** 					prev_layer = 0;
 347:catboard.c    **** 				} else { // FnLock On
 348:catboard.c    **** 					prev_layer = layout;
 349:catboard.c    **** 					layout = layer_fnlock;
 350:catboard.c    **** 					LED_RED_ON;
 351:catboard.c    **** 					LED_BLUE_ON;
 352:catboard.c    **** 				}
 353:catboard.c    **** 			}
 354:catboard.c    **** 		} else if (key_code==KEY_OS_MODE) { // Mac mode
 355:catboard.c    **** 			if (pressed[key_id]==KEY_PRESSED_FN && (mod_keys & (KEY_SHIFT|KEY_RIGHT_SHIFT))) {
 356:catboard.c    **** 				os_mode++;
 357:catboard.c    **** 				if (os_mode>2) os_mode = 0;
 358:catboard.c    **** 			} else { // Press Space
 359:catboard.c    **** 				usb_keyboard_press(KEY_SPACE, mod_keys);
 360:catboard.c    **** 			}
 361:catboard.c    **** 		} else if (key_code==KEY_LAYER1) { // KEY_LAYOUT1
 362:catboard.c    **** 			if (mod_keys & (KEY_SHIFT|KEY_RIGHT_SHIFT)) {
 363:catboard.c    **** 				pressed[key_id] = KEY_PRESSED_CTRL;
 364:catboard.c    **** 				mod_keys |= KEY_CTRL;
 365:catboard.c    **** 				send();
 366:catboard.c    **** 			} else {
 367:catboard.c    **** 				if (mod_keys) pressed[key_id] = KEY_PRESSED_SHIFT;
 368:catboard.c    **** 				mod_keys |= KEY_SHIFT;
 369:catboard.c    **** 				send();
 370:catboard.c    **** 			}
 371:catboard.c    **** 		} else if (key_code==KEY_LAYER2) { // KEY_LAYOUT2
 372:catboard.c    **** 			mod_keys |= KEY_RIGHT_SHIFT;
 373:catboard.c    **** 			send();
 374:catboard.c    **** 		} else if (key_code==KEY_TURBO_REPEAT) { // TURBO_REPEAT ON/OFF
 375:catboard.c    **** 			turbo_repeat = ! turbo_repeat;
 376:catboard.c    **** 			blink_leds();
 377:catboard.c    **** 		} else if (key_code==KEY_MY_SHIFT) { // My Shift
 378:catboard.c    **** 			mod_keys |= KEY_SHIFT;
 379:catboard.c    **** 			send();
 380:catboard.c    **** 		} else if (key_code==KEY_MACRO) { // TODO: My Macro
 381:catboard.c    **** 			/*uint8_t macros_pos_index = 0;
 382:catboard.c    **** 			for (i==0; i<sizeof(macros_pos); i++) {
 383:catboard.c    **** 				if (key_id==macros_pos[i]) {
 384:catboard.c    **** 					macros_pos_index = i;
 385:catboard.c    **** 					break;
 386:catboard.c    **** 				}
 387:catboard.c    **** 			}
 388:catboard.c    **** 			uint16_t *macros;
 389:catboard.c    **** 			uint16_t *macros = macros_press[macros_pos_index];
 390:catboard.c    **** 			for (i==0; i<sizeof(macros); i=i+2) {
 391:catboard.c    **** 				usb_keyboard_press(macros[i], macros[i+1]);
 392:catboard.c    **** 			}*/
 393:catboard.c    **** 		} else if (key_code==KEY_LOCK) { // Lock/Unlock keyboard
 394:catboard.c    **** 			if (locked) {
 395:catboard.c    **** 				locked = 0;
 396:catboard.c    **** 				if (led) {
 397:catboard.c    **** 					restore_leds();
 398:catboard.c    **** 				}
 399:catboard.c    **** 			} else {
 400:catboard.c    **** 				locked = 1;
 401:catboard.c    **** 				LED_OFF;
 402:catboard.c    **** 				LED_RED_OFF;
 403:catboard.c    **** 				LED_BLUE_OFF;
 404:catboard.c    **** 				usb_keyboard_press(KEY_L, KEY_GUI); // Block computer
 405:catboard.c    **** 			}
 406:catboard.c    **** 		} else if (key_code==KEY_LED && (mod_keys & (KEY_SHIFT|KEY_RIGHT_SHIFT))) { // LED On/Off
 407:catboard.c    **** 			if (led) {
 408:catboard.c    **** 				led = 0;
 409:catboard.c    **** 				LED_OFF;
 410:catboard.c    **** 				LED_RED_OFF;
 411:catboard.c    **** 				LED_BLUE_OFF;
 412:catboard.c    **** 			} else {
 413:catboard.c    **** 				led = 1;
 414:catboard.c    **** 				restore_leds();
 415:catboard.c    **** 			}
 416:catboard.c    **** 		}
 417:catboard.c    **** 	} else if (key_code>=KEY_LCTRL) { // Mod keys
 418:catboard.c    **** 		if (os_mode==2 && key_code==KEY_LCTRL) {
 419:catboard.c    **** 			mod_keys |= KEY_GUI;
 420:catboard.c    **** 		} else if ((os_mode==2 && key_code==KEY_RCTRL) || key_code==KEY_RGUI) {
 421:catboard.c    **** 			mod_keys |= KEY_RIGHT_GUI;
 422:catboard.c    **** 		} else if (key_code==KEY_LCTRL) {
 423:catboard.c    **** 			mod_keys |= KEY_CTRL;
 424:catboard.c    **** 		} else if (key_code==KEY_LSHIFT) {
 425:catboard.c    **** 			mod_keys |= KEY_SHIFT;
 426:catboard.c    **** 		} else if (key_code==KEY_LALT) {
 427:catboard.c    **** 			mod_keys |= KEY_ALT;
 428:catboard.c    **** 		} else if (key_code==KEY_LGUI) {
 429:catboard.c    **** 			mod_keys |= KEY_GUI;
 430:catboard.c    **** 		} else if (key_code==KEY_RCTRL) {
 431:catboard.c    **** 			mod_keys |= KEY_RIGHT_CTRL;
 432:catboard.c    **** 		} else if (key_code==KEY_RSHIFT) {
 433:catboard.c    **** 			mod_keys |= KEY_RIGHT_SHIFT;
 434:catboard.c    **** 		} else if (key_code==KEY_RALT) {
 435:catboard.c    **** 			mod_keys |= KEY_RIGHT_ALT;
 436:catboard.c    **** 		} else if (key_code==KEY_RGUI) {
 437:catboard.c    **** 			mod_keys |= KEY_RIGHT_GUI;
 438:catboard.c    **** 		}
 439:catboard.c    **** 		send();
 440:catboard.c    **** 		press_time = 0;
 441:catboard.c    **** 		press_time2 = 0;
 442:catboard.c    **** 		release_time = 0;
 443:catboard.c    **** 		repeat_time = 0;
 444:catboard.c    **** 		last_key = 0;
 445:catboard.c    **** 	} else {
 446:catboard.c    **** 		/*if (mod_keys & (KEY_ALT|KEY_RIGHT_ALT)) { // TODO: typo
 447:catboard.c    **** 			uint16_t num = layer2_typo[0];
 448:catboard.c    **** 			char str[4];
 449:catboard.c    **** 			itoa(num, &str, 16);
 450:catboard.c    **** 		}*/
 451:catboard.c    **** 		if (! (last_key==key_id && release_time<10)) { // debounce
 452:catboard.c    **** 			for (i=5; i>0; i--) queue[i] = queue[i-1];
 453:catboard.c    **** 			queue[0] = key_id;
 454:catboard.c    **** 			send();
 455:catboard.c    **** 		}
 456:catboard.c    **** 	}
 457:catboard.c    **** 	// Autorepeat
 458:catboard.c    **** 	if (last_key==key_id) { // calc press2
 459:catboard.c    **** 		press_time2 = 1;
 460:catboard.c    **** 		repeat_time = 0;
 461:catboard.c    **** 	} else { // calc press1
 462:catboard.c    **** 		last_key = key_id;
 463:catboard.c    **** 		press_time = 1;
 464:catboard.c    **** 		press_time2 = 0;
 465:catboard.c    **** 		release_time = 0;
 466:catboard.c    **** 		repeat_time = 0;
 467:catboard.c    **** 	}
 468:catboard.c    **** }
 469:catboard.c    **** 
 470:catboard.c    **** void key_release(uint8_t key_id) {
 471:catboard.c    **** 	uint8_t i;
 472:catboard.c    **** 	int8_t pressed_key_id = pressed[key_id];
 473:catboard.c    **** 	uint8_t key_code = ((pressed_key_id==KEY_PRESSED_FN) ? layer_fn[key_id] : layout[key_id]);
 474:catboard.c    **** 	if (pressed_key_id!=KEY_PRESSED_FN) {
 475:catboard.c    **** 		LED_OFF;
 476:catboard.c    **** 	}
 477:catboard.c    **** 	if (pressed_key_id==KEY_PRESSED_PREV && prev_layer) {
 478:catboard.c    **** 		key_code = prev_layer[key_id];
 479:catboard.c    **** 	}
 480:catboard.c    **** 	pressed[key_id] = 0;
 481:catboard.c    **** 	//if (locked) return;
 482:catboard.c    **** 	if (key_code>=KEY_CB_START) { // Catboard keys release
 483:catboard.c    **** 		if ((key_code==KEY_ALT_TAB || key_code==KEY_ALT_ENTER) && pressed_key_id!=KEY_PRESSED_ALT) { // A
 484:catboard.c    **** 			mod_keys &= ~(KEY_ALT);
 485:catboard.c    **** 			send();
 486:catboard.c    **** 		} else if (key_code==KEY_LAYER1 && pressed_key_id==KEY_PRESSED_CTRL) { // Layer1: Ctrl release
 487:catboard.c    **** 			mod_keys &= ~(KEY_CTRL);
 488:catboard.c    **** 			send();
 489:catboard.c    **** 		} else if (key_code==KEY_LAYER1) { // LAYER1
 490:catboard.c    **** 			mod_keys &= ~(KEY_SHIFT);
 491:catboard.c    **** 			send();
 492:catboard.c    **** 			if (last_key==key_id && press_time && press_time<50 && pressed_key_id!=KEY_PRESSED_SHIFT) {
 493:catboard.c    **** 				if (layout!=layer1) {
 494:catboard.c    **** 					if (layout==layer_fn) {
 495:catboard.c    **** 						prev_layer = layer1;
 496:catboard.c    **** 					} else {
 497:catboard.c    **** 						layout = layer1;
 498:catboard.c    **** 					}
 499:catboard.c    **** 					change_layout();
 500:catboard.c    **** 					//LED_ON;
 501:catboard.c    **** 					LED_RED_OFF;
 502:catboard.c    **** 					if (led) LED_BLUE_ON;
 503:catboard.c    **** 				}
 504:catboard.c    **** 			}
 505:catboard.c    **** 			last_key = 0xFF;
 506:catboard.c    **** 			press_time = 0;
 507:catboard.c    **** 			press_time2 = 0;
 508:catboard.c    **** 			release_time = 0;
 509:catboard.c    **** 			repeat_time = 0;
 510:catboard.c    **** 		} else if (key_code==KEY_LAYER2) { // LAYER2
 511:catboard.c    **** 			mod_keys &= ~(KEY_RIGHT_SHIFT);
 512:catboard.c    **** 			send();
 513:catboard.c    **** 			if (last_key==key_id && press_time && press_time<50 && pressed_key_id!=KEY_PRESSED_SHIFT) {
 514:catboard.c    **** 				if (layout!=layer2) {
 515:catboard.c    **** 					if (layout==layer_fn) {
 516:catboard.c    **** 						prev_layer = layer2;
 517:catboard.c    **** 					} else {
 518:catboard.c    **** 						layout = layer2;
 519:catboard.c    **** 					}
 520:catboard.c    **** 					change_layout();
 521:catboard.c    **** 					//LED_OFF;
 522:catboard.c    **** 					LED_BLUE_OFF;
 523:catboard.c    **** 					if (led) LED_RED_ON;
 524:catboard.c    **** 				}
 525:catboard.c    **** 			}
 526:catboard.c    **** 			last_key = 0xFF;
 527:catboard.c    **** 			press_time = 0;
 528:catboard.c    **** 			press_time2 = 0;
 529:catboard.c    **** 			release_time = 0;
 530:catboard.c    **** 			repeat_time = 0;
 531:catboard.c    **** 		} else if (key_code==KEY_MY_SHIFT) { // My Shift
 532:catboard.c    **** 			mod_keys &= ~KEY_SHIFT;
 533:catboard.c    **** 			send();
 534:catboard.c    **** 			if (last_key==key_id && press_time && press_time<50 && pressed_key_id!=KEY_PRESSED_MODS && ! mod
 535:catboard.c    **** 				usb_keyboard_press(KEY_SPACE, mod_keys);
 536:catboard.c    **** 			}
 537:catboard.c    **** 			last_key = 0xFF;
 538:catboard.c    **** 			press_time = 0;
 539:catboard.c    **** 			press_time2 = 0;
 540:catboard.c    **** 			release_time = 0;
 541:catboard.c    **** 			repeat_time = 0;
 542:catboard.c    **** 		}
 543:catboard.c    **** 	} else if (key_code>=KEY_LCTRL) { // Mod keys release
 544:catboard.c    **** 		if (os_mode==2 && key_code==KEY_LCTRL) {
 545:catboard.c    **** 			mod_keys &= ~KEY_GUI;
 546:catboard.c    **** 		} else if ((os_mode==2 && key_code==KEY_RCTRL) || key_code==KEY_RGUI) {
 547:catboard.c    **** 			mod_keys &= ~KEY_RIGHT_GUI;
 548:catboard.c    **** 		} else if (key_code==KEY_LCTRL) {
 549:catboard.c    **** 			mod_keys &= ~KEY_CTRL;
 550:catboard.c    **** 		} else if (key_code==KEY_LSHIFT) {
 551:catboard.c    **** 			mod_keys &= ~KEY_SHIFT;
 552:catboard.c    **** 		} else if (key_code==KEY_LALT) {
 553:catboard.c    **** 			mod_keys &= ~KEY_ALT;
 554:catboard.c    **** 		} else if (key_code==KEY_LGUI) {
 555:catboard.c    **** 			mod_keys &= ~KEY_GUI;
 556:catboard.c    **** 		} else if (key_code==KEY_RCTRL) {
 557:catboard.c    **** 			mod_keys &= ~KEY_RIGHT_CTRL;
 558:catboard.c    **** 		} else if (key_code==KEY_RSHIFT) {
 559:catboard.c    **** 			mod_keys &= ~KEY_RIGHT_SHIFT;
 560:catboard.c    **** 		} else if (key_code==KEY_RALT) {
 561:catboard.c    **** 			mod_keys &= ~KEY_RIGHT_ALT;
 562:catboard.c    **** 		} else if (key_code==KEY_RGUI) {
 563:catboard.c    **** 			mod_keys &= ~KEY_RIGHT_GUI;
 564:catboard.c    **** 		}
 565:catboard.c    **** 		send();
 566:catboard.c    **** 		press_time = 0;
 567:catboard.c    **** 		press_time2 = 0;
 568:catboard.c    **** 		release_time = 0;
 569:catboard.c    **** 		repeat_time = 0;
 570:catboard.c    **** 		last_key = 0;
 571:catboard.c    **** 	} else {
 572:catboard.c    **** 		for (i=0; i<6; i++) {
 573:catboard.c    **** 			if (queue[i]==key_id) {
 574:catboard.c    **** 				break;
 575:catboard.c    **** 			}
 576:catboard.c    **** 		}
 577:catboard.c    **** 		for (; i<6; i++) {
 578:catboard.c    **** 			queue[i] = queue[i+1];
 579:catboard.c    **** 		}
 580:catboard.c    **** 		send();
 581:catboard.c    **** 		// Autorepeat
 582:catboard.c    **** 		if (last_key==key_id) { // realise time
 583:catboard.c    **** 			press_time2 = 0;
 584:catboard.c    **** 			release_time = 1;
 585:catboard.c    **** 			repeat_time = 0;
 586:catboard.c    **** 		} else { // reset
 587:catboard.c    **** 			press_time = 0;
 588:catboard.c    **** 			press_time2 = 0;
 589:catboard.c    **** 			release_time = 0;
 590:catboard.c    **** 			repeat_time = 0;
 591:catboard.c    **** 		}
 592:catboard.c    **** 	}
 593:catboard.c    **** }
 594:catboard.c    **** 
 595:catboard.c    **** void change_layout(void) {
 203               		.loc 2 595 0 is_stmt 1
 204               		.cfi_startproc
 205               	/* prologue: function */
 206               	/* frame size = 0 */
 207               	/* stack size = 0 */
 208               	.L__stack_usage = 0
 596:catboard.c    **** 	if (KEY_LAYOUT==KEY_LAYOUT_GUI_SPACE || os_mode==2) { // Press Cmd+Space
 209               		.loc 2 596 0
 210 0000 8091 0000 		lds r24,os_mode
 211 0004 8230      		cpi r24,lo8(2)
 212 0006 01F4      		brne .L35
 213               	.LBB36:
 214               	.LBB37:
 597:catboard.c    **** 		keyboard_modifier_keys = KEY_GUI;
 215               		.loc 2 597 0
 216 0008 88E0      		ldi r24,lo8(8)
 217 000a 8093 0000 		sts keyboard_modifier_keys,r24
 598:catboard.c    **** 		keyboard_keys[0] = 0;
 218               		.loc 2 598 0
 219 000e 1092 0000 		sts keyboard_keys,__zero_reg__
 599:catboard.c    **** 		usb_keyboard_send();
 220               		.loc 2 599 0
 221 0012 0E94 0000 		call usb_keyboard_send
 222               	.LVL6:
 223               	.LBB38:
 224               	.LBB39:
 225               		.file 3 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/avr/include/util/delay.h **** 
 153:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/avr/include/util/delay.h **** 
 156:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/avr/include/util/delay.h **** 
 159:/usr/lib/avr/include/util/delay.h **** 	#else
 160:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/avr/include/util/delay.h **** 	#endif
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 226               		.loc 3 164 0
 227 0016 2FEF      		ldi r18,lo8(159999)
 228 0018 80E7      		ldi r24,hi8(159999)
 229 001a 92E0      		ldi r25,hlo8(159999)
 230 001c 2150      		1: subi r18,1
 231 001e 8040      		sbci r24,0
 232 0020 9040      		sbci r25,0
 233 0022 01F4      		brne 1b
 234 0024 00C0      		rjmp .
 235 0026 0000      		nop
 236               	.LBE39:
 237               	.LBE38:
 600:catboard.c    **** 		_delay_ms(50);
 601:catboard.c    **** 		usb_keyboard_press(KEY_SPACE, KEY_GUI);
 238               		.loc 2 601 0
 239 0028 68E0      		ldi r22,lo8(8)
 240 002a 8CE2      		ldi r24,lo8(44)
 241 002c 00C0      		rjmp .L36
 242               	.LVL7:
 243               	.L35:
 244               	.LBE37:
 245               	.LBE36:
 602:catboard.c    **** 	} else if (KEY_LAYOUT==KEY_LAYOUT_ALT_SHIFT) { // Press Alt+Shift
 603:catboard.c    **** 		keyboard_modifier_keys = KEY_ALT;
 246               		.loc 2 603 0
 247 002e 84E0      		ldi r24,lo8(4)
 248 0030 8093 0000 		sts keyboard_modifier_keys,r24
 604:catboard.c    **** 		keyboard_keys[0] = 0;
 249               		.loc 2 604 0
 250 0034 1092 0000 		sts keyboard_keys,__zero_reg__
 605:catboard.c    **** 		usb_keyboard_send();
 251               		.loc 2 605 0
 252 0038 0E94 0000 		call usb_keyboard_send
 253               	.LVL8:
 254               	.LBB40:
 255               	.LBB41:
 256               		.loc 3 164 0
 257 003c 2FEF      		ldi r18,lo8(159999)
 258 003e 80E7      		ldi r24,hi8(159999)
 259 0040 92E0      		ldi r25,hlo8(159999)
 260 0042 2150      		1: subi r18,1
 261 0044 8040      		sbci r24,0
 262 0046 9040      		sbci r25,0
 263 0048 01F4      		brne 1b
 264 004a 00C0      		rjmp .
 265 004c 0000      		nop
 266               	.LBE41:
 267               	.LBE40:
 606:catboard.c    **** 		_delay_ms(50);
 607:catboard.c    **** 		usb_keyboard_press(0, KEY_ALT|KEY_SHIFT);
 268               		.loc 2 607 0
 269 004e 66E0      		ldi r22,lo8(6)
 270 0050 80E0      		ldi r24,0
 271               	.LVL9:
 272               	.L36:
 273 0052 0C94 0000 		jmp usb_keyboard_press
 274               	.LVL10:
 275               		.cfi_endproc
 276               	.LFE16:
 278               		.section	.text.get_code,"ax",@progbits
 279               	.global	get_code
 281               	get_code:
 282               	.LFB18:
 608:catboard.c    **** 	} else if (KEY_LAYOUT==KEY_LAYOUT_CTRL_SHIFT) { // Press Ctrl+Shift
 609:catboard.c    **** 		keyboard_modifier_keys = KEY_CTRL;
 610:catboard.c    **** 		keyboard_keys[0] = 0;
 611:catboard.c    **** 		usb_keyboard_send();
 612:catboard.c    **** 		_delay_ms(50);
 613:catboard.c    **** 		usb_keyboard_press(0, KEY_CTRL|KEY_SHIFT);
 614:catboard.c    **** 	}
 615:catboard.c    **** }
 616:catboard.c    **** 
 617:catboard.c    **** void send(void) {
 618:catboard.c    **** 	uint8_t i;
 619:catboard.c    **** 	for (i=0; i<6; i++) {
 620:catboard.c    **** 		keyboard_keys[i] = get_code(queue[i]);
 621:catboard.c    **** 	}
 622:catboard.c    **** 	keyboard_modifier_keys = mod_keys;
 623:catboard.c    **** 	usb_keyboard_send();
 624:catboard.c    **** }
 625:catboard.c    **** 
 626:catboard.c    **** uint8_t get_code(uint8_t key_id) {
 283               		.loc 2 626 0
 284               		.cfi_startproc
 285               	.LVL11:
 286               	/* prologue: function */
 287               	/* frame size = 0 */
 288               	/* stack size = 0 */
 289               	.L__stack_usage = 0
 627:catboard.c    **** 	uint8_t key_code = 0;
 628:catboard.c    **** 	if (key_id<KEYS) { // not 0xFF
 290               		.loc 2 628 0
 291 0000 8C33      		cpi r24,lo8(60)
 292 0002 00F4      		brsh .L42
 293               	.LVL12:
 294               	.LBB44:
 295               	.LBB45:
 629:catboard.c    **** 		if (pressed[key_id]==KEY_PRESSED_FN) { // key+Fn key
 296               		.loc 2 629 0
 297 0004 90E0      		ldi r25,0
 298 0006 FC01      		movw r30,r24
 299 0008 E050      		subi r30,lo8(-(pressed))
 300 000a F040      		sbci r31,hi8(-(pressed))
 301 000c 4081      		ld r20,Z
 302 000e 4130      		cpi r20,lo8(1)
 303 0010 01F4      		brne .L39
 630:catboard.c    **** 			if (layer_fn[key_id]>0 && layer_fn[key_id]<0x80) {
 304               		.loc 2 630 0
 305 0012 FC01      		movw r30,r24
 306 0014 E050      		subi r30,lo8(-(layer_fn))
 307 0016 F040      		sbci r31,hi8(-(layer_fn))
 308 0018 8081      		ld r24,Z
 309               	.LVL13:
 310 001a 1816      		cp __zero_reg__,r24
 311 001c 04F0      		brlt .L38
 312 001e 00C0      		rjmp .L42
 313               	.LVL14:
 314               	.L39:
 631:catboard.c    **** 				key_code = layer_fn[key_id];
 632:catboard.c    **** 			}
 633:catboard.c    **** 		} else if (layout!=layer_fn && pressed[key_id]==KEY_PRESSED_MODS) { // keyboard shortcuts from la
 315               		.loc 2 633 0
 316 0020 2091 0000 		lds r18,layout
 317 0024 3091 0000 		lds r19,layout+1
 318 0028 50E0      		ldi r21,hi8(layer_fn)
 319 002a 2030      		cpi r18,lo8(layer_fn)
 320 002c 3507      		cpc r19,r21
 321 002e 01F0      		breq .L41
 322 0030 4230      		cpi r20,lo8(2)
 323 0032 01F4      		brne .L41
 634:catboard.c    **** 			key_code = (KEY_SHORTCUTS_LAYER1 ? layer1[key_id] : layer2[key_id]);
 324               		.loc 2 634 0
 325 0034 FC01      		movw r30,r24
 326 0036 E050      		subi r30,lo8(-(layer1))
 327 0038 F040      		sbci r31,hi8(-(layer1))
 328 003a 00C0      		rjmp .L46
 329               	.L41:
 635:catboard.c    **** 		} else {
 636:catboard.c    **** 			key_code = layout[key_id];
 330               		.loc 2 636 0
 331 003c F901      		movw r30,r18
 332 003e E80F      		add r30,r24
 333 0040 F91F      		adc r31,r25
 334               	.L46:
 335 0042 8081      		ld r24,Z
 336               	.LVL15:
 337 0044 0895      		ret
 338               	.LVL16:
 339               	.L42:
 340               	.LBE45:
 341               	.LBE44:
 627:catboard.c    **** 	uint8_t key_code = 0;
 342               		.loc 2 627 0
 343 0046 80E0      		ldi r24,0
 344               	.L38:
 345               	.LVL17:
 637:catboard.c    **** 		}
 638:catboard.c    **** 	}
 639:catboard.c    **** 	return key_code;
 640:catboard.c    **** }
 346               		.loc 2 640 0
 347 0048 0895      		ret
 348               		.cfi_endproc
 349               	.LFE18:
 351               		.section	.text.repeat_tick,"ax",@progbits
 352               	.global	repeat_tick
 354               	repeat_tick:
 355               	.LFB13:
 253:catboard.c    **** void repeat_tick(void) {
 356               		.loc 2 253 0
 357               		.cfi_startproc
 358               	/* prologue: function */
 359               	/* frame size = 0 */
 360               	/* stack size = 0 */
 361               	.L__stack_usage = 0
 254:catboard.c    **** 	if (repeat_time) { // repeat pause
 362               		.loc 2 254 0
 363 0000 8091 0000 		lds r24,repeat_time
 364 0004 9091 0000 		lds r25,repeat_time+1
 365 0008 0097      		sbiw r24,0
 366 000a 01F0      		breq .L48
 255:catboard.c    **** 		if (repeat_time<(release_time>>2)) {
 367               		.loc 2 255 0
 368 000c 2091 0000 		lds r18,release_time
 369 0010 3091 0000 		lds r19,release_time+1
 370 0014 3695      		lsr r19
 371 0016 2795      		ror r18
 372 0018 3695      		lsr r19
 373 001a 2795      		ror r18
 374 001c 8217      		cp r24,r18
 375 001e 9307      		cpc r25,r19
 376 0020 00F4      		brsh .L49
 256:catboard.c    **** 			repeat_time++;
 377               		.loc 2 256 0
 378 0022 0196      		adiw r24,1
 379 0024 00C0      		rjmp .L63
 380               	.L49:
 258:catboard.c    **** 			repeat_time = 1;
 381               		.loc 2 258 0
 382 0026 81E0      		ldi r24,lo8(1)
 383 0028 90E0      		ldi r25,0
 384 002a 9093 0000 		sts repeat_time+1,r25
 385 002e 8093 0000 		sts repeat_time,r24
 259:catboard.c    **** 			if (turbo_repeat) {
 386               		.loc 2 259 0
 387 0032 8091 0000 		lds r24,turbo_repeat
 388 0036 8823      		tst r24
 389 0038 01F4      		brne .+2
 390 003a 00C0      		rjmp .L47
 260:catboard.c    **** 				keyboard_modifier_keys = mod_keys;
 391               		.loc 2 260 0
 392 003c 8091 0000 		lds r24,mod_keys
 393 0040 8093 0000 		sts keyboard_modifier_keys,r24
 261:catboard.c    **** 				keyboard_keys[0] = get_code(last_key);
 394               		.loc 2 261 0
 395 0044 8091 0000 		lds r24,last_key
 396 0048 0E94 0000 		call get_code
 397               	.LVL18:
 398 004c 8093 0000 		sts keyboard_keys,r24
 262:catboard.c    **** 				if (! usb_keyboard_send()) { // repeat release
 399               		.loc 2 262 0
 400 0050 0E94 0000 		call usb_keyboard_send
 401               	.LVL19:
 402 0054 8111      		cpse r24,__zero_reg__
 403 0056 00C0      		rjmp .L47
 263:catboard.c    **** 					keyboard_keys[0] = 0;
 404               		.loc 2 263 0
 405 0058 1092 0000 		sts keyboard_keys,__zero_reg__
 264:catboard.c    **** 					usb_keyboard_send();
 406               		.loc 2 264 0
 407 005c 0C94 0000 		jmp usb_keyboard_send
 408               	.LVL20:
 409               	.L48:
 268:catboard.c    **** 	} else if (press_time2) { // press2 pause
 410               		.loc 2 268 0
 411 0060 2091 0000 		lds r18,press_time2
 412 0064 3091 0000 		lds r19,press_time2+1
 413 0068 8091 0000 		lds r24,press_time
 414 006c 9091 0000 		lds r25,press_time+1
 415 0070 2115      		cp r18,__zero_reg__
 416 0072 3105      		cpc r19,__zero_reg__
 417 0074 01F0      		breq .L53
 269:catboard.c    **** 		if (press_time2<(press_time+(pressed[FN_KEY_ID] ? 5 : 30))) {
 418               		.loc 2 269 0
 419 0076 4091 0000 		lds r20,pressed+39
 420 007a 4423      		tst r20
 421 007c 01F0      		breq .L59
 422 007e 45E0      		ldi r20,lo8(5)
 423 0080 50E0      		ldi r21,0
 424 0082 00C0      		rjmp .L54
 425               	.L59:
 426 0084 4EE1      		ldi r20,lo8(30)
 427 0086 50E0      		ldi r21,0
 428               	.L54:
 269:catboard.c    **** 		if (press_time2<(press_time+(pressed[FN_KEY_ID] ? 5 : 30))) {
 429               		.loc 2 269 0 is_stmt 0 discriminator 3
 430 0088 840F      		add r24,r20
 431 008a 951F      		adc r25,r21
 432 008c 2817      		cp r18,r24
 433 008e 3907      		cpc r19,r25
 434 0090 00F4      		brsh .L55
 270:catboard.c    **** 			press_time2++;
 435               		.loc 2 270 0 is_stmt 1
 436 0092 2F5F      		subi r18,-1
 437 0094 3F4F      		sbci r19,-1
 438 0096 3093 0000 		sts press_time2+1,r19
 439 009a 2093 0000 		sts press_time2,r18
 440 009e 0895      		ret
 441               	.L55:
 272:catboard.c    **** 			repeat_time = 1;
 442               		.loc 2 272 0
 443 00a0 81E0      		ldi r24,lo8(1)
 444 00a2 90E0      		ldi r25,0
 445               	.L63:
 446 00a4 9093 0000 		sts repeat_time+1,r25
 447 00a8 8093 0000 		sts repeat_time,r24
 448 00ac 0895      		ret
 449               	.L53:
 274:catboard.c    **** 	} else if (release_time) { // release pause
 450               		.loc 2 274 0
 451 00ae 2091 0000 		lds r18,release_time
 452 00b2 3091 0000 		lds r19,release_time+1
 453 00b6 2115      		cp r18,__zero_reg__
 454 00b8 3105      		cpc r19,__zero_reg__
 455 00ba 01F0      		breq .L56
 275:catboard.c    **** 		if (release_time<(press_time+50)) {
 456               		.loc 2 275 0
 457 00bc C296      		adiw r24,50
 458 00be 2817      		cp r18,r24
 459 00c0 3907      		cpc r19,r25
 460 00c2 00F4      		brsh .L57
 276:catboard.c    **** 			release_time++;
 461               		.loc 2 276 0
 462 00c4 2F5F      		subi r18,-1
 463 00c6 3F4F      		sbci r19,-1
 464 00c8 3093 0000 		sts release_time+1,r19
 465 00cc 2093 0000 		sts release_time,r18
 466 00d0 0895      		ret
 467               	.L57:
 278:catboard.c    **** 			last_key = 0xFF;
 468               		.loc 2 278 0
 469 00d2 8FEF      		ldi r24,lo8(-1)
 470 00d4 8093 0000 		sts last_key,r24
 279:catboard.c    **** 			release_time = 0;
 471               		.loc 2 279 0
 472 00d8 1092 0000 		sts release_time+1,__zero_reg__
 473 00dc 1092 0000 		sts release_time,__zero_reg__
 280:catboard.c    **** 			press_time = 0;
 474               		.loc 2 280 0
 475 00e0 1092 0000 		sts press_time+1,__zero_reg__
 476 00e4 1092 0000 		sts press_time,__zero_reg__
 281:catboard.c    **** 			press_time2 = 0;
 477               		.loc 2 281 0
 478 00e8 1092 0000 		sts press_time2+1,__zero_reg__
 479 00ec 1092 0000 		sts press_time2,__zero_reg__
 480 00f0 0895      		ret
 481               	.L56:
 284:catboard.c    **** 	} else if (press_time) { // press1 pause
 482               		.loc 2 284 0
 483 00f2 0097      		sbiw r24,0
 484 00f4 01F0      		breq .L47
 285:catboard.c    **** 		if (press_time<250) {
 485               		.loc 2 285 0
 486 00f6 8A3F      		cpi r24,-6
 487 00f8 9105      		cpc r25,__zero_reg__
 488 00fa 00F4      		brsh .L58
 286:catboard.c    **** 			press_time++;
 489               		.loc 2 286 0
 490 00fc 0196      		adiw r24,1
 491 00fe 9093 0000 		sts press_time+1,r25
 492 0102 8093 0000 		sts press_time,r24
 493 0106 0895      		ret
 494               	.L58:
 288:catboard.c    **** 			press_time = 0;
 495               		.loc 2 288 0
 496 0108 1092 0000 		sts press_time+1,__zero_reg__
 497 010c 1092 0000 		sts press_time,__zero_reg__
 498               	.L47:
 499 0110 0895      		ret
 500               		.cfi_endproc
 501               	.LFE13:
 503               		.section	.text.send,"ax",@progbits
 504               	.global	send
 506               	send:
 507               	.LFB17:
 617:catboard.c    **** void send(void) {
 508               		.loc 2 617 0
 509               		.cfi_startproc
 510 0000 0F93      		push r16
 511               	.LCFI0:
 512               		.cfi_def_cfa_offset 3
 513               		.cfi_offset 16, -2
 514 0002 1F93      		push r17
 515               	.LCFI1:
 516               		.cfi_def_cfa_offset 4
 517               		.cfi_offset 17, -3
 518 0004 CF93      		push r28
 519               	.LCFI2:
 520               		.cfi_def_cfa_offset 5
 521               		.cfi_offset 28, -4
 522 0006 DF93      		push r29
 523               	.LCFI3:
 524               		.cfi_def_cfa_offset 6
 525               		.cfi_offset 29, -5
 526               	/* prologue: function */
 527               	/* frame size = 0 */
 528               	/* stack size = 4 */
 529               	.L__stack_usage = 4
 530               	.LVL21:
 531 0008 C0E0      		ldi r28,lo8(queue)
 532 000a D0E0      		ldi r29,hi8(queue)
 533 000c 00E0      		ldi r16,lo8(keyboard_keys)
 534 000e 10E0      		ldi r17,hi8(keyboard_keys)
 535               	.LVL22:
 536               	.L66:
 620:catboard.c    **** 		keyboard_keys[i] = get_code(queue[i]);
 537               		.loc 2 620 0 discriminator 2
 538 0010 8991      		ld r24,Y+
 539               	.LVL23:
 540 0012 0E94 0000 		call get_code
 541               	.LVL24:
 542 0016 F801      		movw r30,r16
 543 0018 8193      		st Z+,r24
 544 001a 8F01      		movw r16,r30
 545               	.LVL25:
 619:catboard.c    **** 	for (i=0; i<6; i++) {
 546               		.loc 2 619 0 discriminator 2
 547 001c F0E0      		ldi r31,hi8(queue+6)
 548 001e C030      		cpi r28,lo8(queue+6)
 549 0020 DF07      		cpc r29,r31
 550 0022 01F4      		brne .L66
 622:catboard.c    **** 	keyboard_modifier_keys = mod_keys;
 551               		.loc 2 622 0
 552 0024 8091 0000 		lds r24,mod_keys
 553 0028 8093 0000 		sts keyboard_modifier_keys,r24
 554               	/* epilogue start */
 624:catboard.c    **** }
 555               		.loc 2 624 0
 556 002c DF91      		pop r29
 557 002e CF91      		pop r28
 558               	.LVL26:
 559 0030 1F91      		pop r17
 560 0032 0F91      		pop r16
 623:catboard.c    **** 	usb_keyboard_send();
 561               		.loc 2 623 0
 562 0034 0C94 0000 		jmp usb_keyboard_send
 563               	.LVL27:
 564               		.cfi_endproc
 565               	.LFE17:
 567               		.section	.text.key_release,"ax",@progbits
 568               	.global	key_release
 570               	key_release:
 571               	.LFB15:
 470:catboard.c    **** void key_release(uint8_t key_id) {
 572               		.loc 2 470 0
 573               		.cfi_startproc
 574               	.LVL28:
 575 0000 CF93      		push r28
 576               	.LCFI4:
 577               		.cfi_def_cfa_offset 3
 578               		.cfi_offset 28, -2
 579 0002 DF93      		push r29
 580               	.LCFI5:
 581               		.cfi_def_cfa_offset 4
 582               		.cfi_offset 29, -3
 583               	/* prologue: function */
 584               	/* frame size = 0 */
 585               	/* stack size = 2 */
 586               	.L__stack_usage = 2
 587 0004 D82F      		mov r29,r24
 472:catboard.c    **** 	int8_t pressed_key_id = pressed[key_id];
 588               		.loc 2 472 0
 589 0006 282F      		mov r18,r24
 590 0008 30E0      		ldi r19,0
 591 000a D901      		movw r26,r18
 592 000c A050      		subi r26,lo8(-(pressed))
 593 000e B040      		sbci r27,hi8(-(pressed))
 594 0010 CC91      		ld r28,X
 595               	.LVL29:
 473:catboard.c    **** 	uint8_t key_code = ((pressed_key_id==KEY_PRESSED_FN) ? layer_fn[key_id] : layout[key_id]);
 596               		.loc 2 473 0
 597 0012 C130      		cpi r28,lo8(1)
 598 0014 01F4      		brne .L68
 473:catboard.c    **** 	uint8_t key_code = ((pressed_key_id==KEY_PRESSED_FN) ? layer_fn[key_id] : layout[key_id]);
 599               		.loc 2 473 0 is_stmt 0 discriminator 1
 600 0016 F901      		movw r30,r18
 601 0018 E050      		subi r30,lo8(-(layer_fn))
 602 001a F040      		sbci r31,hi8(-(layer_fn))
 603 001c 00C0      		rjmp .L152
 604               	.L68:
 473:catboard.c    **** 	uint8_t key_code = ((pressed_key_id==KEY_PRESSED_FN) ? layer_fn[key_id] : layout[key_id]);
 605               		.loc 2 473 0 discriminator 2
 606 001e E091 0000 		lds r30,layout
 607 0022 F091 0000 		lds r31,layout+1
 608 0026 E20F      		add r30,r18
 609 0028 F31F      		adc r31,r19
 610 002a 9081      		ld r25,Z
 611               	.LVL30:
 475:catboard.c    **** 		LED_OFF;
 612               		.loc 2 475 0 is_stmt 1 discriminator 2
 613 002c 5E9A      		sbi 0xb,6
 477:catboard.c    **** 	if (pressed_key_id==KEY_PRESSED_PREV && prev_layer) {
 614               		.loc 2 477 0 discriminator 2
 615 002e C630      		cpi r28,lo8(6)
 616 0030 01F4      		brne .L69
 477:catboard.c    **** 	if (pressed_key_id==KEY_PRESSED_PREV && prev_layer) {
 617               		.loc 2 477 0 is_stmt 0 discriminator 1
 618 0032 4091 0000 		lds r20,prev_layer
 619 0036 5091 0000 		lds r21,prev_layer+1
 620 003a 4115      		cp r20,__zero_reg__
 621 003c 5105      		cpc r21,__zero_reg__
 622 003e 01F0      		breq .L69
 478:catboard.c    **** 		key_code = prev_layer[key_id];
 623               		.loc 2 478 0 is_stmt 1
 624 0040 FA01      		movw r30,r20
 625 0042 E20F      		add r30,r18
 626 0044 F31F      		adc r31,r19
 627               	.LVL31:
 628               	.L152:
 629 0046 9081      		ld r25,Z
 630               	.LVL32:
 631               	.L69:
 480:catboard.c    **** 	pressed[key_id] = 0;
 632               		.loc 2 480 0
 633 0048 1C92      		st X,__zero_reg__
 482:catboard.c    **** 	if (key_code>=KEY_CB_START) { // Catboard keys release
 634               		.loc 2 482 0
 635 004a 9D36      		cpi r25,lo8(109)
 636 004c 00F4      		brsh .+2
 637 004e 00C0      		rjmp .L70
 483:catboard.c    **** 		if ((key_code==KEY_ALT_TAB || key_code==KEY_ALT_ENTER) && pressed_key_id!=KEY_PRESSED_ALT) { // A
 638               		.loc 2 483 0
 639 0050 9D37      		cpi r25,lo8(125)
 640 0052 01F4      		brne .+2
 641 0054 00C0      		rjmp .L71
 483:catboard.c    **** 		if ((key_code==KEY_ALT_TAB || key_code==KEY_ALT_ENTER) && pressed_key_id!=KEY_PRESSED_ALT) { // A
 642               		.loc 2 483 0 is_stmt 0 discriminator 2
 643 0056 9637      		cpi r25,lo8(118)
 644 0058 01F4      		brne .+2
 645 005a 00C0      		rjmp .L71
 486:catboard.c    **** 		} else if (key_code==KEY_LAYER1 && pressed_key_id==KEY_PRESSED_CTRL) { // Layer1: Ctrl release
 646               		.loc 2 486 0 is_stmt 1
 647 005c 9D36      		cpi r25,lo8(109)
 648 005e 01F0      		breq .+2
 649 0060 00C0      		rjmp .L73
 650 0062 8091 0000 		lds r24,mod_keys
 651               	.LVL33:
 486:catboard.c    **** 		} else if (key_code==KEY_LAYER1 && pressed_key_id==KEY_PRESSED_CTRL) { // Layer1: Ctrl release
 652               		.loc 2 486 0 is_stmt 0 discriminator 1
 653 0066 C530      		cpi r28,lo8(5)
 654 0068 01F4      		brne .L74
 487:catboard.c    **** 			mod_keys &= ~(KEY_CTRL);
 655               		.loc 2 487 0 is_stmt 1
 656 006a 8E7F      		andi r24,lo8(-2)
 657               	.L155:
 658 006c 8093 0000 		sts mod_keys,r24
 659               	/* epilogue start */
 593:catboard.c    **** }
 660               		.loc 2 593 0
 661 0070 DF91      		pop r29
 662 0072 CF91      		pop r28
 663               	.LVL34:
 488:catboard.c    **** 			send();
 664               		.loc 2 488 0
 665 0074 0C94 0000 		jmp send
 666               	.LVL35:
 667               	.L74:
 490:catboard.c    **** 			mod_keys &= ~(KEY_SHIFT);
 668               		.loc 2 490 0
 669 0078 8D7F      		andi r24,lo8(-3)
 670 007a 8093 0000 		sts mod_keys,r24
 491:catboard.c    **** 			send();
 671               		.loc 2 491 0
 672 007e 0E94 0000 		call send
 673               	.LVL36:
 492:catboard.c    **** 			if (last_key==key_id && press_time && press_time<50 && pressed_key_id!=KEY_PRESSED_SHIFT) {
 674               		.loc 2 492 0
 675 0082 8091 0000 		lds r24,last_key
 676 0086 8D13      		cpse r24,r29
 677 0088 00C0      		rjmp .L87
 492:catboard.c    **** 			if (last_key==key_id && press_time && press_time<50 && pressed_key_id!=KEY_PRESSED_SHIFT) {
 678               		.loc 2 492 0 is_stmt 0 discriminator 1
 679 008a 8091 0000 		lds r24,press_time
 680 008e 9091 0000 		lds r25,press_time+1
 681 0092 0197      		sbiw r24,1
 682 0094 C197      		sbiw r24,49
 683 0096 00F0      		brlo .+2
 684 0098 00C0      		rjmp .L87
 685 009a C430      		cpi r28,lo8(4)
 686 009c 01F4      		brne .+2
 687 009e 00C0      		rjmp .L87
 493:catboard.c    **** 				if (layout!=layer1) {
 688               		.loc 2 493 0 is_stmt 1
 689 00a0 8091 0000 		lds r24,layout
 690 00a4 9091 0000 		lds r25,layout+1
 691 00a8 20E0      		ldi r18,hi8(layer1)
 692 00aa 8030      		cpi r24,lo8(layer1)
 693 00ac 9207      		cpc r25,r18
 694 00ae 01F4      		brne .+2
 695 00b0 00C0      		rjmp .L87
 696               	.LBB46:
 494:catboard.c    **** 					if (layout==layer_fn) {
 697               		.loc 2 494 0
 698 00b2 8050      		subi r24,lo8(layer_fn)
 699 00b4 9040      		sbci r25,hi8(layer_fn)
 700 00b6 01F4      		brne .L78
 495:catboard.c    **** 						prev_layer = layer1;
 701               		.loc 2 495 0
 702 00b8 80E0      		ldi r24,lo8(layer1)
 703 00ba 90E0      		ldi r25,hi8(layer1)
 704 00bc 9093 0000 		sts prev_layer+1,r25
 705 00c0 8093 0000 		sts prev_layer,r24
 706 00c4 00C0      		rjmp .L79
 707               	.L78:
 497:catboard.c    **** 						layout = layer1;
 708               		.loc 2 497 0
 709 00c6 80E0      		ldi r24,lo8(layer1)
 710 00c8 90E0      		ldi r25,hi8(layer1)
 711 00ca 9093 0000 		sts layout+1,r25
 712 00ce 8093 0000 		sts layout,r24
 713               	.L79:
 499:catboard.c    **** 					change_layout();
 714               		.loc 2 499 0
 715 00d2 0E94 0000 		call change_layout
 716               	.LVL37:
 501:catboard.c    **** 					LED_RED_OFF;
 717               		.loc 2 501 0
 718 00d6 469A      		sbi 0x8,6
 502:catboard.c    **** 					if (led) LED_BLUE_ON;
 719               		.loc 2 502 0
 720 00d8 8091 0000 		lds r24,led
 721 00dc 8823      		tst r24
 722 00de 01F4      		brne .+2
 723 00e0 00C0      		rjmp .L87
 502:catboard.c    **** 					if (led) LED_BLUE_ON;
 724               		.loc 2 502 0 is_stmt 0 discriminator 1
 725 00e2 599A      		sbi 0xb,1
 726 00e4 00C0      		rjmp .L87
 727               	.LVL38:
 728               	.L73:
 729               	.LBE46:
 510:catboard.c    **** 		} else if (key_code==KEY_LAYER2) { // LAYER2
 730               		.loc 2 510 0 is_stmt 1
 731 00e6 9E36      		cpi r25,lo8(110)
 732 00e8 01F4      		brne .L81
 511:catboard.c    **** 			mod_keys &= ~(KEY_RIGHT_SHIFT);
 733               		.loc 2 511 0
 734 00ea 8091 0000 		lds r24,mod_keys
 735 00ee 8F7D      		andi r24,lo8(-33)
 736 00f0 8093 0000 		sts mod_keys,r24
 512:catboard.c    **** 			send();
 737               		.loc 2 512 0
 738 00f4 0E94 0000 		call send
 739               	.LVL39:
 513:catboard.c    **** 			if (last_key==key_id && press_time && press_time<50 && pressed_key_id!=KEY_PRESSED_SHIFT) {
 740               		.loc 2 513 0
 741 00f8 8091 0000 		lds r24,last_key
 742 00fc 8D13      		cpse r24,r29
 743 00fe 00C0      		rjmp .L87
 513:catboard.c    **** 			if (last_key==key_id && press_time && press_time<50 && pressed_key_id!=KEY_PRESSED_SHIFT) {
 744               		.loc 2 513 0 is_stmt 0 discriminator 1
 745 0100 8091 0000 		lds r24,press_time
 746 0104 9091 0000 		lds r25,press_time+1
 747 0108 0197      		sbiw r24,1
 748 010a C197      		sbiw r24,49
 749 010c 00F0      		brlo .+2
 750 010e 00C0      		rjmp .L87
 751 0110 C430      		cpi r28,lo8(4)
 752 0112 01F4      		brne .+2
 753 0114 00C0      		rjmp .L87
 514:catboard.c    **** 				if (layout!=layer2) {
 754               		.loc 2 514 0 is_stmt 1
 755 0116 8091 0000 		lds r24,layout
 756 011a 9091 0000 		lds r25,layout+1
 757 011e 20E0      		ldi r18,hi8(layer2)
 758 0120 8030      		cpi r24,lo8(layer2)
 759 0122 9207      		cpc r25,r18
 760 0124 01F0      		breq .L87
 761               	.LBB47:
 515:catboard.c    **** 					if (layout==layer_fn) {
 762               		.loc 2 515 0
 763 0126 8050      		subi r24,lo8(layer_fn)
 764 0128 9040      		sbci r25,hi8(layer_fn)
 765 012a 01F4      		brne .L85
 516:catboard.c    **** 						prev_layer = layer2;
 766               		.loc 2 516 0
 767 012c 80E0      		ldi r24,lo8(layer2)
 768 012e 90E0      		ldi r25,hi8(layer2)
 769 0130 9093 0000 		sts prev_layer+1,r25
 770 0134 8093 0000 		sts prev_layer,r24
 771 0138 00C0      		rjmp .L86
 772               	.L85:
 518:catboard.c    **** 						layout = layer2;
 773               		.loc 2 518 0
 774 013a 80E0      		ldi r24,lo8(layer2)
 775 013c 90E0      		ldi r25,hi8(layer2)
 776 013e 9093 0000 		sts layout+1,r25
 777 0142 8093 0000 		sts layout,r24
 778               	.L86:
 520:catboard.c    **** 					change_layout();
 779               		.loc 2 520 0
 780 0146 0E94 0000 		call change_layout
 781               	.LVL40:
 522:catboard.c    **** 					LED_BLUE_OFF;
 782               		.loc 2 522 0
 783 014a 5998      		cbi 0xb,1
 523:catboard.c    **** 					if (led) LED_RED_ON;
 784               		.loc 2 523 0
 785 014c 8091 0000 		lds r24,led
 786 0150 8823      		tst r24
 787 0152 01F0      		breq .L87
 523:catboard.c    **** 					if (led) LED_RED_ON;
 788               		.loc 2 523 0 is_stmt 0 discriminator 1
 789 0154 4698      		cbi 0x8,6
 790 0156 00C0      		rjmp .L87
 791               	.LVL41:
 792               	.L81:
 793               	.LBE47:
 531:catboard.c    **** 		} else if (key_code==KEY_MY_SHIFT) { // My Shift
 794               		.loc 2 531 0 is_stmt 1
 795 0158 9737      		cpi r25,lo8(119)
 796 015a 01F0      		breq .+2
 797 015c 00C0      		rjmp .L67
 532:catboard.c    **** 			mod_keys &= ~KEY_SHIFT;
 798               		.loc 2 532 0
 799 015e 8091 0000 		lds r24,mod_keys
 800 0162 8D7F      		andi r24,lo8(-3)
 801 0164 8093 0000 		sts mod_keys,r24
 533:catboard.c    **** 			send();
 802               		.loc 2 533 0
 803 0168 0E94 0000 		call send
 804               	.LVL42:
 534:catboard.c    **** 			if (last_key==key_id && press_time && press_time<50 && pressed_key_id!=KEY_PRESSED_MODS && ! mod
 805               		.loc 2 534 0
 806 016c 8091 0000 		lds r24,last_key
 807 0170 8D13      		cpse r24,r29
 808 0172 00C0      		rjmp .L87
 534:catboard.c    **** 			if (last_key==key_id && press_time && press_time<50 && pressed_key_id!=KEY_PRESSED_MODS && ! mod
 809               		.loc 2 534 0 is_stmt 0 discriminator 1
 810 0174 8091 0000 		lds r24,press_time
 811 0178 9091 0000 		lds r25,press_time+1
 812 017c 0197      		sbiw r24,1
 813 017e C197      		sbiw r24,49
 814 0180 00F4      		brsh .L87
 815 0182 C230      		cpi r28,lo8(2)
 816 0184 01F0      		breq .L87
 817 0186 8091 0000 		lds r24,mod_keys
 818 018a 8111      		cpse r24,__zero_reg__
 819 018c 00C0      		rjmp .L87
 535:catboard.c    **** 				usb_keyboard_press(KEY_SPACE, mod_keys);
 820               		.loc 2 535 0 is_stmt 1
 821 018e 60E0      		ldi r22,0
 822 0190 8CE2      		ldi r24,lo8(44)
 823 0192 0E94 0000 		call usb_keyboard_press
 824               	.LVL43:
 825               	.L87:
 537:catboard.c    **** 			last_key = 0xFF;
 826               		.loc 2 537 0
 827 0196 8FEF      		ldi r24,lo8(-1)
 828 0198 8093 0000 		sts last_key,r24
 829 019c 00C0      		rjmp .L106
 830               	.LVL44:
 831               	.L70:
 543:catboard.c    **** 	} else if (key_code>=KEY_LCTRL) { // Mod keys release
 832               		.loc 2 543 0
 833 019e 9536      		cpi r25,lo8(101)
 834 01a0 00F4      		brsh .+2
 835 01a2 00C0      		rjmp .L88
 544:catboard.c    **** 		if (os_mode==2 && key_code==KEY_LCTRL) {
 836               		.loc 2 544 0
 837 01a4 2091 0000 		lds r18,os_mode
 838               	.LVL45:
 839 01a8 8091 0000 		lds r24,mod_keys
 840               	.LVL46:
 841 01ac 2230      		cpi r18,lo8(2)
 842 01ae 01F4      		brne .L89
 544:catboard.c    **** 		if (os_mode==2 && key_code==KEY_LCTRL) {
 843               		.loc 2 544 0 is_stmt 0 discriminator 1
 844 01b0 9536      		cpi r25,lo8(101)
 845 01b2 01F4      		brne .L90
 846               	.L98:
 545:catboard.c    **** 			mod_keys &= ~KEY_GUI;
 847               		.loc 2 545 0 is_stmt 1
 848 01b4 877F      		andi r24,lo8(-9)
 849 01b6 00C0      		rjmp .L153
 850               	.L90:
 546:catboard.c    **** 		} else if ((os_mode==2 && key_code==KEY_RCTRL) || key_code==KEY_RGUI) {
 851               		.loc 2 546 0 discriminator 1
 852 01b8 9936      		cpi r25,lo8(105)
 853 01ba 01F4      		brne .L151
 854 01bc 00C0      		rjmp .L92
 855               	.L89:
 546:catboard.c    **** 		} else if ((os_mode==2 && key_code==KEY_RCTRL) || key_code==KEY_RGUI) {
 856               		.loc 2 546 0 is_stmt 0 discriminator 2
 857 01be 9C36      		cpi r25,lo8(108)
 858 01c0 01F4      		brne .L94
 859               	.L92:
 547:catboard.c    **** 			mod_keys &= ~KEY_RIGHT_GUI;
 860               		.loc 2 547 0 is_stmt 1
 861 01c2 8F77      		andi r24,lo8(127)
 862 01c4 00C0      		rjmp .L153
 863               	.L94:
 548:catboard.c    **** 		} else if (key_code==KEY_LCTRL) {
 864               		.loc 2 548 0
 865 01c6 9536      		cpi r25,lo8(101)
 866 01c8 01F4      		brne .L95
 549:catboard.c    **** 			mod_keys &= ~KEY_CTRL;
 867               		.loc 2 549 0
 868 01ca 8E7F      		andi r24,lo8(-2)
 869 01cc 00C0      		rjmp .L153
 870               	.L151:
 546:catboard.c    **** 		} else if ((os_mode==2 && key_code==KEY_RCTRL) || key_code==KEY_RGUI) {
 871               		.loc 2 546 0
 872 01ce 9C36      		cpi r25,lo8(108)
 873 01d0 01F0      		breq .L92
 874               	.L95:
 550:catboard.c    **** 		} else if (key_code==KEY_LSHIFT) {
 875               		.loc 2 550 0
 876 01d2 9636      		cpi r25,lo8(102)
 877 01d4 01F4      		brne .L96
 551:catboard.c    **** 			mod_keys &= ~KEY_SHIFT;
 878               		.loc 2 551 0
 879 01d6 8D7F      		andi r24,lo8(-3)
 880 01d8 00C0      		rjmp .L153
 881               	.L96:
 552:catboard.c    **** 		} else if (key_code==KEY_LALT) {
 882               		.loc 2 552 0
 883 01da 9736      		cpi r25,lo8(103)
 884 01dc 01F4      		brne .L97
 553:catboard.c    **** 			mod_keys &= ~KEY_ALT;
 885               		.loc 2 553 0
 886 01de 8B7F      		andi r24,lo8(-5)
 887 01e0 00C0      		rjmp .L153
 888               	.L97:
 554:catboard.c    **** 		} else if (key_code==KEY_LGUI) {
 889               		.loc 2 554 0
 890 01e2 9836      		cpi r25,lo8(104)
 891 01e4 01F0      		breq .L98
 556:catboard.c    **** 		} else if (key_code==KEY_RCTRL) {
 892               		.loc 2 556 0
 893 01e6 9936      		cpi r25,lo8(105)
 894 01e8 01F4      		brne .L99
 557:catboard.c    **** 			mod_keys &= ~KEY_RIGHT_CTRL;
 895               		.loc 2 557 0
 896 01ea 8F7E      		andi r24,lo8(-17)
 897 01ec 00C0      		rjmp .L153
 898               	.L99:
 558:catboard.c    **** 		} else if (key_code==KEY_RSHIFT) {
 899               		.loc 2 558 0
 900 01ee 9A36      		cpi r25,lo8(106)
 901 01f0 01F4      		brne .L100
 559:catboard.c    **** 			mod_keys &= ~KEY_RIGHT_SHIFT;
 902               		.loc 2 559 0
 903 01f2 8F7D      		andi r24,lo8(-33)
 904 01f4 00C0      		rjmp .L153
 905               	.L100:
 561:catboard.c    **** 			mod_keys &= ~KEY_RIGHT_ALT;
 906               		.loc 2 561 0
 907 01f6 8F7B      		andi r24,lo8(-65)
 908               	.L153:
 909 01f8 8093 0000 		sts mod_keys,r24
 565:catboard.c    **** 		send();
 910               		.loc 2 565 0
 911 01fc 0E94 0000 		call send
 912               	.LVL47:
 566:catboard.c    **** 		press_time = 0;
 913               		.loc 2 566 0
 914 0200 1092 0000 		sts press_time+1,__zero_reg__
 915 0204 1092 0000 		sts press_time,__zero_reg__
 567:catboard.c    **** 		press_time2 = 0;
 916               		.loc 2 567 0
 917 0208 1092 0000 		sts press_time2+1,__zero_reg__
 918 020c 1092 0000 		sts press_time2,__zero_reg__
 568:catboard.c    **** 		release_time = 0;
 919               		.loc 2 568 0
 920 0210 1092 0000 		sts release_time+1,__zero_reg__
 921 0214 1092 0000 		sts release_time,__zero_reg__
 569:catboard.c    **** 		repeat_time = 0;
 922               		.loc 2 569 0
 923 0218 1092 0000 		sts repeat_time+1,__zero_reg__
 924 021c 1092 0000 		sts repeat_time,__zero_reg__
 570:catboard.c    **** 		last_key = 0;
 925               		.loc 2 570 0
 926 0220 1092 0000 		sts last_key,__zero_reg__
 927 0224 00C0      		rjmp .L67
 928               	.LVL48:
 929               	.L88:
 930 0226 E0E0      		ldi r30,lo8(queue)
 931 0228 F0E0      		ldi r31,hi8(queue)
 543:catboard.c    **** 	} else if (key_code>=KEY_LCTRL) { // Mod keys release
 932               		.loc 2 543 0
 933 022a 80E0      		ldi r24,0
 934               	.LVL49:
 935               	.L104:
 573:catboard.c    **** 			if (queue[i]==key_id) {
 936               		.loc 2 573 0
 937 022c 9191      		ld r25,Z+
 938 022e 9D17      		cp r25,r29
 939 0230 01F0      		breq .L102
 572:catboard.c    **** 		for (i=0; i<6; i++) {
 940               		.loc 2 572 0
 941 0232 8F5F      		subi r24,lo8(-(1))
 942               	.LVL50:
 943 0234 8630      		cpi r24,lo8(6)
 944 0236 01F4      		brne .L104
 945               	.L102:
 577:catboard.c    **** 		for (; i<6; i++) {
 946               		.loc 2 577 0 discriminator 1
 947 0238 8630      		cpi r24,lo8(6)
 948 023a 01F0      		breq .L156
 578:catboard.c    **** 			queue[i] = queue[i+1];
 949               		.loc 2 578 0 discriminator 2
 950 023c E82F      		mov r30,r24
 951 023e F0E0      		ldi r31,0
 952 0240 E050      		subi r30,lo8(-(queue))
 953 0242 F040      		sbci r31,hi8(-(queue))
 954 0244 9181      		ldd r25,Z+1
 955 0246 9083      		st Z,r25
 577:catboard.c    **** 		for (; i<6; i++) {
 956               		.loc 2 577 0 discriminator 2
 957 0248 8F5F      		subi r24,lo8(-(1))
 958               	.LVL51:
 959 024a 00C0      		rjmp .L102
 960               	.L156:
 580:catboard.c    **** 		send();
 961               		.loc 2 580 0
 962 024c 0E94 0000 		call send
 963               	.LVL52:
 582:catboard.c    **** 		if (last_key==key_id) { // realise time
 964               		.loc 2 582 0
 965 0250 8091 0000 		lds r24,last_key
 966 0254 8D13      		cpse r24,r29
 967 0256 00C0      		rjmp .L106
 583:catboard.c    **** 			press_time2 = 0;
 968               		.loc 2 583 0
 969 0258 1092 0000 		sts press_time2+1,__zero_reg__
 970 025c 1092 0000 		sts press_time2,__zero_reg__
 584:catboard.c    **** 			release_time = 1;
 971               		.loc 2 584 0
 972 0260 81E0      		ldi r24,lo8(1)
 973 0262 90E0      		ldi r25,0
 974 0264 9093 0000 		sts release_time+1,r25
 975 0268 8093 0000 		sts release_time,r24
 976 026c 00C0      		rjmp .L154
 977               	.L106:
 587:catboard.c    **** 			press_time = 0;
 978               		.loc 2 587 0
 979 026e 1092 0000 		sts press_time+1,__zero_reg__
 980 0272 1092 0000 		sts press_time,__zero_reg__
 588:catboard.c    **** 			press_time2 = 0;
 981               		.loc 2 588 0
 982 0276 1092 0000 		sts press_time2+1,__zero_reg__
 983 027a 1092 0000 		sts press_time2,__zero_reg__
 589:catboard.c    **** 			release_time = 0;
 984               		.loc 2 589 0
 985 027e 1092 0000 		sts release_time+1,__zero_reg__
 986 0282 1092 0000 		sts release_time,__zero_reg__
 987               	.L154:
 590:catboard.c    **** 			repeat_time = 0;
 988               		.loc 2 590 0
 989 0286 1092 0000 		sts repeat_time+1,__zero_reg__
 990 028a 1092 0000 		sts repeat_time,__zero_reg__
 991 028e 00C0      		rjmp .L67
 992               	.LVL53:
 993               	.L71:
 483:catboard.c    **** 		if ((key_code==KEY_ALT_TAB || key_code==KEY_ALT_ENTER) && pressed_key_id!=KEY_PRESSED_ALT) { // A
 994               		.loc 2 483 0
 995 0290 C330      		cpi r28,lo8(3)
 996 0292 01F4      		brne .+2
 997 0294 00C0      		rjmp .L73
 484:catboard.c    **** 			mod_keys &= ~(KEY_ALT);
 998               		.loc 2 484 0
 999 0296 8091 0000 		lds r24,mod_keys
 1000 029a 8B7F      		andi r24,lo8(-5)
 1001 029c 00C0      		rjmp .L155
 1002               	.LVL54:
 1003               	.L67:
 1004               	/* epilogue start */
 593:catboard.c    **** }
 1005               		.loc 2 593 0
 1006 029e DF91      		pop r29
 1007               	.LVL55:
 1008 02a0 CF91      		pop r28
 1009               	.LVL56:
 1010 02a2 0895      		ret
 1011               		.cfi_endproc
 1012               	.LFE15:
 1014               		.section	.text.restore_leds,"ax",@progbits
 1015               	.global	restore_leds
 1017               	restore_leds:
 1018               	.LFB19:
 641:catboard.c    **** 
 642:catboard.c    **** void restore_leds(void)
 643:catboard.c    **** {
 1019               		.loc 2 643 0
 1020               		.cfi_startproc
 1021               	/* prologue: function */
 1022               	/* frame size = 0 */
 1023               	/* stack size = 0 */
 1024               	.L__stack_usage = 0
 644:catboard.c    **** 	LED_RED_OFF;
 1025               		.loc 2 644 0
 1026 0000 469A      		sbi 0x8,6
 645:catboard.c    **** 	LED_BLUE_OFF;
 1027               		.loc 2 645 0
 1028 0002 5998      		cbi 0xb,1
 646:catboard.c    **** 	if (layout==layer1 || prev_layer==layer1) LED_BLUE_ON;
 1029               		.loc 2 646 0
 1030 0004 8091 0000 		lds r24,layout
 1031 0008 9091 0000 		lds r25,layout+1
 1032 000c 8050      		subi r24,lo8(layer1)
 1033 000e 9040      		sbci r25,hi8(layer1)
 1034 0010 01F0      		breq .L158
 1035               		.loc 2 646 0 is_stmt 0 discriminator 2
 1036 0012 8091 0000 		lds r24,prev_layer
 1037 0016 9091 0000 		lds r25,prev_layer+1
 1038 001a 8050      		subi r24,lo8(layer1)
 1039 001c 9040      		sbci r25,hi8(layer1)
 1040 001e 01F4      		brne .L159
 1041               	.L158:
 1042               		.loc 2 646 0 discriminator 1
 1043 0020 599A      		sbi 0xb,1
 1044               	.L159:
 647:catboard.c    **** 	if (layout==layer2 || prev_layer==layer2) LED_RED_ON;
 1045               		.loc 2 647 0 is_stmt 1
 1046 0022 8091 0000 		lds r24,layout
 1047 0026 9091 0000 		lds r25,layout+1
 1048 002a 8050      		subi r24,lo8(layer2)
 1049 002c 9040      		sbci r25,hi8(layer2)
 1050 002e 01F0      		breq .L160
 1051               		.loc 2 647 0 is_stmt 0 discriminator 2
 1052 0030 8091 0000 		lds r24,prev_layer
 1053 0034 9091 0000 		lds r25,prev_layer+1
 1054 0038 8050      		subi r24,lo8(layer2)
 1055 003a 9040      		sbci r25,hi8(layer2)
 1056 003c 01F4      		brne .L157
 1057               	.L160:
 1058               	.LBB50:
 1059               		.loc 2 647 0
 1060 003e 4698      		cbi 0x8,6
 1061               	.L157:
 1062 0040 0895      		ret
 1063               	.LBE50:
 1064               		.cfi_endproc
 1065               	.LFE19:
 1067               		.section	.text.wait,"ax",@progbits
 1068               	.global	wait
 1070               	wait:
 1071               	.LFB21:
 648:catboard.c    **** }
 649:catboard.c    **** 
 650:catboard.c    **** void blink_leds(void)
 651:catboard.c    **** {	
 652:catboard.c    **** 	LED_RED_OFF;
 653:catboard.c    **** 	LED_BLUE_OFF;
 654:catboard.c    **** 	wait(150);
 655:catboard.c    **** 	LED_RED_ON;
 656:catboard.c    **** 	LED_BLUE_ON;
 657:catboard.c    **** 	wait(100);
 658:catboard.c    **** 	LED_RED_OFF;
 659:catboard.c    **** 	LED_BLUE_OFF;
 660:catboard.c    **** 	restore_leds();
 661:catboard.c    **** }
 662:catboard.c    **** 
 663:catboard.c    **** void wait(uint8_t so_much)
 664:catboard.c    **** {
 1072               		.loc 2 664 0 is_stmt 1
 1073               		.cfi_startproc
 1074               	.LVL57:
 1075               	/* prologue: function */
 1076               	/* frame size = 0 */
 1077               	/* stack size = 0 */
 1078               	.L__stack_usage = 0
 665:catboard.c    **** 	uint8_t timeout=UDFNUML+so_much;
 1079               		.loc 2 665 0
 1080 0000 9091 E400 		lds r25,228
 1081 0004 980F      		add r25,r24
 1082               	.LVL58:
 1083               	.L170:
 666:catboard.c    **** 	while(1)
 667:catboard.c    **** 	{
 668:catboard.c    **** 		if(timeout==UDFNUML) break;
 1084               		.loc 2 668 0
 1085 0006 8091 E400 		lds r24,228
 1086 000a 9813      		cpse r25,r24
 1087 000c 00C0      		rjmp .L170
 1088               	/* epilogue start */
 669:catboard.c    **** 	}
 670:catboard.c    **** }...
 1089               		.loc 2 670 0
 1090 000e 0895      		ret
 1091               		.cfi_endproc
 1092               	.LFE21:
 1094               		.section	.text.blink_leds,"ax",@progbits
 1095               	.global	blink_leds
 1097               	blink_leds:
 1098               	.LFB20:
 651:catboard.c    **** {	
 1099               		.loc 2 651 0
 1100               		.cfi_startproc
 1101               	/* prologue: function */
 1102               	/* frame size = 0 */
 1103               	/* stack size = 0 */
 1104               	.L__stack_usage = 0
 652:catboard.c    **** 	LED_RED_OFF;
 1105               		.loc 2 652 0
 1106 0000 469A      		sbi 0x8,6
 653:catboard.c    **** 	LED_BLUE_OFF;
 1107               		.loc 2 653 0
 1108 0002 5998      		cbi 0xb,1
 654:catboard.c    **** 	wait(150);
 1109               		.loc 2 654 0
 1110 0004 86E9      		ldi r24,lo8(-106)
 1111 0006 90E0      		ldi r25,0
 1112 0008 0E94 0000 		call wait
 1113               	.LVL59:
 655:catboard.c    **** 	LED_RED_ON;
 1114               		.loc 2 655 0
 1115 000c 4698      		cbi 0x8,6
 656:catboard.c    **** 	LED_BLUE_ON;
 1116               		.loc 2 656 0
 1117 000e 599A      		sbi 0xb,1
 657:catboard.c    **** 	wait(100);
 1118               		.loc 2 657 0
 1119 0010 84E6      		ldi r24,lo8(100)
 1120 0012 90E0      		ldi r25,0
 1121 0014 0E94 0000 		call wait
 1122               	.LVL60:
 658:catboard.c    **** 	LED_RED_OFF;
 1123               		.loc 2 658 0
 1124 0018 469A      		sbi 0x8,6
 659:catboard.c    **** 	LED_BLUE_OFF;
 1125               		.loc 2 659 0
 1126 001a 5998      		cbi 0xb,1
 660:catboard.c    **** 	restore_leds();
 1127               		.loc 2 660 0
 1128 001c 0C94 0000 		jmp restore_leds
 1129               	.LVL61:
 1130               		.cfi_endproc
 1131               	.LFE20:
 1133               		.section	.text.key_press,"ax",@progbits
 1134               	.global	key_press
 1136               	key_press:
 1137               	.LFB14:
 293:catboard.c    **** void key_press(uint8_t key_id) {
 1138               		.loc 2 293 0
 1139               		.cfi_startproc
 1140               	.LVL62:
 1141 0000 CF93      		push r28
 1142               	.LCFI6:
 1143               		.cfi_def_cfa_offset 3
 1144               		.cfi_offset 28, -2
 1145               	/* prologue: function */
 1146               	/* frame size = 0 */
 1147               	/* stack size = 1 */
 1148               	.L__stack_usage = 1
 1149 0002 C82F      		mov r28,r24
 295:catboard.c    **** 	uint8_t mods_pressed = (mod_keys & (KEY_CTRL|KEY_RIGHT_CTRL|KEY_ALT|KEY_RIGHT_ALT|KEY_GUI|KEY_RIGH
 1150               		.loc 2 295 0
 1151 0004 9091 0000 		lds r25,mod_keys
 1152 0008 9D7D      		andi r25,lo8(-35)
 1153               	.LVL63:
 296:catboard.c    **** 	pressed[key_id] = (pressed[FN_KEY_ID] ? KEY_PRESSED_FN : (mods_pressed ? KEY_PRESSED_MODS : -1));
 1154               		.loc 2 296 0
 1155 000a 282F      		mov r18,r24
 1156 000c 30E0      		ldi r19,0
 1157 000e 8091 0000 		lds r24,pressed+39
 1158               	.LVL64:
 1159 0012 8111      		cpse r24,__zero_reg__
 1160 0014 00C0      		rjmp .L224
 296:catboard.c    **** 	pressed[key_id] = (pressed[FN_KEY_ID] ? KEY_PRESSED_FN : (mods_pressed ? KEY_PRESSED_MODS : -1));
 1161               		.loc 2 296 0 is_stmt 0 discriminator 1
 1162 0016 9923      		tst r25
 1163 0018 01F0      		breq .L225
 296:catboard.c    **** 	pressed[key_id] = (pressed[FN_KEY_ID] ? KEY_PRESSED_FN : (mods_pressed ? KEY_PRESSED_MODS : -1));
 1164               		.loc 2 296 0
 1165 001a 82E0      		ldi r24,lo8(2)
 1166 001c 00C0      		rjmp .L173
 1167               	.L224:
 1168 001e 81E0      		ldi r24,lo8(1)
 1169 0020 00C0      		rjmp .L173
 1170               	.L225:
 1171 0022 8FEF      		ldi r24,lo8(-1)
 1172               	.L173:
 296:catboard.c    **** 	pressed[key_id] = (pressed[FN_KEY_ID] ? KEY_PRESSED_FN : (mods_pressed ? KEY_PRESSED_MODS : -1));
 1173               		.loc 2 296 0 discriminator 5
 1174 0024 F901      		movw r30,r18
 1175 0026 E050      		subi r30,lo8(-(pressed))
 1176 0028 F040      		sbci r31,hi8(-(pressed))
 1177 002a 8083      		st Z,r24
 298:catboard.c    **** 	if (key_id==FN_KEY_ID && led==1)	{
 1178               		.loc 2 298 0 is_stmt 1 discriminator 5
 1179 002c C732      		cpi r28,lo8(39)
 1180 002e 01F4      		brne .L174
 298:catboard.c    **** 	if (key_id==FN_KEY_ID && led==1)	{
 1181               		.loc 2 298 0 is_stmt 0 discriminator 1
 1182 0030 8091 0000 		lds r24,led
 1183 0034 8130      		cpi r24,lo8(1)
 1184 0036 01F4      		brne .L174
 299:catboard.c    **** 		LED_ON;
 1185               		.loc 2 299 0 is_stmt 1
 1186 0038 5E98      		cbi 0xb,6
 1187               	.L174:
 302:catboard.c    **** 	uint8_t key_code = ((pressed[key_id]==KEY_PRESSED_FN) ? layer_fn[key_id] : layout[key_id]);
 1188               		.loc 2 302 0
 1189 003a 8081      		ld r24,Z
 1190 003c 8130      		cpi r24,lo8(1)
 1191 003e 01F4      		brne .L175
 302:catboard.c    **** 	uint8_t key_code = ((pressed[key_id]==KEY_PRESSED_FN) ? layer_fn[key_id] : layout[key_id]);
 1192               		.loc 2 302 0 is_stmt 0 discriminator 1
 1193 0040 D901      		movw r26,r18
 1194 0042 A050      		subi r26,lo8(-(layer_fn))
 1195 0044 B040      		sbci r27,hi8(-(layer_fn))
 1196 0046 00C0      		rjmp .L263
 1197               	.L175:
 302:catboard.c    **** 	uint8_t key_code = ((pressed[key_id]==KEY_PRESSED_FN) ? layer_fn[key_id] : layout[key_id]);
 1198               		.loc 2 302 0 discriminator 2
 1199 0048 A091 0000 		lds r26,layout
 1200 004c B091 0000 		lds r27,layout+1
 1201 0050 A20F      		add r26,r18
 1202 0052 B31F      		adc r27,r19
 1203               	.L263:
 1204 0054 8C91      		ld r24,X
 1205               	.LVL65:
 303:catboard.c    **** 	if (key_code==NULL) {
 1206               		.loc 2 303 0 is_stmt 1 discriminator 2
 1207 0056 8111      		cpse r24,__zero_reg__
 1208 0058 00C0      		rjmp .L177
 304:catboard.c    **** 		key_code = layout[key_id];
 1209               		.loc 2 304 0
 1210 005a A091 0000 		lds r26,layout
 1211 005e B091 0000 		lds r27,layout+1
 1212 0062 A20F      		add r26,r18
 1213 0064 B31F      		adc r27,r19
 1214 0066 8C91      		ld r24,X
 1215               	.LVL66:
 305:catboard.c    **** 		pressed[key_id] = (mods_pressed ? KEY_PRESSED_MODS : -1);
 1216               		.loc 2 305 0
 1217 0068 9923      		tst r25
 1218 006a 01F0      		breq .L226
 1219 006c 92E0      		ldi r25,lo8(2)
 1220               	.LVL67:
 1221 006e 00C0      		rjmp .L178
 1222               	.LVL68:
 1223               	.L226:
 1224 0070 9FEF      		ldi r25,lo8(-1)
 1225               	.LVL69:
 1226               	.L178:
 305:catboard.c    **** 		pressed[key_id] = (mods_pressed ? KEY_PRESSED_MODS : -1);
 1227               		.loc 2 305 0 is_stmt 0 discriminator 3
 1228 0072 9083      		st Z,r25
 306:catboard.c    **** 		if (key_code==NULL && prev_layer && ! mod_keys) {
 1229               		.loc 2 306 0 is_stmt 1 discriminator 3
 1230 0074 8111      		cpse r24,__zero_reg__
 1231 0076 00C0      		rjmp .L177
 306:catboard.c    **** 		if (key_code==NULL && prev_layer && ! mod_keys) {
 1232               		.loc 2 306 0 is_stmt 0 discriminator 1
 1233 0078 4091 0000 		lds r20,prev_layer
 1234 007c 5091 0000 		lds r21,prev_layer+1
 1235 0080 4115      		cp r20,__zero_reg__
 1236 0082 5105      		cpc r21,__zero_reg__
 1237 0084 01F0      		breq .L177
 1238 0086 9091 0000 		lds r25,mod_keys
 1239 008a 9111      		cpse r25,__zero_reg__
 1240 008c 00C0      		rjmp .L177
 307:catboard.c    **** 			key_code = prev_layer[key_id];
 1241               		.loc 2 307 0 is_stmt 1
 1242 008e DA01      		movw r26,r20
 1243 0090 A20F      		add r26,r18
 1244 0092 B31F      		adc r27,r19
 1245 0094 8C91      		ld r24,X
 1246               	.LVL70:
 308:catboard.c    **** 			pressed[key_id] = KEY_PRESSED_PREV;
 1247               		.loc 2 308 0
 1248 0096 96E0      		ldi r25,lo8(6)
 1249 0098 9083      		st Z,r25
 1250               	.L177:
 312:catboard.c    **** 	if (locked && key_code!=KEY_LOCK) return;
 1251               		.loc 2 312 0
 1252 009a 9091 0000 		lds r25,locked
 1253 009e 9923      		tst r25
 1254 00a0 01F0      		breq .L179
 312:catboard.c    **** 	if (locked && key_code!=KEY_LOCK) return;
 1255               		.loc 2 312 0 is_stmt 0 discriminator 1
 1256 00a2 8A37      		cpi r24,lo8(122)
 1257 00a4 01F0      		breq .+2
 1258 00a6 00C0      		rjmp .L172
 1259 00a8 00C0      		rjmp .L272
 1260               	.L179:
 314:catboard.c    **** 	if (key_code>=KEY_CB_START) { // Catboard keys
 1261               		.loc 2 314 0 is_stmt 1
 1262 00aa 8D36      		cpi r24,lo8(109)
 1263 00ac 00F4      		brsh .+2
 1264 00ae 00C0      		rjmp .L182
 315:catboard.c    **** 		if (key_code==KEY_ALT_TAB) { // AltTab press
 1265               		.loc 2 315 0
 1266 00b0 8D37      		cpi r24,lo8(125)
 1267 00b2 01F4      		brne .L183
 316:catboard.c    **** 			if (pressed[key_id]==KEY_PRESSED_FN) { // Fn + AltTab
 1268               		.loc 2 316 0
 1269 00b4 8081      		ld r24,Z
 1270               	.LVL71:
 1271 00b6 8130      		cpi r24,lo8(1)
 1272 00b8 01F4      		brne .L184
 317:catboard.c    **** 				usb_keyboard_press(KEY_TAB, KEY_ALT);
 1273               		.loc 2 317 0
 1274 00ba 64E0      		ldi r22,lo8(4)
 1275 00bc 8BE2      		ldi r24,lo8(43)
 1276 00be 00C0      		rjmp .L266
 1277               	.L184:
 319:catboard.c    **** 				if (! mod_keys) {
 1278               		.loc 2 319 0
 1279 00c0 8091 0000 		lds r24,mod_keys
 1280 00c4 8111      		cpse r24,__zero_reg__
 1281 00c6 00C0      		rjmp .L186
 320:catboard.c    **** 					mod_keys |= (KEY_ALT);
 1282               		.loc 2 320 0
 1283 00c8 84E0      		ldi r24,lo8(4)
 1284 00ca 8093 0000 		sts mod_keys,r24
 1285               	.LVL72:
 1286 00ce 00C0      		rjmp .L187
 1287               	.LVL73:
 1288               	.L186:
 322:catboard.c    **** 					pressed[key_id] = KEY_PRESSED_ALT;
 1289               		.loc 2 322 0
 1290 00d0 83E0      		ldi r24,lo8(3)
 1291 00d2 8083      		st Z,r24
 1292               	.LVL74:
 1293               	.L187:
 324:catboard.c    **** 				keyboard_modifier_keys = mod_keys;
 1294               		.loc 2 324 0
 1295 00d4 8091 0000 		lds r24,mod_keys
 1296 00d8 8093 0000 		sts keyboard_modifier_keys,r24
 325:catboard.c    **** 				keyboard_keys[0] = KEY_TAB;
 1297               		.loc 2 325 0
 1298 00dc 8BE2      		ldi r24,lo8(43)
 1299 00de 00C0      		rjmp .L269
 1300               	.LVL75:
 1301               	.L183:
 330:catboard.c    **** 		} else if (key_code==KEY_ALT_ENTER) {
 1302               		.loc 2 330 0
 1303 00e0 8637      		cpi r24,lo8(118)
 1304 00e2 01F4      		brne .L188
 331:catboard.c    **** 			if (!mod_keys) {
 1305               		.loc 2 331 0
 1306 00e4 8091 0000 		lds r24,mod_keys
 1307               	.LVL76:
 1308 00e8 8111      		cpse r24,__zero_reg__
 1309 00ea 00C0      		rjmp .L189
 332:catboard.c    **** 				mod_keys |= (KEY_ALT);
 1310               		.loc 2 332 0
 1311 00ec 84E0      		ldi r24,lo8(4)
 1312 00ee 8093 0000 		sts mod_keys,r24
 1313               	.LVL77:
 1314 00f2 00C0      		rjmp .L190
 1315               	.LVL78:
 1316               	.L189:
 334:catboard.c    **** 					pressed[key_id] = KEY_PRESSED_ALT;
 1317               		.loc 2 334 0
 1318 00f4 83E0      		ldi r24,lo8(3)
 1319 00f6 8083      		st Z,r24
 1320               	.LVL79:
 1321               	.L190:
 336:catboard.c    **** 				keyboard_modifier_keys = mod_keys;
 1322               		.loc 2 336 0 discriminator 4
 1323 00f8 8091 0000 		lds r24,mod_keys
 1324 00fc 8093 0000 		sts keyboard_modifier_keys,r24
 337:catboard.c    **** 				keyboard_keys[0] = KEY_ENTER;
 1325               		.loc 2 337 0 discriminator 4
 1326 0100 88E2      		ldi r24,lo8(40)
 1327               	.L269:
 1328 0102 8093 0000 		sts keyboard_keys,r24
 338:catboard.c    **** 				usb_keyboard_send();
 1329               		.loc 2 338 0 discriminator 4
 1330 0106 0E94 0000 		call usb_keyboard_send
 1331               	.LVL80:
 1332               	.LBB51:
 1333               	.LBB52:
 1334               		.loc 3 164 0 discriminator 4
 1335 010a 2FEF      		ldi r18,lo8(159999)
 1336 010c 80E7      		ldi r24,hi8(159999)
 1337 010e 92E0      		ldi r25,hlo8(159999)
 1338 0110 2150      		1: subi r18,1
 1339 0112 8040      		sbci r24,0
 1340 0114 9040      		sbci r25,0
 1341 0116 01F4      		brne 1b
 1342 0118 00C0      		rjmp .
 1343 011a 0000      		nop
 1344 011c 00C0      		rjmp .L265
 1345               	.LVL81:
 1346               	.L188:
 1347               	.LBE52:
 1348               	.LBE51:
 341:catboard.c    **** 		} else if (key_code==KEY_FN_LOCK) { // FnLock
 1349               		.loc 2 341 0
 1350 011e 8E37      		cpi r24,lo8(126)
 1351 0120 01F4      		brne .L191
 342:catboard.c    **** 			if (pressed[key_id]==KEY_PRESSED_FN && (mod_keys & (KEY_SHIFT|KEY_RIGHT_SHIFT))) {
 1352               		.loc 2 342 0
 1353 0122 8081      		ld r24,Z
 1354               	.LVL82:
 1355 0124 8130      		cpi r24,lo8(1)
 1356 0126 01F0      		breq .+2
 1357 0128 00C0      		rjmp .L185
 342:catboard.c    **** 			if (pressed[key_id]==KEY_PRESSED_FN && (mod_keys & (KEY_SHIFT|KEY_RIGHT_SHIFT))) {
 1358               		.loc 2 342 0 is_stmt 0 discriminator 1
 1359 012a 8091 0000 		lds r24,mod_keys
 1360 012e 8272      		andi r24,lo8(34)
 1361 0130 01F4      		brne .+2
 1362 0132 00C0      		rjmp .L185
 343:catboard.c    **** 				if (prev_layer) { // FnLock Off
 1363               		.loc 2 343 0 is_stmt 1
 1364 0134 2091 0000 		lds r18,prev_layer
 1365 0138 3091 0000 		lds r19,prev_layer+1
 1366               	.LVL83:
 1367 013c 2115      		cp r18,__zero_reg__
 1368 013e 3105      		cpc r19,__zero_reg__
 1369 0140 01F0      		breq .L194
 1370               	.LBB53:
 344:catboard.c    **** 					layout = prev_layer;
 1371               		.loc 2 344 0
 1372 0142 3093 0000 		sts layout+1,r19
 1373 0146 2093 0000 		sts layout,r18
 345:catboard.c    **** 					restore_leds();
 1374               		.loc 2 345 0
 1375 014a 0E94 0000 		call restore_leds
 1376               	.LVL84:
 346:catboard.c    **** 					prev_layer = 0;
 1377               		.loc 2 346 0
 1378 014e 1092 0000 		sts prev_layer+1,__zero_reg__
 1379 0152 1092 0000 		sts prev_layer,__zero_reg__
 1380               	.LBE53:
 1381 0156 00C0      		rjmp .L185
 1382               	.LVL85:
 1383               	.L194:
 348:catboard.c    **** 					prev_layer = layout;
 1384               		.loc 2 348 0
 1385 0158 8091 0000 		lds r24,layout
 1386 015c 9091 0000 		lds r25,layout+1
 1387 0160 9093 0000 		sts prev_layer+1,r25
 1388 0164 8093 0000 		sts prev_layer,r24
 349:catboard.c    **** 					layout = layer_fnlock;
 1389               		.loc 2 349 0
 1390 0168 80E0      		ldi r24,lo8(layer_fnlock)
 1391 016a 90E0      		ldi r25,hi8(layer_fnlock)
 1392 016c 9093 0000 		sts layout+1,r25
 1393 0170 8093 0000 		sts layout,r24
 350:catboard.c    **** 					LED_RED_ON;
 1394               		.loc 2 350 0
 1395 0174 4698      		cbi 0x8,6
 351:catboard.c    **** 					LED_BLUE_ON;
 1396               		.loc 2 351 0
 1397 0176 599A      		sbi 0xb,1
 1398 0178 00C0      		rjmp .L185
 1399               	.LVL86:
 1400               	.L191:
 354:catboard.c    **** 		} else if (key_code==KEY_OS_MODE) { // Mac mode
 1401               		.loc 2 354 0
 1402 017a 8C37      		cpi r24,lo8(124)
 1403 017c 01F4      		brne .L195
 355:catboard.c    **** 			if (pressed[key_id]==KEY_PRESSED_FN && (mod_keys & (KEY_SHIFT|KEY_RIGHT_SHIFT))) {
 1404               		.loc 2 355 0
 1405 017e 8081      		ld r24,Z
 1406               	.LVL87:
 1407 0180 8130      		cpi r24,lo8(1)
 1408 0182 01F4      		brne .L196
 355:catboard.c    **** 			if (pressed[key_id]==KEY_PRESSED_FN && (mod_keys & (KEY_SHIFT|KEY_RIGHT_SHIFT))) {
 1409               		.loc 2 355 0 is_stmt 0 discriminator 1
 1410 0184 8091 0000 		lds r24,mod_keys
 1411 0188 8272      		andi r24,lo8(34)
 1412 018a 01F0      		breq .L196
 356:catboard.c    **** 				os_mode++;
 1413               		.loc 2 356 0 is_stmt 1
 1414 018c 8091 0000 		lds r24,os_mode
 1415 0190 8F5F      		subi r24,lo8(-(1))
 1416 0192 8093 0000 		sts os_mode,r24
 357:catboard.c    **** 				if (os_mode>2) os_mode = 0;
 1417               		.loc 2 357 0
 1418 0196 8330      		cpi r24,lo8(3)
 1419 0198 00F4      		brsh .+2
 1420 019a 00C0      		rjmp .L185
 357:catboard.c    **** 				if (os_mode>2) os_mode = 0;
 1421               		.loc 2 357 0 is_stmt 0 discriminator 1
 1422 019c 1092 0000 		sts os_mode,__zero_reg__
 1423 01a0 00C0      		rjmp .L185
 1424               	.L196:
 359:catboard.c    **** 				usb_keyboard_press(KEY_SPACE, mod_keys);
 1425               		.loc 2 359 0 is_stmt 1
 1426 01a2 6091 0000 		lds r22,mod_keys
 1427 01a6 8CE2      		ldi r24,lo8(44)
 1428               	.L266:
 1429 01a8 0E94 0000 		call usb_keyboard_press
 1430               	.LVL88:
 1431 01ac 00C0      		rjmp .L185
 1432               	.LVL89:
 1433               	.L195:
 361:catboard.c    **** 		} else if (key_code==KEY_LAYER1) { // KEY_LAYOUT1
 1434               		.loc 2 361 0
 1435 01ae 8D36      		cpi r24,lo8(109)
 1436 01b0 01F4      		brne .L197
 362:catboard.c    **** 			if (mod_keys & (KEY_SHIFT|KEY_RIGHT_SHIFT)) {
 1437               		.loc 2 362 0
 1438 01b2 8091 0000 		lds r24,mod_keys
 1439               	.LVL90:
 1440 01b6 982F      		mov r25,r24
 1441 01b8 9272      		andi r25,lo8(34)
 1442 01ba 01F0      		breq .L198
 363:catboard.c    **** 				pressed[key_id] = KEY_PRESSED_CTRL;
 1443               		.loc 2 363 0
 1444 01bc 95E0      		ldi r25,lo8(5)
 1445 01be 9083      		st Z,r25
 364:catboard.c    **** 				mod_keys |= KEY_CTRL;
 1446               		.loc 2 364 0
 1447 01c0 8160      		ori r24,lo8(1)
 1448 01c2 00C0      		rjmp .L271
 1449               	.L198:
 367:catboard.c    **** 				if (mod_keys) pressed[key_id] = KEY_PRESSED_SHIFT;
 1450               		.loc 2 367 0
 1451 01c4 8823      		tst r24
 1452 01c6 01F0      		breq .L199
 367:catboard.c    **** 				if (mod_keys) pressed[key_id] = KEY_PRESSED_SHIFT;
 1453               		.loc 2 367 0 is_stmt 0 discriminator 1
 1454 01c8 94E0      		ldi r25,lo8(4)
 1455 01ca 9083      		st Z,r25
 1456               	.L199:
 368:catboard.c    **** 				mod_keys |= KEY_SHIFT;
 1457               		.loc 2 368 0 is_stmt 1
 1458 01cc 8260      		ori r24,lo8(2)
 1459               	.L271:
 1460 01ce 8093 0000 		sts mod_keys,r24
 1461               	.LVL91:
 1462 01d2 00C0      		rjmp .L265
 1463               	.LVL92:
 1464               	.L197:
 371:catboard.c    **** 		} else if (key_code==KEY_LAYER2) { // KEY_LAYOUT2
 1465               		.loc 2 371 0
 1466 01d4 8E36      		cpi r24,lo8(110)
 1467 01d6 01F4      		brne .L200
 372:catboard.c    **** 			mod_keys |= KEY_RIGHT_SHIFT;
 1468               		.loc 2 372 0
 1469 01d8 8091 0000 		lds r24,mod_keys
 1470               	.LVL93:
 1471 01dc 8062      		ori r24,lo8(32)
 1472 01de 00C0      		rjmp .L271
 1473               	.LVL94:
 1474               	.L200:
 374:catboard.c    **** 		} else if (key_code==KEY_TURBO_REPEAT) { // TURBO_REPEAT ON/OFF
 1475               		.loc 2 374 0
 1476 01e0 8B37      		cpi r24,lo8(123)
 1477 01e2 01F4      		brne .L201
 1478               	.LBB54:
 375:catboard.c    **** 			turbo_repeat = ! turbo_repeat;
 1479               		.loc 2 375 0
 1480 01e4 81E0      		ldi r24,lo8(1)
 1481               	.LVL95:
 1482 01e6 9091 0000 		lds r25,turbo_repeat
 1483 01ea 9111      		cpse r25,__zero_reg__
 1484 01ec 80E0      		ldi r24,0
 1485               	.L202:
 1486 01ee 8093 0000 		sts turbo_repeat,r24
 376:catboard.c    **** 			blink_leds();
 1487               		.loc 2 376 0
 1488 01f2 0E94 0000 		call blink_leds
 1489               	.LVL96:
 1490               	.LBE54:
 1491 01f6 00C0      		rjmp .L185
 1492               	.LVL97:
 1493               	.L201:
 377:catboard.c    **** 		} else if (key_code==KEY_MY_SHIFT) { // My Shift
 1494               		.loc 2 377 0
 1495 01f8 8737      		cpi r24,lo8(119)
 1496 01fa 01F4      		brne .L203
 378:catboard.c    **** 			mod_keys |= KEY_SHIFT;
 1497               		.loc 2 378 0
 1498 01fc 8091 0000 		lds r24,mod_keys
 1499               	.LVL98:
 1500 0200 00C0      		rjmp .L199
 1501               	.LVL99:
 1502               	.L203:
 380:catboard.c    **** 		} else if (key_code==KEY_MACRO) { // TODO: My Macro
 1503               		.loc 2 380 0
 1504 0202 8F36      		cpi r24,lo8(111)
 1505 0204 01F4      		brne .+2
 1506 0206 00C0      		rjmp .L185
 393:catboard.c    **** 		} else if (key_code==KEY_LOCK) { // Lock/Unlock keyboard
 1507               		.loc 2 393 0
 1508 0208 8A37      		cpi r24,lo8(122)
 1509 020a 01F4      		brne .L261
 400:catboard.c    **** 				locked = 1;
 1510               		.loc 2 400 0
 1511 020c 81E0      		ldi r24,lo8(1)
 1512               	.LVL100:
 1513 020e 8093 0000 		sts locked,r24
 401:catboard.c    **** 				LED_OFF;
 1514               		.loc 2 401 0
 1515 0212 5E9A      		sbi 0xb,6
 402:catboard.c    **** 				LED_RED_OFF;
 1516               		.loc 2 402 0
 1517 0214 469A      		sbi 0x8,6
 403:catboard.c    **** 				LED_BLUE_OFF;
 1518               		.loc 2 403 0
 1519 0216 5998      		cbi 0xb,1
 404:catboard.c    **** 				usb_keyboard_press(KEY_L, KEY_GUI); // Block computer
 1520               		.loc 2 404 0
 1521 0218 68E0      		ldi r22,lo8(8)
 1522 021a 8FE0      		ldi r24,lo8(15)
 1523 021c 00C0      		rjmp .L266
 1524               	.LVL101:
 1525               	.L272:
 395:catboard.c    **** 				locked = 0;
 1526               		.loc 2 395 0
 1527 021e 1092 0000 		sts locked,__zero_reg__
 396:catboard.c    **** 				if (led) {
 1528               		.loc 2 396 0
 1529 0222 8091 0000 		lds r24,led
 1530               	.LVL102:
 1531 0226 8823      		tst r24
 1532 0228 01F4      		brne .+2
 1533 022a 00C0      		rjmp .L185
 1534 022c 00C0      		rjmp .L267
 1535               	.LVL103:
 1536               	.L261:
 406:catboard.c    **** 		} else if (key_code==KEY_LED && (mod_keys & (KEY_SHIFT|KEY_RIGHT_SHIFT))) { // LED On/Off
 1537               		.loc 2 406 0
 1538 022e 8937      		cpi r24,lo8(121)
 1539 0230 01F0      		breq .+2
 1540 0232 00C0      		rjmp .L185
 406:catboard.c    **** 		} else if (key_code==KEY_LED && (mod_keys & (KEY_SHIFT|KEY_RIGHT_SHIFT))) { // LED On/Off
 1541               		.loc 2 406 0 is_stmt 0 discriminator 1
 1542 0234 8091 0000 		lds r24,mod_keys
 1543               	.LVL104:
 1544 0238 8272      		andi r24,lo8(34)
 1545 023a 01F4      		brne .+2
 1546 023c 00C0      		rjmp .L185
 407:catboard.c    **** 			if (led) {
 1547               		.loc 2 407 0 is_stmt 1
 1548 023e 8091 0000 		lds r24,led
 1549 0242 8823      		tst r24
 1550 0244 01F0      		breq .L206
 408:catboard.c    **** 				led = 0;
 1551               		.loc 2 408 0
 1552 0246 1092 0000 		sts led,__zero_reg__
 409:catboard.c    **** 				LED_OFF;
 1553               		.loc 2 409 0
 1554 024a 5E9A      		sbi 0xb,6
 410:catboard.c    **** 				LED_RED_OFF;
 1555               		.loc 2 410 0
 1556 024c 469A      		sbi 0x8,6
 411:catboard.c    **** 				LED_BLUE_OFF;
 1557               		.loc 2 411 0
 1558 024e 5998      		cbi 0xb,1
 1559 0250 00C0      		rjmp .L185
 1560               	.L206:
 1561               	.LBB55:
 413:catboard.c    **** 				led = 1;
 1562               		.loc 2 413 0
 1563 0252 81E0      		ldi r24,lo8(1)
 1564 0254 8093 0000 		sts led,r24
 1565               	.L267:
 414:catboard.c    **** 				restore_leds();
 1566               		.loc 2 414 0
 1567 0258 0E94 0000 		call restore_leds
 1568               	.LVL105:
 1569 025c 00C0      		rjmp .L185
 1570               	.LVL106:
 1571               	.L182:
 1572               	.LBE55:
 417:catboard.c    **** 	} else if (key_code>=KEY_LCTRL) { // Mod keys
 1573               		.loc 2 417 0
 1574 025e 8536      		cpi r24,lo8(101)
 1575 0260 00F0      		brlo .L207
 418:catboard.c    **** 		if (os_mode==2 && key_code==KEY_LCTRL) {
 1576               		.loc 2 418 0
 1577 0262 2091 0000 		lds r18,os_mode
 1578               	.LVL107:
 1579 0266 9091 0000 		lds r25,mod_keys
 1580 026a 2230      		cpi r18,lo8(2)
 1581 026c 01F4      		brne .L208
 418:catboard.c    **** 		if (os_mode==2 && key_code==KEY_LCTRL) {
 1582               		.loc 2 418 0 is_stmt 0 discriminator 1
 1583 026e 8536      		cpi r24,lo8(101)
 1584 0270 01F4      		brne .L209
 1585               	.L217:
 419:catboard.c    **** 			mod_keys |= KEY_GUI;
 1586               		.loc 2 419 0 is_stmt 1
 1587 0272 9860      		ori r25,lo8(8)
 1588 0274 00C0      		rjmp .L264
 1589               	.L209:
 420:catboard.c    **** 		} else if ((os_mode==2 && key_code==KEY_RCTRL) || key_code==KEY_RGUI) {
 1590               		.loc 2 420 0 discriminator 1
 1591 0276 8936      		cpi r24,lo8(105)
 1592 0278 01F4      		brne .L262
 1593 027a 00C0      		rjmp .L211
 1594               	.L208:
 420:catboard.c    **** 		} else if ((os_mode==2 && key_code==KEY_RCTRL) || key_code==KEY_RGUI) {
 1595               		.loc 2 420 0 is_stmt 0 discriminator 2
 1596 027c 8C36      		cpi r24,lo8(108)
 1597 027e 01F4      		brne .L213
 1598               	.L211:
 421:catboard.c    **** 			mod_keys |= KEY_RIGHT_GUI;
 1599               		.loc 2 421 0 is_stmt 1
 1600 0280 9068      		ori r25,lo8(-128)
 1601 0282 00C0      		rjmp .L264
 1602               	.L213:
 422:catboard.c    **** 		} else if (key_code==KEY_LCTRL) {
 1603               		.loc 2 422 0
 1604 0284 8536      		cpi r24,lo8(101)
 1605 0286 01F4      		brne .L214
 423:catboard.c    **** 			mod_keys |= KEY_CTRL;
 1606               		.loc 2 423 0
 1607 0288 9160      		ori r25,lo8(1)
 1608 028a 00C0      		rjmp .L264
 1609               	.L262:
 420:catboard.c    **** 		} else if ((os_mode==2 && key_code==KEY_RCTRL) || key_code==KEY_RGUI) {
 1610               		.loc 2 420 0
 1611 028c 8C36      		cpi r24,lo8(108)
 1612 028e 01F0      		breq .L211
 1613               	.L214:
 424:catboard.c    **** 		} else if (key_code==KEY_LSHIFT) {
 1614               		.loc 2 424 0
 1615 0290 8636      		cpi r24,lo8(102)
 1616 0292 01F4      		brne .L215
 425:catboard.c    **** 			mod_keys |= KEY_SHIFT;
 1617               		.loc 2 425 0
 1618 0294 9260      		ori r25,lo8(2)
 1619 0296 00C0      		rjmp .L264
 1620               	.L215:
 426:catboard.c    **** 		} else if (key_code==KEY_LALT) {
 1621               		.loc 2 426 0
 1622 0298 8736      		cpi r24,lo8(103)
 1623 029a 01F4      		brne .L216
 427:catboard.c    **** 			mod_keys |= KEY_ALT;
 1624               		.loc 2 427 0
 1625 029c 9460      		ori r25,lo8(4)
 1626 029e 00C0      		rjmp .L264
 1627               	.L216:
 428:catboard.c    **** 		} else if (key_code==KEY_LGUI) {
 1628               		.loc 2 428 0
 1629 02a0 8836      		cpi r24,lo8(104)
 1630 02a2 01F0      		breq .L217
 430:catboard.c    **** 		} else if (key_code==KEY_RCTRL) {
 1631               		.loc 2 430 0
 1632 02a4 8936      		cpi r24,lo8(105)
 1633 02a6 01F4      		brne .L218
 431:catboard.c    **** 			mod_keys |= KEY_RIGHT_CTRL;
 1634               		.loc 2 431 0
 1635 02a8 9061      		ori r25,lo8(16)
 1636 02aa 00C0      		rjmp .L264
 1637               	.L218:
 432:catboard.c    **** 		} else if (key_code==KEY_RSHIFT) {
 1638               		.loc 2 432 0
 1639 02ac 8A36      		cpi r24,lo8(106)
 1640 02ae 01F4      		brne .L219
 433:catboard.c    **** 			mod_keys |= KEY_RIGHT_SHIFT;
 1641               		.loc 2 433 0
 1642 02b0 9062      		ori r25,lo8(32)
 1643 02b2 00C0      		rjmp .L264
 1644               	.L219:
 435:catboard.c    **** 			mod_keys |= KEY_RIGHT_ALT;
 1645               		.loc 2 435 0
 1646 02b4 9064      		ori r25,lo8(64)
 1647               	.L264:
 1648 02b6 9093 0000 		sts mod_keys,r25
 1649               	.LVL108:
 439:catboard.c    **** 		send();
 1650               		.loc 2 439 0
 1651 02ba 0E94 0000 		call send
 1652               	.LVL109:
 440:catboard.c    **** 		press_time = 0;
 1653               		.loc 2 440 0
 1654 02be 1092 0000 		sts press_time+1,__zero_reg__
 1655 02c2 1092 0000 		sts press_time,__zero_reg__
 442:catboard.c    **** 		release_time = 0;
 1656               		.loc 2 442 0
 1657 02c6 1092 0000 		sts release_time+1,__zero_reg__
 1658 02ca 1092 0000 		sts release_time,__zero_reg__
 444:catboard.c    **** 		last_key = 0;
 1659               		.loc 2 444 0
 1660 02ce 1092 0000 		sts last_key,__zero_reg__
 1661 02d2 00C0      		rjmp .L185
 1662               	.LVL110:
 1663               	.L207:
 451:catboard.c    **** 		if (! (last_key==key_id && release_time<10)) { // debounce
 1664               		.loc 2 451 0
 1665 02d4 8091 0000 		lds r24,last_key
 1666               	.LVL111:
 1667 02d8 8C13      		cpse r24,r28
 1668 02da 00C0      		rjmp .L220
 451:catboard.c    **** 		if (! (last_key==key_id && release_time<10)) { // debounce
 1669               		.loc 2 451 0 is_stmt 0 discriminator 1
 1670 02dc 8091 0000 		lds r24,release_time
 1671 02e0 9091 0000 		lds r25,release_time+1
 1672 02e4 0A97      		sbiw r24,10
 1673 02e6 00F0      		brlo .L185
 1674               	.L220:
 1675 02e8 E0E0      		ldi r30,lo8(queue+5)
 1676 02ea F0E0      		ldi r31,hi8(queue+5)
 1677 02ec A0E0      		ldi r26,lo8(queue+6)
 1678 02ee B0E0      		ldi r27,hi8(queue+6)
 1679               	.LVL112:
 1680               	.L222:
 452:catboard.c    **** 			for (i=5; i>0; i--) queue[i] = queue[i-1];
 1681               		.loc 2 452 0 is_stmt 1 discriminator 2
 1682 02f0 8291      		ld r24,-Z
 1683               	.LVL113:
 1684 02f2 8E93      		st -X,r24
 1685               	.LVL114:
 1686 02f4 20E0      		ldi r18,hi8(queue)
 1687 02f6 E030      		cpi r30,lo8(queue)
 1688 02f8 F207      		cpc r31,r18
 1689 02fa 01F4      		brne .L222
 453:catboard.c    **** 			queue[0] = key_id;
 1690               		.loc 2 453 0
 1691 02fc C093 0000 		sts queue,r28
 1692               	.LVL115:
 1693               	.L265:
 454:catboard.c    **** 			send();
 1694               		.loc 2 454 0
 1695 0300 0E94 0000 		call send
 1696               	.LVL116:
 1697               	.L185:
 458:catboard.c    **** 	if (last_key==key_id) { // calc press2
 1698               		.loc 2 458 0
 1699 0304 8091 0000 		lds r24,last_key
 1700 0308 8C13      		cpse r24,r28
 1701 030a 00C0      		rjmp .L223
 459:catboard.c    **** 		press_time2 = 1;
 1702               		.loc 2 459 0
 1703 030c 81E0      		ldi r24,lo8(1)
 1704 030e 90E0      		ldi r25,0
 1705 0310 9093 0000 		sts press_time2+1,r25
 1706 0314 8093 0000 		sts press_time2,r24
 1707 0318 00C0      		rjmp .L268
 1708               	.L223:
 462:catboard.c    **** 		last_key = key_id;
 1709               		.loc 2 462 0
 1710 031a C093 0000 		sts last_key,r28
 463:catboard.c    **** 		press_time = 1;
 1711               		.loc 2 463 0
 1712 031e 81E0      		ldi r24,lo8(1)
 1713 0320 90E0      		ldi r25,0
 1714 0322 9093 0000 		sts press_time+1,r25
 1715 0326 8093 0000 		sts press_time,r24
 464:catboard.c    **** 		press_time2 = 0;
 1716               		.loc 2 464 0
 1717 032a 1092 0000 		sts press_time2+1,__zero_reg__
 1718 032e 1092 0000 		sts press_time2,__zero_reg__
 465:catboard.c    **** 		release_time = 0;
 1719               		.loc 2 465 0
 1720 0332 1092 0000 		sts release_time+1,__zero_reg__
 1721 0336 1092 0000 		sts release_time,__zero_reg__
 1722               	.L268:
 466:catboard.c    **** 		repeat_time = 0;
 1723               		.loc 2 466 0
 1724 033a 1092 0000 		sts repeat_time+1,__zero_reg__
 1725 033e 1092 0000 		sts repeat_time,__zero_reg__
 1726               	.L172:
 1727               	/* epilogue start */
 468:catboard.c    **** }
 1728               		.loc 2 468 0
 1729 0342 CF91      		pop r28
 1730               	.LVL117:
 1731 0344 0895      		ret
 1732               		.cfi_endproc
 1733               	.LFE14:
 1735               		.section	.text.poll,"ax",@progbits
 1736               	.global	poll
 1738               	poll:
 1739               	.LFB11:
 207:catboard.c    **** void poll() {
 1740               		.loc 2 207 0
 1741               		.cfi_startproc
 1742 0000 7F92      		push r7
 1743               	.LCFI7:
 1744               		.cfi_def_cfa_offset 3
 1745               		.cfi_offset 7, -2
 1746 0002 8F92      		push r8
 1747               	.LCFI8:
 1748               		.cfi_def_cfa_offset 4
 1749               		.cfi_offset 8, -3
 1750 0004 9F92      		push r9
 1751               	.LCFI9:
 1752               		.cfi_def_cfa_offset 5
 1753               		.cfi_offset 9, -4
 1754 0006 AF92      		push r10
 1755               	.LCFI10:
 1756               		.cfi_def_cfa_offset 6
 1757               		.cfi_offset 10, -5
 1758 0008 BF92      		push r11
 1759               	.LCFI11:
 1760               		.cfi_def_cfa_offset 7
 1761               		.cfi_offset 11, -6
 1762 000a CF92      		push r12
 1763               	.LCFI12:
 1764               		.cfi_def_cfa_offset 8
 1765               		.cfi_offset 12, -7
 1766 000c DF92      		push r13
 1767               	.LCFI13:
 1768               		.cfi_def_cfa_offset 9
 1769               		.cfi_offset 13, -8
 1770 000e EF92      		push r14
 1771               	.LCFI14:
 1772               		.cfi_def_cfa_offset 10
 1773               		.cfi_offset 14, -9
 1774 0010 FF92      		push r15
 1775               	.LCFI15:
 1776               		.cfi_def_cfa_offset 11
 1777               		.cfi_offset 15, -10
 1778 0012 0F93      		push r16
 1779               	.LCFI16:
 1780               		.cfi_def_cfa_offset 12
 1781               		.cfi_offset 16, -11
 1782 0014 1F93      		push r17
 1783               	.LCFI17:
 1784               		.cfi_def_cfa_offset 13
 1785               		.cfi_offset 17, -12
 1786 0016 CF93      		push r28
 1787               	.LCFI18:
 1788               		.cfi_def_cfa_offset 14
 1789               		.cfi_offset 28, -13
 1790 0018 DF93      		push r29
 1791               	.LCFI19:
 1792               		.cfi_def_cfa_offset 15
 1793               		.cfi_offset 29, -14
 1794               	/* prologue: function */
 1795               	/* frame size = 0 */
 1796               	/* stack size = 13 */
 1797               	.L__stack_usage = 13
 1798               	.LVL118:
 1799 001a 70E0      		ldi r23,lo8(row_port)
 1800 001c E72E      		mov r14,r23
 1801 001e 70E0      		ldi r23,hi8(row_port)
 1802 0020 F72E      		mov r15,r23
 1803 0022 00E0      		ldi r16,lo8(row_bit)
 1804 0024 10E0      		ldi r17,hi8(row_bit)
 209:catboard.c    **** 	for (row=0; row<ROWS; row++) { // scan rows
 1805               		.loc 2 209 0
 1806 0026 812C      		mov r8,__zero_reg__
 1807               	.LVL119:
 1808               	.L279:
 210:catboard.c    **** 		*row_port[row] &= ~row_bit[row];
 1809               		.loc 2 210 0
 1810 0028 D701      		movw r26,r14
 1811 002a CD91      		ld r28,X+
 1812 002c DD91      		ld r29,X+
 1813 002e 7D01      		movw r14,r26
 1814 0030 F801      		movw r30,r16
 1815 0032 9190      		ld r9,Z+
 1816 0034 8F01      		movw r16,r30
 1817 0036 992D      		mov r25,r9
 1818 0038 9095      		com r25
 1819 003a 8881      		ld r24,Y
 1820 003c 8923      		and r24,r25
 1821 003e 8883      		st Y,r24
 1822               	.LVL120:
 1823               	.LBB56:
 1824               	.LBB57:
 165:/usr/lib/avr/include/util/delay.h **** 
 166:/usr/lib/avr/include/util/delay.h **** #else
 167:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/avr/include/util/delay.h **** 	{
 172:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/avr/include/util/delay.h **** 		{
 176:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/avr/include/util/delay.h **** 		}
 180:/usr/lib/avr/include/util/delay.h **** 		return;
 181:/usr/lib/avr/include/util/delay.h **** 	}
 182:/usr/lib/avr/include/util/delay.h **** 	else
 183:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/avr/include/util/delay.h **** #endif
 186:/usr/lib/avr/include/util/delay.h **** }
 187:/usr/lib/avr/include/util/delay.h **** 
 188:/usr/lib/avr/include/util/delay.h **** /**
 189:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/avr/include/util/delay.h **** 
 191:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/avr/include/util/delay.h **** 
 193:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/avr/include/util/delay.h **** 
 196:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/avr/include/util/delay.h **** 
 198:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/avr/include/util/delay.h **** 
 202:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/avr/include/util/delay.h ****   
 207:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/avr/include/util/delay.h **** 
 211:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/avr/include/util/delay.h ****  
 214:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****  */
 223:/usr/lib/avr/include/util/delay.h **** void
 224:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/avr/include/util/delay.h **** {
 226:/usr/lib/avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 228:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/usr/lib/avr/include/util/delay.h **** 
 235:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/usr/lib/avr/include/util/delay.h **** 
 238:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/usr/lib/avr/include/util/delay.h **** 
 241:/usr/lib/avr/include/util/delay.h **** 	#else
 242:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 243:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/usr/lib/avr/include/util/delay.h **** 	#endif
 245:/usr/lib/avr/include/util/delay.h **** 
 246:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1825               		.loc 3 246 0
 1826 0040 F5E0      		ldi r31,lo8(5)
 1827 0042 FA95      		1: dec r31
 1828 0044 01F4      		brne 1b
 1829 0046 0000      		nop
 1830               	.LVL121:
 1831 0048 50E0      		ldi r21,lo8(col_pin)
 1832 004a A52E      		mov r10,r21
 1833 004c 50E0      		ldi r21,hi8(col_pin)
 1834 004e B52E      		mov r11,r21
 1835 0050 60E0      		ldi r22,lo8(col_bit)
 1836 0052 C62E      		mov r12,r22
 1837 0054 60E0      		ldi r22,hi8(col_bit)
 1838 0056 D62E      		mov r13,r22
 1839 0058 712C      		mov r7,__zero_reg__
 1840               	.LVL122:
 1841               	.L277:
 1842               	.LBE57:
 1843               	.LBE56:
 213:catboard.c    **** 			key_id = col*ROWS+row;
 1844               		.loc 2 213 0
 1845 005a 872D      		mov r24,r7
 1846 005c 880D      		add r24,r8
 1847               	.LVL123:
 214:catboard.c    **** 			if (! (*col_pin[col] & col_bit[col])) { // press key
 1848               		.loc 2 214 0
 1849 005e D501      		movw r26,r10
 1850 0060 ED91      		ld r30,X+
 1851 0062 FD91      		ld r31,X+
 1852 0064 5D01      		movw r10,r26
 1853 0066 D601      		movw r26,r12
 1854 0068 9D91      		ld r25,X+
 1855 006a 6D01      		movw r12,r26
 1856               	.LVL124:
 1857 006c 2081      		ld r18,Z
 1858 006e 9223      		and r25,r18
 1859 0070 282F      		mov r18,r24
 1860 0072 30E0      		ldi r19,0
 215:catboard.c    **** 				if (! pressed[key_id]) {
 1861               		.loc 2 215 0
 1862 0074 F901      		movw r30,r18
 1863 0076 E050      		subi r30,lo8(-(pressed))
 1864 0078 F040      		sbci r31,hi8(-(pressed))
 214:catboard.c    **** 			if (! (*col_pin[col] & col_bit[col])) { // press key
 1865               		.loc 2 214 0
 1866 007a 9111      		cpse r25,__zero_reg__
 1867 007c 00C0      		rjmp .L274
 215:catboard.c    **** 				if (! pressed[key_id]) {
 1868               		.loc 2 215 0
 1869 007e 9081      		ld r25,Z
 1870 0080 9111      		cpse r25,__zero_reg__
 1871 0082 00C0      		rjmp .L275
 216:catboard.c    **** 					key_press(key_id);
 1872               		.loc 2 216 0
 1873 0084 0E94 0000 		call key_press
 1874               	.LVL125:
 1875 0088 00C0      		rjmp .L275
 1876               	.LVL126:
 1877               	.L274:
 218:catboard.c    **** 			} else if (pressed[key_id]) { // release key
 1878               		.loc 2 218 0
 1879 008a 9081      		ld r25,Z
 1880 008c 9111      		cpse r25,__zero_reg__
 219:catboard.c    **** 				key_release(key_id);
 1881               		.loc 2 219 0
 1882 008e 0E94 0000 		call key_release
 1883               	.LVL127:
 1884               	.L275:
 1885 0092 B5E0      		ldi r27,lo8(5)
 1886 0094 7B0E      		add r7,r27
 1887               	.LVL128:
 212:catboard.c    **** 		for (col=0; col<COLS; col++) { // read columns
 1888               		.loc 2 212 0
 1889 0096 ECE3      		ldi r30,lo8(60)
 1890 0098 7E12      		cpse r7,r30
 1891 009a 00C0      		rjmp .L277
 222:catboard.c    **** 		*row_port[row] |= row_bit[row];
 1892               		.loc 2 222 0
 1893 009c 8881      		ld r24,Y
 1894 009e 8929      		or r24,r9
 1895 00a0 8883      		st Y,r24
 209:catboard.c    **** 	for (row=0; row<ROWS; row++) { // scan rows
 1896               		.loc 2 209 0
 1897 00a2 8394      		inc r8
 1898               	.LVL129:
 1899 00a4 8B12      		cpse r8,r27
 1900 00a6 00C0      		rjmp .L279
 224:catboard.c    **** 	if (caps_lock_led != (keyboard_leds & LED_CAPS_LOCK)) { // change layout
 1901               		.loc 2 224 0
 1902 00a8 8091 0000 		lds r24,keyboard_leds
 1903 00ac 8270      		andi r24,lo8(2)
 1904 00ae 9091 0000 		lds r25,caps_lock_led
 1905 00b2 9813      		cpse r25,r24
 1906               	.LBB58:
 225:catboard.c    **** 		caps_lock_change_layer();
 1907               		.loc 2 225 0
 1908 00b4 0E94 0000 		call caps_lock_change_layer
 1909               	.LVL130:
 1910               	.L280:
 1911               	.LBE58:
 228:catboard.c    **** 	repeat_tick();
 1912               		.loc 2 228 0
 1913 00b8 0E94 0000 		call repeat_tick
 1914               	.LVL131:
 1915               	.LBB59:
 1916               	.LBB60:
 164:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1917               		.loc 3 164 0
 1918 00bc 8FE1      		ldi r24,lo8(19999)
 1919 00be 9EE4      		ldi r25,hi8(19999)
 1920 00c0 0197      		1: sbiw r24,1
 1921 00c2 01F4      		brne 1b
 1922 00c4 00C0      		rjmp .
 1923 00c6 0000      		nop
 1924               	/* epilogue start */
 1925               	.LBE60:
 1926               	.LBE59:
 230:catboard.c    **** }
 1927               		.loc 2 230 0
 1928 00c8 DF91      		pop r29
 1929 00ca CF91      		pop r28
 1930 00cc 1F91      		pop r17
 1931 00ce 0F91      		pop r16
 1932 00d0 FF90      		pop r15
 1933 00d2 EF90      		pop r14
 1934 00d4 DF90      		pop r13
 1935 00d6 CF90      		pop r12
 1936               	.LVL132:
 1937 00d8 BF90      		pop r11
 1938 00da AF90      		pop r10
 1939 00dc 9F90      		pop r9
 1940 00de 8F90      		pop r8
 1941               	.LVL133:
 1942 00e0 7F90      		pop r7
 1943 00e2 0895      		ret
 1944               		.cfi_endproc
 1945               	.LFE11:
 1947               		.section	.text.startup.main,"ax",@progbits
 1948               	.global	main
 1950               	main:
 1951               	.LFB9:
 168:catboard.c    **** int main(void) {
 1952               		.loc 2 168 0
 1953               		.cfi_startproc
 1954               	/* prologue: function */
 1955               	/* frame size = 0 */
 1956               	/* stack size = 0 */
 1957               	.L__stack_usage = 0
 170:catboard.c    **** 	MCUSR &= ~(1 << WDRF);
 1958               		.loc 2 170 0
 1959 0000 84B7      		in r24,0x34
 1960 0002 877F      		andi r24,lo8(-9)
 1961 0004 84BF      		out 0x34,r24
 171:catboard.c    **** 	wdt_disable();
 1962               		.loc 2 171 0
 1963 0006 88E1      		ldi r24,lo8(24)
 1964               	/* #APP */
 1965               	 ;  171 "catboard.c" 1
 1966 0008 0FB6      		in __tmp_reg__, __SREG__
 1967 000a F894      		cli
 1968 000c 8093 6000 		sts 96, r24
 1969 0010 1092 6000 		sts 96, __zero_reg__
 1970 0014 0FBE      		out __SREG__,__tmp_reg__
 1971               		
 1972               	 ;  0 "" 2
 1973               	.LVL134:
 1974               	/* #NOAPP */
 1975               	.LBB61:
 1976               	.LBB62:
 1977               		.file 4 "/usr/lib/avr/include/avr/power.h"
   1:/usr/lib/avr/include/avr/power.h **** /* Copyright (c) 2006, 2007, 2008  Eric B. Weddington
   2:/usr/lib/avr/include/avr/power.h ****    All rights reserved.
   3:/usr/lib/avr/include/avr/power.h **** 
   4:/usr/lib/avr/include/avr/power.h ****    Redistribution and use in source and binary forms, with or without
   5:/usr/lib/avr/include/avr/power.h ****    modification, are permitted provided that the following conditions are met:
   6:/usr/lib/avr/include/avr/power.h **** 
   7:/usr/lib/avr/include/avr/power.h ****    * Redistributions of source code must retain the above copyright
   8:/usr/lib/avr/include/avr/power.h ****      notice, this list of conditions and the following disclaimer.
   9:/usr/lib/avr/include/avr/power.h ****    * Redistributions in binary form must reproduce the above copyright
  10:/usr/lib/avr/include/avr/power.h ****      notice, this list of conditions and the following disclaimer in
  11:/usr/lib/avr/include/avr/power.h ****      the documentation and/or other materials provided with the
  12:/usr/lib/avr/include/avr/power.h ****      distribution.
  13:/usr/lib/avr/include/avr/power.h ****    * Neither the name of the copyright holders nor the names of
  14:/usr/lib/avr/include/avr/power.h ****      contributors may be used to endorse or promote products derived
  15:/usr/lib/avr/include/avr/power.h ****      from this software without specific prior written permission.
  16:/usr/lib/avr/include/avr/power.h **** 
  17:/usr/lib/avr/include/avr/power.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  18:/usr/lib/avr/include/avr/power.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  19:/usr/lib/avr/include/avr/power.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  20:/usr/lib/avr/include/avr/power.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  21:/usr/lib/avr/include/avr/power.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  22:/usr/lib/avr/include/avr/power.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  23:/usr/lib/avr/include/avr/power.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  24:/usr/lib/avr/include/avr/power.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  25:/usr/lib/avr/include/avr/power.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  26:/usr/lib/avr/include/avr/power.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  27:/usr/lib/avr/include/avr/power.h ****   POSSIBILITY OF SUCH DAMAGE. */
  28:/usr/lib/avr/include/avr/power.h **** 
  29:/usr/lib/avr/include/avr/power.h **** /* $Id: power.h 2254 2011-09-26 15:06:50Z arcanum $ */
  30:/usr/lib/avr/include/avr/power.h **** 
  31:/usr/lib/avr/include/avr/power.h **** #ifndef _AVR_POWER_H_
  32:/usr/lib/avr/include/avr/power.h **** #define _AVR_POWER_H_   1
  33:/usr/lib/avr/include/avr/power.h **** 
  34:/usr/lib/avr/include/avr/power.h **** #include <avr/io.h>
  35:/usr/lib/avr/include/avr/power.h **** #include <stdint.h>
  36:/usr/lib/avr/include/avr/power.h **** 
  37:/usr/lib/avr/include/avr/power.h **** 
  38:/usr/lib/avr/include/avr/power.h **** /** \file */
  39:/usr/lib/avr/include/avr/power.h **** /** \defgroup avr_power <avr/power.h>: Power Reduction Management
  40:/usr/lib/avr/include/avr/power.h **** 
  41:/usr/lib/avr/include/avr/power.h **** \code #include <avr/power.h>\endcode
  42:/usr/lib/avr/include/avr/power.h **** 
  43:/usr/lib/avr/include/avr/power.h **** Many AVRs contain a Power Reduction Register (PRR) or Registers (PRRx) that 
  44:/usr/lib/avr/include/avr/power.h **** allow you to reduce power consumption by disabling or enabling various on-board 
  45:/usr/lib/avr/include/avr/power.h **** peripherals as needed.
  46:/usr/lib/avr/include/avr/power.h **** 
  47:/usr/lib/avr/include/avr/power.h **** There are many macros in this header file that provide an easy interface
  48:/usr/lib/avr/include/avr/power.h **** to enable or disable on-board peripherals to reduce power. See the table below.
  49:/usr/lib/avr/include/avr/power.h **** 
  50:/usr/lib/avr/include/avr/power.h **** \note Not all AVR devices have a Power Reduction Register (for example
  51:/usr/lib/avr/include/avr/power.h **** the ATmega128). On those devices without a Power Reduction Register, these 
  52:/usr/lib/avr/include/avr/power.h **** macros are not available.
  53:/usr/lib/avr/include/avr/power.h **** 
  54:/usr/lib/avr/include/avr/power.h **** \note Not all AVR devices contain the same peripherals (for example, the LCD
  55:/usr/lib/avr/include/avr/power.h **** interface), or they will be named differently (for example, USART and 
  56:/usr/lib/avr/include/avr/power.h **** USART0). Please consult your device's datasheet, or the header file, to 
  57:/usr/lib/avr/include/avr/power.h **** find out which macros are applicable to your device.
  58:/usr/lib/avr/include/avr/power.h **** 
  59:/usr/lib/avr/include/avr/power.h **** */
  60:/usr/lib/avr/include/avr/power.h **** 
  61:/usr/lib/avr/include/avr/power.h **** 
  62:/usr/lib/avr/include/avr/power.h **** /** \addtogroup avr_power
  63:/usr/lib/avr/include/avr/power.h **** 
  64:/usr/lib/avr/include/avr/power.h **** \anchor avr_powermacros
  65:/usr/lib/avr/include/avr/power.h **** <small>
  66:/usr/lib/avr/include/avr/power.h **** <center>
  67:/usr/lib/avr/include/avr/power.h **** <table border="3">
  68:/usr/lib/avr/include/avr/power.h ****   <tr>
  69:/usr/lib/avr/include/avr/power.h ****     <td width="10%"><strong>Power Macro</strong></td>
  70:/usr/lib/avr/include/avr/power.h ****     <td width="15%"><strong>Description</strong></td>
  71:/usr/lib/avr/include/avr/power.h ****     <td width="75%"><strong>Applicable for device</strong></td>
  72:/usr/lib/avr/include/avr/power.h ****   </tr>
  73:/usr/lib/avr/include/avr/power.h **** 
  74:/usr/lib/avr/include/avr/power.h ****   <tr>
  75:/usr/lib/avr/include/avr/power.h ****     <td>power_adc_enable()</td>
  76:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Analog to Digital Converter module.</td>
  77:/usr/lib/avr/include/avr/power.h ****     <td>ATmega640, ATmega1280, ATmega1281, ATmega128RFA1, ATmega2560, ATmega2561, AT90USB646, AT90U
  78:/usr/lib/avr/include/avr/power.h ****   </tr>
  79:/usr/lib/avr/include/avr/power.h **** 
  80:/usr/lib/avr/include/avr/power.h ****   <tr>
  81:/usr/lib/avr/include/avr/power.h ****     <td>power_adc_disable()</td>
  82:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Analog to Digital Converter module.</td>
  83:/usr/lib/avr/include/avr/power.h ****     <td>ATmega640, ATmega1280, ATmega1281, ATmega128RFA1, ATmega2560, ATmega2561, AT90USB646, AT90U
  84:/usr/lib/avr/include/avr/power.h ****   </tr>
  85:/usr/lib/avr/include/avr/power.h **** 
  86:/usr/lib/avr/include/avr/power.h ****   <tr>
  87:/usr/lib/avr/include/avr/power.h ****     <td>power_lcd_enable()</td>
  88:/usr/lib/avr/include/avr/power.h ****     <td>Enable the LCD module.</td>
  89:/usr/lib/avr/include/avr/power.h ****     <td>ATmega169, ATmega169P, ATmega329, ATmega329A, ATmega3290, ATmega3290A, ATmega649, ATmega649
  90:/usr/lib/avr/include/avr/power.h ****   </tr>
  91:/usr/lib/avr/include/avr/power.h **** 
  92:/usr/lib/avr/include/avr/power.h ****   <tr>
  93:/usr/lib/avr/include/avr/power.h ****     <td>power_lcd_disable().</td>
  94:/usr/lib/avr/include/avr/power.h ****     <td>Disable the LCD module.</td>
  95:/usr/lib/avr/include/avr/power.h ****     <td>ATmega169, ATmega169P, ATmega329, ATmega329A, ATmega3290, ATmega3290A, ATmega649, ATmega649
  96:/usr/lib/avr/include/avr/power.h ****   </tr>
  97:/usr/lib/avr/include/avr/power.h **** 
  98:/usr/lib/avr/include/avr/power.h ****   <tr>
  99:/usr/lib/avr/include/avr/power.h ****     <td>power_pscr_enable()</td>
 100:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Reduced Power Stage Controller module.</td>
 101:/usr/lib/avr/include/avr/power.h ****     <td>AT90PWM81</td>
 102:/usr/lib/avr/include/avr/power.h ****   </tr>
 103:/usr/lib/avr/include/avr/power.h **** 
 104:/usr/lib/avr/include/avr/power.h ****   <tr>
 105:/usr/lib/avr/include/avr/power.h ****     <td>power_pscr_disable()</td>
 106:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Reduced Power Stage Controller module.</td>
 107:/usr/lib/avr/include/avr/power.h ****     <td>AT90PWM81</td>
 108:/usr/lib/avr/include/avr/power.h ****   </tr>
 109:/usr/lib/avr/include/avr/power.h **** 
 110:/usr/lib/avr/include/avr/power.h ****   <tr>
 111:/usr/lib/avr/include/avr/power.h ****     <td>power_psc0_enable()</td>
 112:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Power Stage Controller 0 module.</td>
 113:/usr/lib/avr/include/avr/power.h ****     <td>AT90PWM1, AT90PWM2, AT90PWM2B, AT90PWM3, AT90PWM3B</td>
 114:/usr/lib/avr/include/avr/power.h ****   </tr>
 115:/usr/lib/avr/include/avr/power.h **** 
 116:/usr/lib/avr/include/avr/power.h ****   <tr>
 117:/usr/lib/avr/include/avr/power.h ****     <td>power_psc0_disable()</td>
 118:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Power Stage Controller 0 module.</td>
 119:/usr/lib/avr/include/avr/power.h ****     <td>AT90PWM1, AT90PWM2, AT90PWM2B, AT90PWM3, AT90PWM3B</td>
 120:/usr/lib/avr/include/avr/power.h ****   </tr>
 121:/usr/lib/avr/include/avr/power.h **** 
 122:/usr/lib/avr/include/avr/power.h ****   <tr>
 123:/usr/lib/avr/include/avr/power.h ****     <td>power_psc1_enable()</td>
 124:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Power Stage Controller 1 module.</td>
 125:/usr/lib/avr/include/avr/power.h ****     <td>AT90PWM1, AT90PWM2, AT90PWM2B, AT90PWM3, AT90PWM3B</td>
 126:/usr/lib/avr/include/avr/power.h ****   </tr>
 127:/usr/lib/avr/include/avr/power.h **** 
 128:/usr/lib/avr/include/avr/power.h ****   <tr>
 129:/usr/lib/avr/include/avr/power.h ****     <td>power_psc1_disable()</td>
 130:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Power Stage Controller 1 module.</td>
 131:/usr/lib/avr/include/avr/power.h ****     <td>AT90PWM1, AT90PWM2, AT90PWM2B, AT90PWM3, AT90PWM3B</td>
 132:/usr/lib/avr/include/avr/power.h ****   </tr>
 133:/usr/lib/avr/include/avr/power.h **** 
 134:/usr/lib/avr/include/avr/power.h ****   <tr>
 135:/usr/lib/avr/include/avr/power.h ****     <td>power_psc2_enable()</td>
 136:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Power Stage Controller 2 module.</td>
 137:/usr/lib/avr/include/avr/power.h ****     <td>AT90PWM1, AT90PWM2, AT90PWM2B, AT90PWM3, AT90PWM3B, AT90PWM81</td>
 138:/usr/lib/avr/include/avr/power.h ****   </tr>
 139:/usr/lib/avr/include/avr/power.h **** 
 140:/usr/lib/avr/include/avr/power.h ****   <tr>
 141:/usr/lib/avr/include/avr/power.h ****     <td>power_psc2_disable()</td>
 142:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Power Stage Controller 2 module.</td>
 143:/usr/lib/avr/include/avr/power.h ****     <td>AT90PWM1, AT90PWM2, AT90PWM2B, AT90PWM3, AT90PWM3B, AT90PWM81</td>
 144:/usr/lib/avr/include/avr/power.h ****   </tr>
 145:/usr/lib/avr/include/avr/power.h **** 
 146:/usr/lib/avr/include/avr/power.h ****   <tr>
 147:/usr/lib/avr/include/avr/power.h ****     <td>power_spi_enable()</td>
 148:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Serial Peripheral Interface module.</td>
 149:/usr/lib/avr/include/avr/power.h ****     <td>ATmega640, ATmega1280, ATmega1281, ATmega128RFA1, ATmega2560, ATmega2561, AT90USB646, AT90U
 150:/usr/lib/avr/include/avr/power.h ****   </tr>
 151:/usr/lib/avr/include/avr/power.h **** 
 152:/usr/lib/avr/include/avr/power.h ****   <tr>
 153:/usr/lib/avr/include/avr/power.h ****     <td>power_spi_disable()</td>
 154:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Serial Peripheral Interface module.</td>
 155:/usr/lib/avr/include/avr/power.h ****     <td>ATmega640, ATmega1280, ATmega1281, ATmega128RFA1, ATmega2560, ATmega2561, AT90USB646, AT90U
 156:/usr/lib/avr/include/avr/power.h ****   </tr>
 157:/usr/lib/avr/include/avr/power.h **** 
 158:/usr/lib/avr/include/avr/power.h ****   <tr>
 159:/usr/lib/avr/include/avr/power.h ****     <td>power_timer0_enable()</td>
 160:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 0 module.</td>
 161:/usr/lib/avr/include/avr/power.h ****     <td>ATmega640, ATmega1280, ATmega1281, ATmega128RFA1, ATmega2560, ATmega2561, AT90USB646, AT90U
 162:/usr/lib/avr/include/avr/power.h ****   </tr>
 163:/usr/lib/avr/include/avr/power.h **** 
 164:/usr/lib/avr/include/avr/power.h ****   <tr>
 165:/usr/lib/avr/include/avr/power.h ****     <td>power_timer0_disable()</td>
 166:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 0 module.</td>
 167:/usr/lib/avr/include/avr/power.h ****     <td>ATmega640, ATmega1280, ATmega1281, ATmega128RFA1, ATmega2560, ATmega2561, AT90USB646, AT90U
 168:/usr/lib/avr/include/avr/power.h ****   </tr>
 169:/usr/lib/avr/include/avr/power.h **** 
 170:/usr/lib/avr/include/avr/power.h ****   <tr>
 171:/usr/lib/avr/include/avr/power.h ****     <td>power_timer1_enable()</td>
 172:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 1 module.</td>
 173:/usr/lib/avr/include/avr/power.h ****     <td>ATmega640, ATmega1280, ATmega1281, ATmega128RFA1, ATmega2560, ATmega2561, AT90USB646, AT90U
 174:/usr/lib/avr/include/avr/power.h ****   </tr>
 175:/usr/lib/avr/include/avr/power.h **** 
 176:/usr/lib/avr/include/avr/power.h ****   <tr>
 177:/usr/lib/avr/include/avr/power.h ****     <td>power_timer1_disable()</td>
 178:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 1 module.</td>
 179:/usr/lib/avr/include/avr/power.h ****     <td>ATmega640, ATmega1280, ATmega1281, ATmega128RFA1, ATmega2560, ATmega2561, AT90USB646, AT90U
 180:/usr/lib/avr/include/avr/power.h ****   </tr>
 181:/usr/lib/avr/include/avr/power.h **** 
 182:/usr/lib/avr/include/avr/power.h ****   <tr>
 183:/usr/lib/avr/include/avr/power.h ****     <td>power_timer2_enable()</td>
 184:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 2 module.</td>
 185:/usr/lib/avr/include/avr/power.h ****     <td>ATmega640, ATmega1280, ATmega1281, ATmega128RFA1, ATmega2560, ATmega2561, AT90USB646, AT90U
 186:/usr/lib/avr/include/avr/power.h ****   </tr>
 187:/usr/lib/avr/include/avr/power.h **** 
 188:/usr/lib/avr/include/avr/power.h ****   <tr>
 189:/usr/lib/avr/include/avr/power.h ****     <td>power_timer2_disable()</td>
 190:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 2 module.</td>
 191:/usr/lib/avr/include/avr/power.h ****     <td>ATmega640, ATmega1280, ATmega1281, ATmega128RFA1, ATmega2560, ATmega2561, AT90USB646, AT90U
 192:/usr/lib/avr/include/avr/power.h ****   </tr>
 193:/usr/lib/avr/include/avr/power.h **** 
 194:/usr/lib/avr/include/avr/power.h ****   <tr>
 195:/usr/lib/avr/include/avr/power.h ****     <td>power_timer3_enable()</td>
 196:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 3 module.</td>
 197:/usr/lib/avr/include/avr/power.h ****     <td>ATmega640, ATmega1280, ATmega1281, ATmega128RFA1, ATmega2560, ATmega2561, AT90USB646, AT90U
 198:/usr/lib/avr/include/avr/power.h ****   </tr>
 199:/usr/lib/avr/include/avr/power.h **** 
 200:/usr/lib/avr/include/avr/power.h ****   <tr>
 201:/usr/lib/avr/include/avr/power.h ****     <td>power_timer3_disable()</td>
 202:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 3 module.</td>
 203:/usr/lib/avr/include/avr/power.h ****     <td>ATmega640, ATmega1280, ATmega1281, ATmega128RFA1, ATmega2560, ATmega2561, AT90USB646, AT90U
 204:/usr/lib/avr/include/avr/power.h ****   </tr>
 205:/usr/lib/avr/include/avr/power.h **** 
 206:/usr/lib/avr/include/avr/power.h ****   <tr>
 207:/usr/lib/avr/include/avr/power.h ****     <td>power_timer4_enable()</td>
 208:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 4 module.</td>
 209:/usr/lib/avr/include/avr/power.h ****     <td>ATmega640, ATmega1280, ATmega1281, ATmega128RFA1, ATmega2560, ATmega2561</td>
 210:/usr/lib/avr/include/avr/power.h ****   </tr>
 211:/usr/lib/avr/include/avr/power.h **** 
 212:/usr/lib/avr/include/avr/power.h ****   <tr>
 213:/usr/lib/avr/include/avr/power.h ****     <td>power_timer4_disable()</td>
 214:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 4 module.</td>
 215:/usr/lib/avr/include/avr/power.h ****     <td>ATmega640, ATmega1280, ATmega1281, ATmega128RFA1, ATmega2560, ATmega2561</td>
 216:/usr/lib/avr/include/avr/power.h ****   </tr>
 217:/usr/lib/avr/include/avr/power.h **** 
 218:/usr/lib/avr/include/avr/power.h ****   <tr>
 219:/usr/lib/avr/include/avr/power.h ****     <td>power_timer5_enable()</td>
 220:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Timer 5 module.</td>
 221:/usr/lib/avr/include/avr/power.h ****     <td>ATmega640, ATmega1280, ATmega1281, ATmega128RFA1, ATmega2560, ATmega2561</td>
 222:/usr/lib/avr/include/avr/power.h ****   </tr>
 223:/usr/lib/avr/include/avr/power.h **** 
 224:/usr/lib/avr/include/avr/power.h ****   <tr>
 225:/usr/lib/avr/include/avr/power.h ****     <td>power_timer5_disable()</td>
 226:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Timer 5 module.</td>
 227:/usr/lib/avr/include/avr/power.h ****     <td>ATmega640, ATmega1280, ATmega1281, ATmega128RFA1, ATmega2560, ATmega2561</td>
 228:/usr/lib/avr/include/avr/power.h ****   </tr>
 229:/usr/lib/avr/include/avr/power.h **** 
 230:/usr/lib/avr/include/avr/power.h ****   <tr>
 231:/usr/lib/avr/include/avr/power.h ****     <td>power_twi_enable()</td>
 232:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Two Wire Interface module.</td>
 233:/usr/lib/avr/include/avr/power.h ****     <td>ATmega640, ATmega1280, ATmega1281, ATmega128RFA1, ATmega2560, ATmega2561, AT90USB646, AT90U
 234:/usr/lib/avr/include/avr/power.h ****   </tr>
 235:/usr/lib/avr/include/avr/power.h **** 
 236:/usr/lib/avr/include/avr/power.h ****   <tr>
 237:/usr/lib/avr/include/avr/power.h ****     <td>power_twi_disable()</td>
 238:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Two Wire Interface module.</td>
 239:/usr/lib/avr/include/avr/power.h ****     <td>ATmega640, ATmega1280, ATmega1281, ATmega128RFA1, ATmega2560, ATmega2561, AT90USB646, AT90U
 240:/usr/lib/avr/include/avr/power.h ****   </tr>
 241:/usr/lib/avr/include/avr/power.h **** 
 242:/usr/lib/avr/include/avr/power.h ****   <tr>
 243:/usr/lib/avr/include/avr/power.h ****     <td>power_usart_enable()</td>
 244:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USART module.</td>
 245:/usr/lib/avr/include/avr/power.h ****     <td>AT90PWM2, AT90PWM2B, AT90PWM3, AT90PWM3B</td>
 246:/usr/lib/avr/include/avr/power.h ****   </tr>
 247:/usr/lib/avr/include/avr/power.h **** 
 248:/usr/lib/avr/include/avr/power.h ****   <tr>
 249:/usr/lib/avr/include/avr/power.h ****     <td>power_usart_disable()</td>
 250:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USART module.</td>
 251:/usr/lib/avr/include/avr/power.h ****     <td>AT90PWM2, AT90PWM2B, AT90PWM3, AT90PWM3B</td>
 252:/usr/lib/avr/include/avr/power.h ****   </tr>
 253:/usr/lib/avr/include/avr/power.h **** 
 254:/usr/lib/avr/include/avr/power.h ****   <tr>
 255:/usr/lib/avr/include/avr/power.h ****     <td>power_usart0_enable()</td>
 256:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USART 0 module.</td>
 257:/usr/lib/avr/include/avr/power.h ****     <td>ATmega640, ATmega1280, ATmega1281, ATmega128RFA1, ATmega2560, ATmega2561, ATmega165, ATmega
 258:/usr/lib/avr/include/avr/power.h ****   </tr>
 259:/usr/lib/avr/include/avr/power.h **** 
 260:/usr/lib/avr/include/avr/power.h ****   <tr>
 261:/usr/lib/avr/include/avr/power.h ****     <td>power_usart0_disable()</td>
 262:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USART 0 module.</td>
 263:/usr/lib/avr/include/avr/power.h ****     <td>ATmega640, ATmega1280, ATmega1281, ATmega128RFA1, ATmega2560, ATmega2561, ATmega165, ATmega
 264:/usr/lib/avr/include/avr/power.h ****   </tr>
 265:/usr/lib/avr/include/avr/power.h **** 
 266:/usr/lib/avr/include/avr/power.h ****   <tr>
 267:/usr/lib/avr/include/avr/power.h ****     <td>power_usart1_enable()</td>
 268:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USART 1 module.</td>
 269:/usr/lib/avr/include/avr/power.h ****     <td>ATmega640, ATmega1280, ATmega1281, ATmega128RFA1, ATmega2560, ATmega2561, AT90USB646, AT90U
 270:/usr/lib/avr/include/avr/power.h ****   </tr>
 271:/usr/lib/avr/include/avr/power.h **** 
 272:/usr/lib/avr/include/avr/power.h ****   <tr>
 273:/usr/lib/avr/include/avr/power.h ****     <td>power_usart1_disable()</td>
 274:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USART 1 module.</td>
 275:/usr/lib/avr/include/avr/power.h ****     <td>ATmega640, ATmega1280, ATmega1281, ATmega128RFA1, ATmega2560, ATmega2561, AT90USB646, AT90U
 276:/usr/lib/avr/include/avr/power.h ****   </tr>
 277:/usr/lib/avr/include/avr/power.h **** 
 278:/usr/lib/avr/include/avr/power.h ****   <tr>
 279:/usr/lib/avr/include/avr/power.h ****     <td>power_usart2_enable()</td>
 280:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USART 2 module.</td>
 281:/usr/lib/avr/include/avr/power.h ****     <td>ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561</td>
 282:/usr/lib/avr/include/avr/power.h ****   </tr>
 283:/usr/lib/avr/include/avr/power.h **** 
 284:/usr/lib/avr/include/avr/power.h ****   <tr>
 285:/usr/lib/avr/include/avr/power.h ****     <td>power_usart2_disable()</td>
 286:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USART 2 module.</td>
 287:/usr/lib/avr/include/avr/power.h ****     <td>ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561</td>
 288:/usr/lib/avr/include/avr/power.h ****   </tr>
 289:/usr/lib/avr/include/avr/power.h **** 
 290:/usr/lib/avr/include/avr/power.h ****   <tr>
 291:/usr/lib/avr/include/avr/power.h ****     <td>power_usart3_enable()</td>
 292:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USART 3 module.</td>
 293:/usr/lib/avr/include/avr/power.h ****     <td>ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561</td>
 294:/usr/lib/avr/include/avr/power.h ****   </tr>
 295:/usr/lib/avr/include/avr/power.h **** 
 296:/usr/lib/avr/include/avr/power.h ****   <tr>
 297:/usr/lib/avr/include/avr/power.h ****     <td>power_usart3_disable()</td>
 298:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USART 3 module.</td>
 299:/usr/lib/avr/include/avr/power.h ****     <td>ATmega640, ATmega1280, ATmega1281, ATmega2560, ATmega2561</td>
 300:/usr/lib/avr/include/avr/power.h ****   </tr>
 301:/usr/lib/avr/include/avr/power.h **** 
 302:/usr/lib/avr/include/avr/power.h ****   <tr>
 303:/usr/lib/avr/include/avr/power.h ****     <td>power_usb_enable()</td>
 304:/usr/lib/avr/include/avr/power.h ****     <td>Enable the USB module.</td>
 305:/usr/lib/avr/include/avr/power.h ****     <td>AT90USB646, AT90USB647, AT90USB1286, AT90USB1287</td>
 306:/usr/lib/avr/include/avr/power.h ****   </tr>
 307:/usr/lib/avr/include/avr/power.h **** 
 308:/usr/lib/avr/include/avr/power.h ****   <tr>
 309:/usr/lib/avr/include/avr/power.h ****     <td>power_usb_disable()</td>
 310:/usr/lib/avr/include/avr/power.h ****     <td>Disable the USB module.</td>
 311:/usr/lib/avr/include/avr/power.h ****     <td>AT90USB646, AT90USB647, AT90USB1286, AT90USB1287</td>
 312:/usr/lib/avr/include/avr/power.h ****   </tr>
 313:/usr/lib/avr/include/avr/power.h **** 
 314:/usr/lib/avr/include/avr/power.h ****   <tr>
 315:/usr/lib/avr/include/avr/power.h ****     <td>power_usi_enable()</td>
 316:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Universal Serial Interface module.</td>
 317:/usr/lib/avr/include/avr/power.h ****     <td>ATtiny24, ATtiny44, ATtiny84, ATtiny84A, ATtiny25, ATtiny45, ATtiny85, ATtiny261, ATtiny461
 318:/usr/lib/avr/include/avr/power.h ****   </tr>
 319:/usr/lib/avr/include/avr/power.h **** 
 320:/usr/lib/avr/include/avr/power.h ****   <tr>
 321:/usr/lib/avr/include/avr/power.h ****     <td>power_usi_disable()</td>
 322:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Universal Serial Interface module.</td>
 323:/usr/lib/avr/include/avr/power.h ****     <td>ATtiny24, ATtiny44, ATtiny84, ATtiny84A, ATtiny25, ATtiny45, ATtiny85, ATtiny261, ATtiny461
 324:/usr/lib/avr/include/avr/power.h ****   </tr>
 325:/usr/lib/avr/include/avr/power.h **** 
 326:/usr/lib/avr/include/avr/power.h ****   <tr>
 327:/usr/lib/avr/include/avr/power.h ****     <td>power_vadc_enable()</td>
 328:/usr/lib/avr/include/avr/power.h ****     <td>Enable the Voltage ADC module.</td>
 329:/usr/lib/avr/include/avr/power.h ****     <td>ATmega406</td>
 330:/usr/lib/avr/include/avr/power.h ****   </tr>
 331:/usr/lib/avr/include/avr/power.h **** 
 332:/usr/lib/avr/include/avr/power.h ****   <tr>
 333:/usr/lib/avr/include/avr/power.h ****     <td>power_vadc_disable()</td>
 334:/usr/lib/avr/include/avr/power.h ****     <td>Disable the Voltage ADC module.</td>
 335:/usr/lib/avr/include/avr/power.h ****     <td>ATmega406</td>
 336:/usr/lib/avr/include/avr/power.h ****   </tr>
 337:/usr/lib/avr/include/avr/power.h **** 
 338:/usr/lib/avr/include/avr/power.h ****   <tr>
 339:/usr/lib/avr/include/avr/power.h ****     <td>power_all_enable()</td>
 340:/usr/lib/avr/include/avr/power.h ****     <td>Enable all modules.</td>
 341:/usr/lib/avr/include/avr/power.h ****     <td>ATxmega6A4, ATxmega32A4, ATxmega64A1, ATxmega64A1U, ATxmega64A3, ATxmegaA1, ATxmegaA1U, ATx
 342:/usr/lib/avr/include/avr/power.h ****   </tr>
 343:/usr/lib/avr/include/avr/power.h **** 
 344:/usr/lib/avr/include/avr/power.h ****   <tr>
 345:/usr/lib/avr/include/avr/power.h ****     <td>power_all_disable()</td>
 346:/usr/lib/avr/include/avr/power.h ****     <td>Disable all modules.</td>
 347:/usr/lib/avr/include/avr/power.h ****     <td>ATxmega6A4, ATxmega32A4, ATxmega64A1, ATxmega64A1U, ATxmega64A3, ATxmegaA1, ATxmegaA1U, ATx
 348:/usr/lib/avr/include/avr/power.h ****   </tr>
 349:/usr/lib/avr/include/avr/power.h **** </table>
 350:/usr/lib/avr/include/avr/power.h **** </center>
 351:/usr/lib/avr/include/avr/power.h **** </small>
 352:/usr/lib/avr/include/avr/power.h **** 
 353:/usr/lib/avr/include/avr/power.h **** @} */
 354:/usr/lib/avr/include/avr/power.h **** 
 355:/usr/lib/avr/include/avr/power.h **** // Xmega A series has AES, EBI and DMA bits
 356:/usr/lib/avr/include/avr/power.h **** // Include any other device on need basis
 357:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_ATxmega16A4__) \
 358:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATxmega32A4__) \
 359:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATxmega64A1__) \
 360:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATxmega64A1U__) \
 361:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATxmega64A3__) \
 362:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATxmega128A1__) \
 363:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATxmega128A1U__) \
 364:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATxmega128A3__) \
 365:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATxmega192A3__) \
 366:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATxmega256A3__) \
 367:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATxmega256A3B__)
 368:/usr/lib/avr/include/avr/power.h **** 
 369:/usr/lib/avr/include/avr/power.h **** #define power_aes_enable()  (PR_PRGEN &= (uint8_t)~(PR_AES_bm))
 370:/usr/lib/avr/include/avr/power.h **** #define power_aes_disable() (PR_PRGEN |= (uint8_t)PR_AES_bm)
 371:/usr/lib/avr/include/avr/power.h **** 
 372:/usr/lib/avr/include/avr/power.h **** #define power_ebi_enable()  (PR_PRGEN &= (uint8_t)~(PR_EBI_bm))
 373:/usr/lib/avr/include/avr/power.h **** #define power_ebi_disable() (PR_PRGEN |= (uint8_t)PR_EBI_bm)
 374:/usr/lib/avr/include/avr/power.h **** 
 375:/usr/lib/avr/include/avr/power.h **** #define power_dma_enable()    (PR_PRGEN &= (uint8_t)~(PR_DMA_bm))
 376:/usr/lib/avr/include/avr/power.h **** #define power_dma_disable()   (PR_PRGEN |= (uint8_t)PR_DMA_bm)
 377:/usr/lib/avr/include/avr/power.h **** 
 378:/usr/lib/avr/include/avr/power.h **** #define power_daca_enable()     (PR_PRPA &= (uint8_t)~(PR_DAC_bm))
 379:/usr/lib/avr/include/avr/power.h **** #define power_daca_disable()    (PR_PRPA |= (uint8_t)PR_DAC_bm)
 380:/usr/lib/avr/include/avr/power.h **** #define power_dacb_enable()     (PR_PRPB &= (uint8_t)~(PR_DAC_bm))
 381:/usr/lib/avr/include/avr/power.h **** #define power_dacb_disable()    (PR_PRPB |= (uint8_t)PR_DAC_bm)
 382:/usr/lib/avr/include/avr/power.h **** 
 383:/usr/lib/avr/include/avr/power.h **** #define power_usartc1_enable()  (PR_PRPC &= (uint8_t)~(PR_USART1_bm))
 384:/usr/lib/avr/include/avr/power.h **** #define power_usartc1_disable() (PR_PRPC |= (uint8_t)PR_USART1_bm)
 385:/usr/lib/avr/include/avr/power.h **** #define power_usartd1_enable()  (PR_PRPD &= (uint8_t)~(PR_USART1_bm))
 386:/usr/lib/avr/include/avr/power.h **** #define power_usartd1_disable() (PR_PRPD |= (uint8_t)PR_USART1_bm)
 387:/usr/lib/avr/include/avr/power.h **** #define power_usarte1_enable()  (PR_PRPE &= (uint8_t)~(PR_USART1_bm))
 388:/usr/lib/avr/include/avr/power.h **** #define power_usarte1_disable() (PR_PRPE |= (uint8_t)PR_USART1_bm)
 389:/usr/lib/avr/include/avr/power.h **** #define power_usartf1_enable()  (PR_PRPF &= (uint8_t)~(PR_USART1_bm))
 390:/usr/lib/avr/include/avr/power.h **** #define power_usartf1_disable() (PR_PRPF |= (uint8_t)PR_USART1_bm)
 391:/usr/lib/avr/include/avr/power.h **** 
 392:/usr/lib/avr/include/avr/power.h **** #define power_all_enable() \
 393:/usr/lib/avr/include/avr/power.h **** do { \
 394:/usr/lib/avr/include/avr/power.h ****     PR_PRGEN &= (uint8_t)~(PR_AES_bm|PR_EBI_bm|PR_RTC_bm|PR_EVSYS_bm|PR_DMA_bm); \
 395:/usr/lib/avr/include/avr/power.h ****     PR_PRPA &= (uint8_t)~(PR_DAC_bm|PR_ADC_bm|PR_AC_bm); \
 396:/usr/lib/avr/include/avr/power.h ****     PR_PRPB &= (uint8_t)~(PR_DAC_bm|PR_ADC_bm|PR_AC_bm); \
 397:/usr/lib/avr/include/avr/power.h ****     PR_PRPC &= (uint8_t)~(PR_TWI_bm|PR_USART1_bm|PR_USART0_bm|PR_SPI_bm|PR_HIRES_bm|PR_TC1_bm|PR_TC
 398:/usr/lib/avr/include/avr/power.h ****     PR_PRPD &= (uint8_t)~(PR_TWI_bm|PR_USART1_bm|PR_USART0_bm|PR_SPI_bm|PR_HIRES_bm|PR_TC1_bm|PR_TC
 399:/usr/lib/avr/include/avr/power.h ****     PR_PRPE &= (uint8_t)~(PR_TWI_bm|PR_USART1_bm|PR_USART0_bm|PR_SPI_bm|PR_HIRES_bm|PR_TC1_bm|PR_TC
 400:/usr/lib/avr/include/avr/power.h ****     PR_PRPF &= (uint8_t)~(PR_TWI_bm|PR_USART1_bm|PR_USART0_bm|PR_SPI_bm|PR_HIRES_bm|PR_TC1_bm|PR_TC
 401:/usr/lib/avr/include/avr/power.h **** } while(0)
 402:/usr/lib/avr/include/avr/power.h **** 
 403:/usr/lib/avr/include/avr/power.h **** 
 404:/usr/lib/avr/include/avr/power.h **** #define power_all_disable() \
 405:/usr/lib/avr/include/avr/power.h **** do { \
 406:/usr/lib/avr/include/avr/power.h ****     PR_PRGEN|= (uint8_t)(PR_AES_bm|PR_EBI_bm|PR_RTC_bm|PR_EVSYS_bm|PR_DMA_bm); \
 407:/usr/lib/avr/include/avr/power.h ****     PR_PRPA |= (uint8_t)(PR_DAC_bm|PR_ADC_bm|PR_AC_bm); \
 408:/usr/lib/avr/include/avr/power.h ****     PR_PRPB |= (uint8_t)(PR_DAC_bm|PR_ADC_bm|PR_AC_bm); \
 409:/usr/lib/avr/include/avr/power.h ****     PR_PRPC |= (uint8_t)(PR_TWI_bm|PR_USART1_bm|PR_USART0_bm|PR_SPI_bm|PR_HIRES_bm|PR_TC1_bm|PR_TC0
 410:/usr/lib/avr/include/avr/power.h ****     PR_PRPD |= (uint8_t)(PR_TWI_bm|PR_USART1_bm|PR_USART0_bm|PR_SPI_bm|PR_HIRES_bm|PR_TC1_bm|PR_TC0
 411:/usr/lib/avr/include/avr/power.h ****     PR_PRPE |= (uint8_t)(PR_TWI_bm|PR_USART1_bm|PR_USART0_bm|PR_SPI_bm|PR_HIRES_bm|PR_TC1_bm|PR_TC0
 412:/usr/lib/avr/include/avr/power.h ****     PR_PRPF |= (uint8_t)(PR_TWI_bm|PR_USART1_bm|PR_USART0_bm|PR_SPI_bm|PR_HIRES_bm|PR_TC1_bm|PR_TC0
 413:/usr/lib/avr/include/avr/power.h **** } while(0)
 414:/usr/lib/avr/include/avr/power.h **** #endif
 415:/usr/lib/avr/include/avr/power.h **** 
 416:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_ATxmega16A4__) \
 417:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATxmega16D4__) \
 418:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATxmega32A4__) \
 419:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATxmega32D4__) \
 420:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATxmega64A1__) \
 421:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATxmega64A1U__) \
 422:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATxmega64A3__) \
 423:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATxmega64D3__) \
 424:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATxmega128A1__) \
 425:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATxmega128A1U__) \
 426:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATxmega128A3__) \
 427:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATxmega128D3__) \
 428:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATxmega192A3__) \
 429:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATxmega192D3__) \
 430:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATxmega256A3__) \
 431:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATxmega256A3B__)
 432:/usr/lib/avr/include/avr/power.h **** 
 433:/usr/lib/avr/include/avr/power.h **** 
 434:/usr/lib/avr/include/avr/power.h **** #define power_rtc_enable()  (PR_PRGEN &= (uint8_t)~(PR_RTC_bm))
 435:/usr/lib/avr/include/avr/power.h **** #define power_rtc_disable() (PR_PRGEN |= (uint8_t)PR_RTC_bm)
 436:/usr/lib/avr/include/avr/power.h **** 
 437:/usr/lib/avr/include/avr/power.h **** #define power_evsys_enable()    (PR_PRGEN &= (uint8_t)~(PR_EVSYS_bm))
 438:/usr/lib/avr/include/avr/power.h **** #define power_evsys_disable()   (PR_PRGEN |= (uint8_t)PR_EVSYS_bm)
 439:/usr/lib/avr/include/avr/power.h **** 
 440:/usr/lib/avr/include/avr/power.h **** #define power_adca_enable()     (PR_PRPA &= (uint8_t)~(PR_ADC_bm))
 441:/usr/lib/avr/include/avr/power.h **** #define power_adca_disable()    (PR_PRPA |= (uint8_t)PR_ADC_bm)
 442:/usr/lib/avr/include/avr/power.h **** #define power_adcb_enable()     (PR_PRPB &= (uint8_t)~(PR_ADC_bm))
 443:/usr/lib/avr/include/avr/power.h **** #define power_adcb_disable()    (PR_PRPB |= (uint8_t)PR_ADC_bm)
 444:/usr/lib/avr/include/avr/power.h **** 
 445:/usr/lib/avr/include/avr/power.h **** #define power_aca_enable()      (PR_PRPA &= (uint8_t)~(PR_AC_bm))
 446:/usr/lib/avr/include/avr/power.h **** #define power_aca_disable()     (PR_PRPA |= (uint8_t)PR_AC_bm)
 447:/usr/lib/avr/include/avr/power.h **** #define power_acb_enable()      (PR_PRPB &= (uint8_t)~(PR_AC_bm))
 448:/usr/lib/avr/include/avr/power.h **** #define power_acb_disable()     (PR_PRPB |= (uint8_t)PR_AC_bm)
 449:/usr/lib/avr/include/avr/power.h **** 
 450:/usr/lib/avr/include/avr/power.h **** #define power_twic_enable()     (PR_PRPC &= (uint8_t)~(PR_TWI_bm))
 451:/usr/lib/avr/include/avr/power.h **** #define power_twic_disable()    (PR_PRPC |= (uint8_t)PR_TWI_bm)
 452:/usr/lib/avr/include/avr/power.h **** #define power_twid_enable()     (PR_PRPD &= (uint8_t)~(PR_TWI_bm))
 453:/usr/lib/avr/include/avr/power.h **** #define power_twid_disable()    (PR_PRPD |= (uint8_t)PR_TWI_bm)
 454:/usr/lib/avr/include/avr/power.h **** #define power_twie_enable()     (PR_PRPE &= (uint8_t)~(PR_TWI_bm))
 455:/usr/lib/avr/include/avr/power.h **** #define power_twie_disable()    (PR_PRPE |= (uint8_t)PR_TWI_bm)
 456:/usr/lib/avr/include/avr/power.h **** #define power_twif_enable()     (PR_PRPF &= (uint8_t)~(PR_TWI_bm))
 457:/usr/lib/avr/include/avr/power.h **** #define power_twif_disable()    (PR_PRPF |= (uint8_t)PR_TWI_bm)
 458:/usr/lib/avr/include/avr/power.h **** 
 459:/usr/lib/avr/include/avr/power.h **** #define power_usartc0_enable()  (PR_PRPC &= (uint8_t)~(PR_USART0_bm))
 460:/usr/lib/avr/include/avr/power.h **** #define power_usartc0_disable() (PR_PRPC |= (uint8_t)PR_USART0_bm)
 461:/usr/lib/avr/include/avr/power.h **** #define power_usartd0_enable()  (PR_PRPD &= (uint8_t)~(PR_USART0_bm))
 462:/usr/lib/avr/include/avr/power.h **** #define power_usartd0_disable() (PR_PRPD |= (uint8_t)PR_USART0_bm)
 463:/usr/lib/avr/include/avr/power.h **** #define power_usarte0_enable()  (PR_PRPE &= (uint8_t)~(PR_USART0_bm))
 464:/usr/lib/avr/include/avr/power.h **** #define power_usarte0_disable() (PR_PRPE |= (uint8_t)PR_USART0_bm)
 465:/usr/lib/avr/include/avr/power.h **** #define power_usartf0_enable()  (PR_PRPF &= (uint8_t)~(PR_USART0_bm))
 466:/usr/lib/avr/include/avr/power.h **** #define power_usartf0_disable() (PR_PRPF |= (uint8_t)PR_USART0_bm)
 467:/usr/lib/avr/include/avr/power.h **** 
 468:/usr/lib/avr/include/avr/power.h **** #define power_spic_enable()     (PR_PRPC &= (uint8_t)~(PR_SPI_bm))
 469:/usr/lib/avr/include/avr/power.h **** #define power_spic_disable()    (PR_PRPC |= (uint8_t)PR_SPI_bm)
 470:/usr/lib/avr/include/avr/power.h **** #define power_spid_enable()     (PR_PRPD &= (uint8_t)~(PR_SPI_bm))
 471:/usr/lib/avr/include/avr/power.h **** #define power_spid_disable()    (PR_PRPD |= (uint8_t)PR_SPI_bm)
 472:/usr/lib/avr/include/avr/power.h **** #define power_spie_enable()     (PR_PRPE &= (uint8_t)~(PR_SPI_bm))
 473:/usr/lib/avr/include/avr/power.h **** #define power_spie_disable()    (PR_PRPE |= (uint8_t)PR_SPI_bm)
 474:/usr/lib/avr/include/avr/power.h **** #define power_spif_enable()     (PR_PRPF &= (uint8_t)~(PR_SPI_bm))
 475:/usr/lib/avr/include/avr/power.h **** #define power_spif_disable()    (PR_PRPF |= (uint8_t)PR_SPI_bm)
 476:/usr/lib/avr/include/avr/power.h **** 
 477:/usr/lib/avr/include/avr/power.h **** #define power_hiresc_enable()   (PR_PRPC &= (uint8_t)~(PR_HIRES_bm))
 478:/usr/lib/avr/include/avr/power.h **** #define power_hiresc_disable()  (PR_PRPC |= (uint8_t)PR_HIRES_bm)
 479:/usr/lib/avr/include/avr/power.h **** #define power_hiresd_enable()   (PR_PRPD &= (uint8_t)~(PR_HIRES_bm))
 480:/usr/lib/avr/include/avr/power.h **** #define power_hiresd_disable()  (PR_PRPD |= (uint8_t)PR_HIRES_bm)
 481:/usr/lib/avr/include/avr/power.h **** #define power_hirese_enable()   (PR_PRPE &= (uint8_t)~(PR_HIRES_bm))
 482:/usr/lib/avr/include/avr/power.h **** #define power_hirese_disable()  (PR_PRPE |= (uint8_t)PR_HIRES_bm)
 483:/usr/lib/avr/include/avr/power.h **** #define power_hiresf_enable()   (PR_PRPF &= (uint8_t)~(PR_HIRES_bm))
 484:/usr/lib/avr/include/avr/power.h **** #define power_hiresf_disable()  (PR_PRPF |= (uint8_t)PR_HIRES_bm)
 485:/usr/lib/avr/include/avr/power.h **** 
 486:/usr/lib/avr/include/avr/power.h **** #define power_tc1c_enable()     (PR_PRPC &= (uint8_t)~(PR_TC1_bm))
 487:/usr/lib/avr/include/avr/power.h **** #define power_tc1c_disable()    (PR_PRPC |= (uint8_t)PR_TC1_bm)
 488:/usr/lib/avr/include/avr/power.h **** #define power_tc1d_enable()     (PR_PRPD &= (uint8_t)~(PR_TC1_bm))
 489:/usr/lib/avr/include/avr/power.h **** #define power_tc1d_disable()    (PR_PRPD |= (uint8_t)PR_TC1_bm)
 490:/usr/lib/avr/include/avr/power.h **** #define power_tc1e_enable()     (PR_PRPE &= (uint8_t)~(PR_TC1_bm))
 491:/usr/lib/avr/include/avr/power.h **** #define power_tc1e_disable()    (PR_PRPE |= (uint8_t)PR_TC1_bm)
 492:/usr/lib/avr/include/avr/power.h **** #define power_tc1f_enable()     (PR_PRPF &= (uint8_t)~(PR_TC1_bm))
 493:/usr/lib/avr/include/avr/power.h **** #define power_tc1f_disable()    (PR_PRPF |= (uint8_t)PR_TC1_bm)
 494:/usr/lib/avr/include/avr/power.h **** 
 495:/usr/lib/avr/include/avr/power.h **** #define power_tc0c_enable()     (PR_PRPC &= (uint8_t)~(PR_TC0_bm))
 496:/usr/lib/avr/include/avr/power.h **** #define power_tc0c_disable()    (PR_PRPC |= (uint8_t)PR_TC0_bm)
 497:/usr/lib/avr/include/avr/power.h **** #define power_tc0d_enable()     (PR_PRPD &= (uint8_t)~(PR_TC0_bm))
 498:/usr/lib/avr/include/avr/power.h **** #define power_tc0d_disable()    (PR_PRPD |= (uint8_t)PR_TC0_bm)
 499:/usr/lib/avr/include/avr/power.h **** #define power_tc0e_enable()     (PR_PRPE &= (uint8_t)~(PR_TC0_bm))
 500:/usr/lib/avr/include/avr/power.h **** #define power_tc0e_disable()    (PR_PRPE |= (uint8_t)PR_TC0_bm)
 501:/usr/lib/avr/include/avr/power.h **** #define power_tc0f_enable()     (PR_PRPF &= (uint8_t)~(PR_TC0_bm))
 502:/usr/lib/avr/include/avr/power.h **** #define power_tc0f_disable()    (PR_PRPF |= (uint8_t)PR_TC0_bm)
 503:/usr/lib/avr/include/avr/power.h **** 
 504:/usr/lib/avr/include/avr/power.h **** #endif
 505:/usr/lib/avr/include/avr/power.h **** 
 506:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_ATxmega16D4__) \
 507:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATxmega32D4__) \
 508:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATxmega64D3__) \
 509:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATxmega128D3__) \
 510:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATxmega192D3__) 
 511:/usr/lib/avr/include/avr/power.h **** 
 512:/usr/lib/avr/include/avr/power.h **** #define power_all_enable() \
 513:/usr/lib/avr/include/avr/power.h **** do { \
 514:/usr/lib/avr/include/avr/power.h ****     PR_PRGEN &= (uint8_t)~(PR_RTC_bm|PR_EVSYS_bm); \
 515:/usr/lib/avr/include/avr/power.h ****     PR_PRPA &= (uint8_t)~(PR_ADC_bm|PR_AC_bm); \
 516:/usr/lib/avr/include/avr/power.h ****     PR_PRPB &= (uint8_t)~(PR_ADC_bm|PR_AC_bm); \
 517:/usr/lib/avr/include/avr/power.h ****     PR_PRPC &= (uint8_t)~(PR_TWI_bm|PR_USART0_bm|PR_SPI_bm|PR_HIRES_bm|PR_TC1_bm|PR_TC0_bm); \
 518:/usr/lib/avr/include/avr/power.h ****     PR_PRPD &= (uint8_t)~(PR_TWI_bm|PR_USART0_bm|PR_SPI_bm|PR_HIRES_bm|PR_TC1_bm|PR_TC0_bm); \
 519:/usr/lib/avr/include/avr/power.h ****     PR_PRPE &= (uint8_t)~(PR_TWI_bm|PR_USART0_bm|PR_SPI_bm|PR_HIRES_bm|PR_TC1_bm|PR_TC0_bm); \
 520:/usr/lib/avr/include/avr/power.h ****     PR_PRPF &= (uint8_t)~(PR_TWI_bm|PR_USART0_bm|PR_SPI_bm|PR_HIRES_bm|PR_TC1_bm|PR_TC0_bm); \
 521:/usr/lib/avr/include/avr/power.h **** } while(0)
 522:/usr/lib/avr/include/avr/power.h **** 
 523:/usr/lib/avr/include/avr/power.h **** 
 524:/usr/lib/avr/include/avr/power.h **** #define power_all_disable() \
 525:/usr/lib/avr/include/avr/power.h **** do { \
 526:/usr/lib/avr/include/avr/power.h ****     PR_PRGEN|= (uint8_t)(PR_EBI_bm|PR_RTC_bm|PR_EVSYS_bm|PR_DMA_bm); \
 527:/usr/lib/avr/include/avr/power.h ****     PR_PRPA |= (uint8_t)(PR_ADC_bm|PR_AC_bm); \
 528:/usr/lib/avr/include/avr/power.h ****     PR_PRPB |= (uint8_t)(PR_ADC_bm|PR_AC_bm); \
 529:/usr/lib/avr/include/avr/power.h ****     PR_PRPC |= (uint8_t)(PR_TWI_bm|R_USART0_bm|PR_SPI_bm|PR_HIRES_bm|PR_TC1_bm|PR_TC0_bm); \
 530:/usr/lib/avr/include/avr/power.h ****     PR_PRPD |= (uint8_t)(PR_TWI_bm|PR_USART0_bm|PR_SPI_bm|PR_HIRES_bm|PR_TC1_bm|PR_TC0_bm); \
 531:/usr/lib/avr/include/avr/power.h ****     PR_PRPE |= (uint8_t)(PR_TWI_bm|PR_USART0_bm|PR_SPI_bm|PR_HIRES_bm|PR_TC1_bm|PR_TC0_bm); \
 532:/usr/lib/avr/include/avr/power.h ****     PR_PRPF |= (uint8_t)(PR_TWI_bm|PR_USART0_bm|PR_SPI_bm|PR_HIRES_bm|PR_TC1_bm|PR_TC0_bm); \
 533:/usr/lib/avr/include/avr/power.h **** } while(0)
 534:/usr/lib/avr/include/avr/power.h **** 
 535:/usr/lib/avr/include/avr/power.h **** #elif defined(__AVR_ATmega640__) \
 536:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega1280__) \
 537:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega1281__) \
 538:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega2560__) \
 539:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega2561__) 
 540:/usr/lib/avr/include/avr/power.h **** 
 541:/usr/lib/avr/include/avr/power.h **** #define power_adc_enable()      (PRR0 &= (uint8_t)~(1 << PRADC))
 542:/usr/lib/avr/include/avr/power.h **** #define power_adc_disable()     (PRR0 |= (uint8_t)(1 << PRADC))
 543:/usr/lib/avr/include/avr/power.h **** 
 544:/usr/lib/avr/include/avr/power.h **** #define power_spi_enable()      (PRR0 &= (uint8_t)~(1 << PRSPI))
 545:/usr/lib/avr/include/avr/power.h **** #define power_spi_disable()     (PRR0 |= (uint8_t)(1 << PRSPI))
 546:/usr/lib/avr/include/avr/power.h **** 
 547:/usr/lib/avr/include/avr/power.h **** #define power_twi_enable()      (PRR0 &= (uint8_t)~(1 << PRTWI))
 548:/usr/lib/avr/include/avr/power.h **** #define power_twi_disable()     (PRR0 |= (uint8_t)(1 << PRTWI))
 549:/usr/lib/avr/include/avr/power.h **** 
 550:/usr/lib/avr/include/avr/power.h **** #define power_timer0_enable()   (PRR0 &= (uint8_t)~(1 << PRTIM0))
 551:/usr/lib/avr/include/avr/power.h **** #define power_timer0_disable()  (PRR0 |= (uint8_t)(1 << PRTIM0))
 552:/usr/lib/avr/include/avr/power.h **** 
 553:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()   (PRR0 &= (uint8_t)~(1 << PRTIM1))
 554:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()  (PRR0 |= (uint8_t)(1 << PRTIM1))
 555:/usr/lib/avr/include/avr/power.h **** 
 556:/usr/lib/avr/include/avr/power.h **** #define power_timer2_enable()   (PRR0 &= (uint8_t)~(1 << PRTIM2))
 557:/usr/lib/avr/include/avr/power.h **** #define power_timer2_disable()  (PRR0 |= (uint8_t)(1 << PRTIM2))
 558:/usr/lib/avr/include/avr/power.h **** 
 559:/usr/lib/avr/include/avr/power.h **** #define power_timer3_enable()   (PRR1 &= (uint8_t)~(1 << PRTIM3))
 560:/usr/lib/avr/include/avr/power.h **** #define power_timer3_disable()  (PRR1 |= (uint8_t)(1 << PRTIM3))
 561:/usr/lib/avr/include/avr/power.h **** 
 562:/usr/lib/avr/include/avr/power.h **** #define power_timer4_enable()   (PRR1 &= (uint8_t)~(1 << PRTIM4))
 563:/usr/lib/avr/include/avr/power.h **** #define power_timer4_disable()  (PRR1 |= (uint8_t)(1 << PRTIM4))
 564:/usr/lib/avr/include/avr/power.h **** 
 565:/usr/lib/avr/include/avr/power.h **** #define power_timer5_enable()   (PRR1 &= (uint8_t)~(1 << PRTIM5))
 566:/usr/lib/avr/include/avr/power.h **** #define power_timer5_disable()  (PRR1 |= (uint8_t)(1 << PRTIM5))
 567:/usr/lib/avr/include/avr/power.h **** 
 568:/usr/lib/avr/include/avr/power.h **** #define power_usart0_enable()   (PRR0 &= (uint8_t)~(1 << PRUSART0))
 569:/usr/lib/avr/include/avr/power.h **** #define power_usart0_disable()  (PRR0 |= (uint8_t)(1 << PRUSART0))
 570:/usr/lib/avr/include/avr/power.h **** 
 571:/usr/lib/avr/include/avr/power.h **** #define power_usart1_enable()   (PRR1 &= (uint8_t)~(1 << PRUSART1))
 572:/usr/lib/avr/include/avr/power.h **** #define power_usart1_disable()  (PRR1 |= (uint8_t)(1 << PRUSART1))
 573:/usr/lib/avr/include/avr/power.h **** 
 574:/usr/lib/avr/include/avr/power.h **** #define power_usart2_enable()   (PRR1 &= (uint8_t)~(1 << PRUSART2))
 575:/usr/lib/avr/include/avr/power.h **** #define power_usart2_disable()  (PRR1 |= (uint8_t)(1 << PRUSART2))
 576:/usr/lib/avr/include/avr/power.h **** 
 577:/usr/lib/avr/include/avr/power.h **** #define power_usart3_enable()   (PRR1 &= (uint8_t)~(1 << PRUSART3))
 578:/usr/lib/avr/include/avr/power.h **** #define power_usart3_disable()  (PRR1 |= (uint8_t)(1 << PRUSART3))
 579:/usr/lib/avr/include/avr/power.h **** 
 580:/usr/lib/avr/include/avr/power.h **** #define power_all_enable() \
 581:/usr/lib/avr/include/avr/power.h **** do{ \
 582:/usr/lib/avr/include/avr/power.h ****     PRR0 &= (uint8_t)~((1<<PRADC)|(1<<PRSPI)|(1<<PRTWI)|(1<<PRTIM0)|(1<<PRTIM1)|(1<<PRTIM2)|(1<<PRU
 583:/usr/lib/avr/include/avr/power.h ****     PRR1 &= (uint8_t)~((1<<PRTIM3)|(1<<PRTIM4)|(1<<PRTIM5)|(1<<PRTIM5)|(1<<PRUSART1)|(1<<PRUSART2)|
 584:/usr/lib/avr/include/avr/power.h **** }while(0)
 585:/usr/lib/avr/include/avr/power.h **** 
 586:/usr/lib/avr/include/avr/power.h **** #define power_all_disable() \
 587:/usr/lib/avr/include/avr/power.h **** do{ \
 588:/usr/lib/avr/include/avr/power.h ****     PRR0 |= (uint8_t)((1<<PRADC)|(1<<PRSPI)|(1<<PRTWI)|(1<<PRTIM0)|(1<<PRTIM1)|(1<<PRTIM2)|(1<<PRUS
 589:/usr/lib/avr/include/avr/power.h ****     PRR1 |= (uint8_t)((1<<PRTIM3)|(1<<PRTIM4)|(1<<PRTIM5)|(1<<PRTIM5)|(1<<PRUSART1)|(1<<PRUSART2)|(
 590:/usr/lib/avr/include/avr/power.h **** }while(0)
 591:/usr/lib/avr/include/avr/power.h **** 
 592:/usr/lib/avr/include/avr/power.h **** 
 593:/usr/lib/avr/include/avr/power.h **** #elif defined(__AVR_ATmega128RFA1__)
 594:/usr/lib/avr/include/avr/power.h **** 
 595:/usr/lib/avr/include/avr/power.h **** #define power_adc_enable()      (PRR0 &= (uint8_t)~(1 << PRADC))
 596:/usr/lib/avr/include/avr/power.h **** #define power_adc_disable()     (PRR0 |= (uint8_t)(1 << PRADC))
 597:/usr/lib/avr/include/avr/power.h **** 
 598:/usr/lib/avr/include/avr/power.h **** #define power_spi_enable()      (PRR0 &= (uint8_t)~(1 << PRSPI))
 599:/usr/lib/avr/include/avr/power.h **** #define power_spi_disable()     (PRR0 |= (uint8_t)(1 << PRSPI))
 600:/usr/lib/avr/include/avr/power.h **** 
 601:/usr/lib/avr/include/avr/power.h **** #define power_twi_enable()      (PRR0 &= (uint8_t)~(1 << PRTWI))
 602:/usr/lib/avr/include/avr/power.h **** #define power_twi_disable()     (PRR0 |= (uint8_t)(1 << PRTWI))
 603:/usr/lib/avr/include/avr/power.h **** 
 604:/usr/lib/avr/include/avr/power.h **** #define power_timer0_enable()   (PRR0 &= (uint8_t)~(1 << PRTIM0))
 605:/usr/lib/avr/include/avr/power.h **** #define power_timer0_disable()  (PRR0 |= (uint8_t)(1 << PRTIM0))
 606:/usr/lib/avr/include/avr/power.h **** 
 607:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()   (PRR0 &= (uint8_t)~(1 << PRTIM1))
 608:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()  (PRR0 |= (uint8_t)(1 << PRTIM1))
 609:/usr/lib/avr/include/avr/power.h **** 
 610:/usr/lib/avr/include/avr/power.h **** #define power_timer2_enable()   (PRR0 &= (uint8_t)~(1 << PRTIM2))
 611:/usr/lib/avr/include/avr/power.h **** #define power_timer2_disable()  (PRR0 |= (uint8_t)(1 << PRTIM2))
 612:/usr/lib/avr/include/avr/power.h **** 
 613:/usr/lib/avr/include/avr/power.h **** #define power_timer3_enable()   (PRR1 &= (uint8_t)~(1 << PRTIM3))
 614:/usr/lib/avr/include/avr/power.h **** #define power_timer3_disable()  (PRR1 |= (uint8_t)(1 << PRTIM3))
 615:/usr/lib/avr/include/avr/power.h **** 
 616:/usr/lib/avr/include/avr/power.h **** #define power_timer4_enable()   (PRR1 &= (uint8_t)~(1 << PRTIM4))
 617:/usr/lib/avr/include/avr/power.h **** #define power_timer4_disable()  (PRR1 |= (uint8_t)(1 << PRTIM4))
 618:/usr/lib/avr/include/avr/power.h **** 
 619:/usr/lib/avr/include/avr/power.h **** #define power_timer5_enable()   (PRR1 &= (uint8_t)~(1 << PRTIM5))
 620:/usr/lib/avr/include/avr/power.h **** #define power_timer5_disable()  (PRR1 |= (uint8_t)(1 << PRTIM5))
 621:/usr/lib/avr/include/avr/power.h **** 
 622:/usr/lib/avr/include/avr/power.h **** #define power_usart0_enable()   (PRR0 &= (uint8_t)~(1 << PRUSART0))
 623:/usr/lib/avr/include/avr/power.h **** #define power_usart0_disable()  (PRR0 |= (uint8_t)(1 << PRUSART0))
 624:/usr/lib/avr/include/avr/power.h **** 
 625:/usr/lib/avr/include/avr/power.h **** #define power_usart1_enable()   (PRR1 &= (uint8_t)~(1 << PRUSART1))
 626:/usr/lib/avr/include/avr/power.h **** #define power_usart1_disable()  (PRR1 |= (uint8_t)(1 << PRUSART1))
 627:/usr/lib/avr/include/avr/power.h **** 
 628:/usr/lib/avr/include/avr/power.h **** #define power_all_enable() \
 629:/usr/lib/avr/include/avr/power.h **** do{ \
 630:/usr/lib/avr/include/avr/power.h ****     PRR0 &= (uint8_t)~((1<<PRADC)|(1<<PRSPI)|(1<<PRTWI)|(1<<PRTIM0)|(1<<PRTIM1)|(1<<PRTIM2)|(1<<PRU
 631:/usr/lib/avr/include/avr/power.h ****     PRR1 &= (uint8_t)~((1<<PRTIM3)|(1<<PRTIM4)|(1<<PRTIM5)|(1<<PRTIM5)|(1<<PRUSART1)); \
 632:/usr/lib/avr/include/avr/power.h **** }while(0)
 633:/usr/lib/avr/include/avr/power.h **** 
 634:/usr/lib/avr/include/avr/power.h **** #define power_all_disable() \
 635:/usr/lib/avr/include/avr/power.h **** do{ \
 636:/usr/lib/avr/include/avr/power.h ****     PRR0 |= (uint8_t)((1<<PRADC)|(1<<PRSPI)|(1<<PRTWI)|(1<<PRTIM0)|(1<<PRTIM1)|(1<<PRTIM2)|(1<<PRUS
 637:/usr/lib/avr/include/avr/power.h ****     PRR1 |= (uint8_t)((1<<PRTIM3)|(1<<PRTIM4)|(1<<PRTIM5)|(1<<PRTIM5)|(1<<PRUSART1)); \
 638:/usr/lib/avr/include/avr/power.h **** }while(0)
 639:/usr/lib/avr/include/avr/power.h **** 
 640:/usr/lib/avr/include/avr/power.h **** 
 641:/usr/lib/avr/include/avr/power.h **** #elif defined(__AVR_AT90USB646__) \
 642:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB647__) \
 643:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB1286__) \
 644:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB1287__)
 645:/usr/lib/avr/include/avr/power.h **** 
 646:/usr/lib/avr/include/avr/power.h **** #define power_adc_enable()      (PRR0 &= (uint8_t)~(1 << PRADC))
 647:/usr/lib/avr/include/avr/power.h **** #define power_adc_disable()     (PRR0 |= (uint8_t)(1 << PRADC))
 648:/usr/lib/avr/include/avr/power.h **** 
 649:/usr/lib/avr/include/avr/power.h **** #define power_spi_enable()      (PRR0 &= (uint8_t)~(1 << PRSPI))
 650:/usr/lib/avr/include/avr/power.h **** #define power_spi_disable()     (PRR0 |= (uint8_t)(1 << PRSPI))
 651:/usr/lib/avr/include/avr/power.h **** 
 652:/usr/lib/avr/include/avr/power.h **** #define power_twi_enable()      (PRR0 &= (uint8_t)~(1 << PRTWI))
 653:/usr/lib/avr/include/avr/power.h **** #define power_twi_disable()     (PRR0 |= (uint8_t)(1 << PRTWI))
 654:/usr/lib/avr/include/avr/power.h **** 
 655:/usr/lib/avr/include/avr/power.h **** #define power_timer0_enable()   (PRR0 &= (uint8_t)~(1 << PRTIM0))
 656:/usr/lib/avr/include/avr/power.h **** #define power_timer0_disable()  (PRR0 |= (uint8_t)(1 << PRTIM0))
 657:/usr/lib/avr/include/avr/power.h **** 
 658:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()   (PRR0 &= (uint8_t)~(1 << PRTIM1))
 659:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()  (PRR0 |= (uint8_t)(1 << PRTIM1))
 660:/usr/lib/avr/include/avr/power.h **** 
 661:/usr/lib/avr/include/avr/power.h **** #define power_timer2_enable()   (PRR0 &= (uint8_t)~(1 << PRTIM2))
 662:/usr/lib/avr/include/avr/power.h **** #define power_timer2_disable()  (PRR0 |= (uint8_t)(1 << PRTIM2))
 663:/usr/lib/avr/include/avr/power.h **** 
 664:/usr/lib/avr/include/avr/power.h **** #define power_timer3_enable()   (PRR1 &= (uint8_t)~(1 << PRTIM3))
 665:/usr/lib/avr/include/avr/power.h **** #define power_timer3_disable()  (PRR1 |= (uint8_t)(1 << PRTIM3))
 666:/usr/lib/avr/include/avr/power.h **** 
 667:/usr/lib/avr/include/avr/power.h **** #define power_usart1_enable()   (PRR1 &= (uint8_t)~(1 << PRUSART1))
 668:/usr/lib/avr/include/avr/power.h **** #define power_usart1_disable()  (PRR1 |= (uint8_t)(1 << PRUSART1))
 669:/usr/lib/avr/include/avr/power.h **** 
 670:/usr/lib/avr/include/avr/power.h **** #define power_usb_enable()      (PRR1 &= (uint8_t)~(1 << PRUSB))
 671:/usr/lib/avr/include/avr/power.h **** #define power_usb_disable()     (PRR1 |= (uint8_t)(1 << PRUSB))
 672:/usr/lib/avr/include/avr/power.h **** 
 673:/usr/lib/avr/include/avr/power.h **** #define power_all_enable() \
 674:/usr/lib/avr/include/avr/power.h **** do{ \
 675:/usr/lib/avr/include/avr/power.h ****     PRR0 &= (uint8_t)~((1<<PRADC)|(1<<PRSPI)|(1<<PRTWI)|(1<<PRTIM0)|(1<<PRTIM1)|(1<<PRTIM2)); \
 676:/usr/lib/avr/include/avr/power.h ****     PRR1 &= (uint8_t)~((1<<PRTIM3)|(1<<PRUSART1)|(1<<PRUSB)); \
 677:/usr/lib/avr/include/avr/power.h **** }while(0)
 678:/usr/lib/avr/include/avr/power.h **** 
 679:/usr/lib/avr/include/avr/power.h **** #define power_all_disable() \
 680:/usr/lib/avr/include/avr/power.h **** do{ \
 681:/usr/lib/avr/include/avr/power.h ****     PRR0 |= (uint8_t)((1<<PRADC)|(1<<PRSPI)|(1<<PRTWI)|(1<<PRTIM0)|(1<<PRTIM1)|(1<<PRTIM2)); \
 682:/usr/lib/avr/include/avr/power.h ****     PRR1 |= (uint8_t)((1<<PRTIM3)|(1<<PRUSART1)|(1<<PRUSB)); \
 683:/usr/lib/avr/include/avr/power.h **** }while(0)
 684:/usr/lib/avr/include/avr/power.h **** 
 685:/usr/lib/avr/include/avr/power.h **** 
 686:/usr/lib/avr/include/avr/power.h **** #elif defined(__AVR_ATmega32U4__) \
 687:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega16U4__)
 688:/usr/lib/avr/include/avr/power.h **** 
 689:/usr/lib/avr/include/avr/power.h **** 
 690:/usr/lib/avr/include/avr/power.h **** #define power_adc_enable()      (PRR0 &= (uint8_t)~(1 << PRADC))
 691:/usr/lib/avr/include/avr/power.h **** #define power_adc_disable()     (PRR0 |= (uint8_t)(1 << PRADC))
 692:/usr/lib/avr/include/avr/power.h **** 
 693:/usr/lib/avr/include/avr/power.h **** #define power_usart0_enable()   (PRR0 &= (uint8_t)~(1 << PRUSART0))
 694:/usr/lib/avr/include/avr/power.h **** #define power_usart0_disable()  (PRR0 |= (uint8_t)(1 << PRUSART0))
 695:/usr/lib/avr/include/avr/power.h **** 
 696:/usr/lib/avr/include/avr/power.h **** #define power_spi_enable()      (PRR0 &= (uint8_t)~(1 << PRSPI))
 697:/usr/lib/avr/include/avr/power.h **** #define power_spi_disable()     (PRR0 |= (uint8_t)(1 << PRSPI))
 698:/usr/lib/avr/include/avr/power.h **** 
 699:/usr/lib/avr/include/avr/power.h **** #define power_twi_enable()      (PRR0 &= (uint8_t)~(1 << PRTWI))
 700:/usr/lib/avr/include/avr/power.h **** #define power_twi_disable()     (PRR0 |= (uint8_t)(1 << PRTWI))
 701:/usr/lib/avr/include/avr/power.h **** 
 702:/usr/lib/avr/include/avr/power.h **** #define power_timer0_enable()   (PRR0 &= (uint8_t)~(1 << PRTIM0))
 703:/usr/lib/avr/include/avr/power.h **** #define power_timer0_disable()  (PRR0 |= (uint8_t)(1 << PRTIM0))
 704:/usr/lib/avr/include/avr/power.h **** 
 705:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()   (PRR0 &= (uint8_t)~(1 << PRTIM1))
 706:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()  (PRR0 |= (uint8_t)(1 << PRTIM1))
 707:/usr/lib/avr/include/avr/power.h **** 
 708:/usr/lib/avr/include/avr/power.h **** #define power_timer2_enable()   (PRR0 &= (uint8_t)~(1 << PRTIM2))
 709:/usr/lib/avr/include/avr/power.h **** #define power_timer2_disable()  (PRR0 |= (uint8_t)(1 << PRTIM2))
 710:/usr/lib/avr/include/avr/power.h **** 
 711:/usr/lib/avr/include/avr/power.h **** #define power_timer3_enable()   (PRR1 &= (uint8_t)~(1 << PRTIM3))
 712:/usr/lib/avr/include/avr/power.h **** #define power_timer3_disable()  (PRR1 |= (uint8_t)(1 << PRTIM3))
 713:/usr/lib/avr/include/avr/power.h **** 
 714:/usr/lib/avr/include/avr/power.h **** #define power_usart1_enable()   (PRR1 &= (uint8_t)~(1 << PRUSART1))
 715:/usr/lib/avr/include/avr/power.h **** #define power_usart1_disable()  (PRR1 |= (uint8_t)(1 << PRUSART1))
 716:/usr/lib/avr/include/avr/power.h **** 
 717:/usr/lib/avr/include/avr/power.h **** #define power_usb_enable()      (PRR1 &= (uint8_t)~(1 << PRUSB))
 718:/usr/lib/avr/include/avr/power.h **** #define power_usb_disable()     (PRR1 |= (uint8_t)(1 << PRUSB))
 719:/usr/lib/avr/include/avr/power.h **** 
 720:/usr/lib/avr/include/avr/power.h **** #define power_all_enable() \
 721:/usr/lib/avr/include/avr/power.h **** do{ \
 722:/usr/lib/avr/include/avr/power.h ****     PRR0 &= (uint8_t)~((1<<PRADC)|(1<<PRUSART0)|(1<<PRSPI)|(1<<PRTWI)|(1<<PRTIM0)|(1<<PRTIM1)|(1<<P
 723:/usr/lib/avr/include/avr/power.h ****     PRR1 &= (uint8_t)~((1<<PRTIM3)|(1<<PRUSART1)|(1<<PRUSB)); \
 724:/usr/lib/avr/include/avr/power.h **** }while(0)
 725:/usr/lib/avr/include/avr/power.h **** 
 726:/usr/lib/avr/include/avr/power.h **** #define power_all_disable() \
 727:/usr/lib/avr/include/avr/power.h **** do{ \
 728:/usr/lib/avr/include/avr/power.h ****     PRR0 |= (uint8_t)((1<<PRADC)|(1<<PRUSART0)|(1<<PRSPI)|(1<<PRTWI)|(1<<PRTIM0)|(1<<PRTIM1)|(1<<PR
 729:/usr/lib/avr/include/avr/power.h ****     PRR1 |= (uint8_t)((1<<PRTIM3)|(1<<PRUSART1)|(1<<PRUSB)); \
 730:/usr/lib/avr/include/avr/power.h **** }while(0)
 731:/usr/lib/avr/include/avr/power.h **** 
 732:/usr/lib/avr/include/avr/power.h **** 
 733:/usr/lib/avr/include/avr/power.h **** #elif defined(__AVR_ATmega32U6__)
 734:/usr/lib/avr/include/avr/power.h **** 
 735:/usr/lib/avr/include/avr/power.h **** 
 736:/usr/lib/avr/include/avr/power.h **** #define power_adc_enable()      (PRR0 &= (uint8_t)~(1 << PRADC))
 737:/usr/lib/avr/include/avr/power.h **** #define power_adc_disable()     (PRR0 |= (uint8_t)(1 << PRADC))
 738:/usr/lib/avr/include/avr/power.h **** 
 739:/usr/lib/avr/include/avr/power.h **** #define power_spi_enable()      (PRR0 &= (uint8_t)~(1 << PRSPI))
 740:/usr/lib/avr/include/avr/power.h **** #define power_spi_disable()     (PRR0 |= (uint8_t)(1 << PRSPI))
 741:/usr/lib/avr/include/avr/power.h **** 
 742:/usr/lib/avr/include/avr/power.h **** #define power_twi_enable()      (PRR0 &= (uint8_t)~(1 << PRTWI))
 743:/usr/lib/avr/include/avr/power.h **** #define power_twi_disable()     (PRR0 |= (uint8_t)(1 << PRTWI))
 744:/usr/lib/avr/include/avr/power.h **** 
 745:/usr/lib/avr/include/avr/power.h **** #define power_timer0_enable()   (PRR0 &= (uint8_t)~(1 << PRTIM0))
 746:/usr/lib/avr/include/avr/power.h **** #define power_timer0_disable()  (PRR0 |= (uint8_t)(1 << PRTIM0))
 747:/usr/lib/avr/include/avr/power.h **** 
 748:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()   (PRR0 &= (uint8_t)~(1 << PRTIM1))
 749:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()  (PRR0 |= (uint8_t)(1 << PRTIM1))
 750:/usr/lib/avr/include/avr/power.h **** 
 751:/usr/lib/avr/include/avr/power.h **** #define power_timer2_enable()   (PRR0 &= (uint8_t)~(1 << PRTIM2))
 752:/usr/lib/avr/include/avr/power.h **** #define power_timer2_disable()  (PRR0 |= (uint8_t)(1 << PRTIM2))
 753:/usr/lib/avr/include/avr/power.h **** 
 754:/usr/lib/avr/include/avr/power.h **** #define power_timer3_enable()   (PRR1 &= (uint8_t)~(1 << PRTIM3))
 755:/usr/lib/avr/include/avr/power.h **** #define power_timer3_disable()  (PRR1 |= (uint8_t)(1 << PRTIM3))
 756:/usr/lib/avr/include/avr/power.h **** 
 757:/usr/lib/avr/include/avr/power.h **** #define power_usart1_enable()   (PRR1 &= (uint8_t)~(1 << PRUSART1))
 758:/usr/lib/avr/include/avr/power.h **** #define power_usart1_disable()  (PRR1 |= (uint8_t)(1 << PRUSART1))
 759:/usr/lib/avr/include/avr/power.h **** 
 760:/usr/lib/avr/include/avr/power.h **** #define power_usb_enable()      (PRR1 &= (uint8_t)~(1 << PRUSB))
 761:/usr/lib/avr/include/avr/power.h **** #define power_usb_disable()     (PRR1 |= (uint8_t)(1 << PRUSB))
 762:/usr/lib/avr/include/avr/power.h **** 
 763:/usr/lib/avr/include/avr/power.h **** #define power_all_enable() \
 764:/usr/lib/avr/include/avr/power.h **** do{ \
 765:/usr/lib/avr/include/avr/power.h ****     PRR0 &= (uint8_t)~((1<<PRADC)|(1<<PRSPI)|(1<<PRTWI)|(1<<PRTIM0)|(1<<PRTIM1)|(1<<PRTIM2)); \
 766:/usr/lib/avr/include/avr/power.h ****     PRR1 &= (uint8_t)~((1<<PRTIM3)|(1<<PRUSART1)|(1<<PRUSB)); \
 767:/usr/lib/avr/include/avr/power.h **** }while(0)
 768:/usr/lib/avr/include/avr/power.h **** 
 769:/usr/lib/avr/include/avr/power.h **** #define power_all_disable() \
 770:/usr/lib/avr/include/avr/power.h **** do{ \
 771:/usr/lib/avr/include/avr/power.h ****     PRR0 |= (uint8_t)((1<<PRADC)|(1<<PRSPI)|(1<<PRTWI)|(1<<PRTIM0)|(1<<PRTIM1)|(1<<PRTIM2)); \
 772:/usr/lib/avr/include/avr/power.h ****     PRR1 |= (uint8_t)((1<<PRTIM3)|(1<<PRUSART1)|(1<<PRUSB)); \
 773:/usr/lib/avr/include/avr/power.h **** }while(0)
 774:/usr/lib/avr/include/avr/power.h **** 
 775:/usr/lib/avr/include/avr/power.h **** 
 776:/usr/lib/avr/include/avr/power.h **** #elif defined(__AVR_AT90PWM1__)
 777:/usr/lib/avr/include/avr/power.h **** 
 778:/usr/lib/avr/include/avr/power.h **** #define power_adc_enable()      (PRR &= (uint8_t)~(1 << PRADC))
 779:/usr/lib/avr/include/avr/power.h **** #define power_adc_disable()     (PRR |= (uint8_t)(1 << PRADC))
 780:/usr/lib/avr/include/avr/power.h **** 
 781:/usr/lib/avr/include/avr/power.h **** #define power_spi_enable()      (PRR &= (uint8_t)~(1 << PRSPI))
 782:/usr/lib/avr/include/avr/power.h **** #define power_spi_disable()     (PRR |= (uint8_t)(1 << PRSPI))
 783:/usr/lib/avr/include/avr/power.h **** 
 784:/usr/lib/avr/include/avr/power.h **** #define power_timer0_enable()   (PRR &= (uint8_t)~(1 << PRTIM0))
 785:/usr/lib/avr/include/avr/power.h **** #define power_timer0_disable()  (PRR |= (uint8_t)(1 << PRTIM0))
 786:/usr/lib/avr/include/avr/power.h **** 
 787:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()   (PRR &= (uint8_t)~(1 << PRTIM1))
 788:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()  (PRR |= (uint8_t)(1 << PRTIM1))
 789:/usr/lib/avr/include/avr/power.h **** 
 790:/usr/lib/avr/include/avr/power.h **** /* Power Stage Controller 0 */
 791:/usr/lib/avr/include/avr/power.h **** #define power_psc0_enable()     (PRR &= (uint8_t)~(1 << PRPSC0))
 792:/usr/lib/avr/include/avr/power.h **** #define power_psc0_disable()    (PRR |= (uint8_t)(1 << PRPSC0))
 793:/usr/lib/avr/include/avr/power.h **** 
 794:/usr/lib/avr/include/avr/power.h **** /* Power Stage Controller 1 */
 795:/usr/lib/avr/include/avr/power.h **** #define power_psc1_enable()     (PRR &= (uint8_t)~(1 << PRPSC1))
 796:/usr/lib/avr/include/avr/power.h **** #define power_psc1_disable()    (PRR |= (uint8_t)(1 << PRPSC1))
 797:/usr/lib/avr/include/avr/power.h **** 
 798:/usr/lib/avr/include/avr/power.h **** /* Power Stage Controller 2 */
 799:/usr/lib/avr/include/avr/power.h **** #define power_psc2_enable()     (PRR &= (uint8_t)~(1 << PRPSC2))
 800:/usr/lib/avr/include/avr/power.h **** #define power_psc2_disable()    (PRR |= (uint8_t)(1 << PRPSC2))
 801:/usr/lib/avr/include/avr/power.h **** 
 802:/usr/lib/avr/include/avr/power.h **** #define power_all_enable()      (PRR &= (uint8_t)~((1<<PRADC)|(1<<PRSPI)|(1<<PRTIM0)|(1<<PRTIM1)|(1
 803:/usr/lib/avr/include/avr/power.h **** #define power_all_disable()     (PRR |= (uint8_t)((1<<PRADC)|(1<<PRSPI)|(1<<PRTIM0)|(1<<PRTIM1)|(1<
 804:/usr/lib/avr/include/avr/power.h **** 
 805:/usr/lib/avr/include/avr/power.h **** 
 806:/usr/lib/avr/include/avr/power.h **** #elif defined(__AVR_AT90PWM2__) \
 807:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM2B__) \
 808:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM3__) \
 809:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM3B__) \
 810:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM216__) \
 811:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM316__)
 812:/usr/lib/avr/include/avr/power.h **** 
 813:/usr/lib/avr/include/avr/power.h **** #define power_adc_enable()      (PRR &= (uint8_t)~(1 << PRADC))
 814:/usr/lib/avr/include/avr/power.h **** #define power_adc_disable()     (PRR |= (uint8_t)(1 << PRADC))
 815:/usr/lib/avr/include/avr/power.h **** 
 816:/usr/lib/avr/include/avr/power.h **** #define power_spi_enable()      (PRR &= (uint8_t)~(1 << PRSPI))
 817:/usr/lib/avr/include/avr/power.h **** #define power_spi_disable()     (PRR |= (uint8_t)(1 << PRSPI))
 818:/usr/lib/avr/include/avr/power.h **** 
 819:/usr/lib/avr/include/avr/power.h **** #define power_usart_enable()    (PRR &= (uint8_t)~(1 << PRUSART))
 820:/usr/lib/avr/include/avr/power.h **** #define power_usart_disable()   (PRR |= (uint8_t)(1 << PRUSART))
 821:/usr/lib/avr/include/avr/power.h **** 
 822:/usr/lib/avr/include/avr/power.h **** #define power_timer0_enable()   (PRR &= (uint8_t)~(1 << PRTIM0))
 823:/usr/lib/avr/include/avr/power.h **** #define power_timer0_disable()  (PRR |= (uint8_t)(1 << PRTIM0))
 824:/usr/lib/avr/include/avr/power.h **** 
 825:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()   (PRR &= (uint8_t)~(1 << PRTIM1))
 826:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()  (PRR |= (uint8_t)(1 << PRTIM1))
 827:/usr/lib/avr/include/avr/power.h **** 
 828:/usr/lib/avr/include/avr/power.h **** /* Power Stage Controller 0 */
 829:/usr/lib/avr/include/avr/power.h **** #define power_psc0_enable()     (PRR &= (uint8_t)~(1 << PRPSC0))
 830:/usr/lib/avr/include/avr/power.h **** #define power_psc0_disable()    (PRR |= (uint8_t)(1 << PRPSC0))
 831:/usr/lib/avr/include/avr/power.h **** 
 832:/usr/lib/avr/include/avr/power.h **** /* Power Stage Controller 1 */
 833:/usr/lib/avr/include/avr/power.h **** #define power_psc1_enable()     (PRR &= (uint8_t)~(1 << PRPSC1))
 834:/usr/lib/avr/include/avr/power.h **** #define power_psc1_disable()    (PRR |= (uint8_t)(1 << PRPSC1))
 835:/usr/lib/avr/include/avr/power.h **** 
 836:/usr/lib/avr/include/avr/power.h **** /* Power Stage Controller 2 */
 837:/usr/lib/avr/include/avr/power.h **** #define power_psc2_enable()     (PRR &= (uint8_t)~(1 << PRPSC2))
 838:/usr/lib/avr/include/avr/power.h **** #define power_psc2_disable()    (PRR |= (uint8_t)(1 << PRPSC2))
 839:/usr/lib/avr/include/avr/power.h **** 
 840:/usr/lib/avr/include/avr/power.h **** #define power_all_enable()      (PRR &= (uint8_t)~((1<<PRADC)|(1<<PRSPI)|(1<<PRUSART)|(1<<PRTIM0)|(
 841:/usr/lib/avr/include/avr/power.h **** #define power_all_disable()     (PRR |= (uint8_t)((1<<PRADC)|(1<<PRSPI)|(1<<PRUSART)|(1<<PRTIM0)|(1
 842:/usr/lib/avr/include/avr/power.h **** 
 843:/usr/lib/avr/include/avr/power.h **** 
 844:/usr/lib/avr/include/avr/power.h **** #elif defined(__AVR_AT90PWM81__)
 845:/usr/lib/avr/include/avr/power.h **** 
 846:/usr/lib/avr/include/avr/power.h **** #define power_adc_enable()      (PRR &= (uint8_t)~(1 << PRADC))
 847:/usr/lib/avr/include/avr/power.h **** #define power_adc_disable()     (PRR |= (uint8_t)(1 << PRADC))
 848:/usr/lib/avr/include/avr/power.h **** 
 849:/usr/lib/avr/include/avr/power.h **** #define power_spi_enable()      (PRR &= (uint8_t)~(1 << PRSPI))
 850:/usr/lib/avr/include/avr/power.h **** #define power_spi_disable()     (PRR |= (uint8_t)(1 << PRSPI))
 851:/usr/lib/avr/include/avr/power.h **** 
 852:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()   (PRR &= (uint8_t)~(1 << PRTIM1))
 853:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()  (PRR |= (uint8_t)(1 << PRTIM1))
 854:/usr/lib/avr/include/avr/power.h **** 
 855:/usr/lib/avr/include/avr/power.h **** /* Reduced Power Stage Controller */
 856:/usr/lib/avr/include/avr/power.h **** #define power_pscr_enable()     (PRR &= (uint8_t)~(1 << PRPSCR))
 857:/usr/lib/avr/include/avr/power.h **** #define power_pscr_disable()    (PRR |= (uint8_t)(1 << PRPSCR))
 858:/usr/lib/avr/include/avr/power.h **** 
 859:/usr/lib/avr/include/avr/power.h **** /* Power Stage Controller 2 */
 860:/usr/lib/avr/include/avr/power.h **** #define power_psc2_enable()     (PRR &= (uint8_t)~(1 << PRPSC2))
 861:/usr/lib/avr/include/avr/power.h **** #define power_psc2_disable()    (PRR |= (uint8_t)(1 << PRPSC2))
 862:/usr/lib/avr/include/avr/power.h **** 
 863:/usr/lib/avr/include/avr/power.h **** #define power_all_enable()      (PRR &= (uint8_t)~((1<<PRADC)|(1<<PRSPI)|(1<<PRTIM1)|(1<<PRPSCR)|(1
 864:/usr/lib/avr/include/avr/power.h **** #define power_all_disable()     (PRR |= (uint8_t)((1<<PRADC)|(1<<PRSPI)|(1<<PRTIM1)|(1<<PRPSCR)|(1<
 865:/usr/lib/avr/include/avr/power.h **** 
 866:/usr/lib/avr/include/avr/power.h **** 
 867:/usr/lib/avr/include/avr/power.h **** #elif defined(__AVR_ATmega165__) \
 868:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega165A__) \
 869:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega165P__) \
 870:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega325__) \
 871:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega325A__) \
 872:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3250__) \
 873:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3250A__) \
 874:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega645__) \
 875:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega645A__) \
 876:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega645P__) \
 877:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6450__) \
 878:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6450A__) \
 879:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6450P__)
 880:/usr/lib/avr/include/avr/power.h **** 
 881:/usr/lib/avr/include/avr/power.h **** #define power_adc_enable()      (PRR &= (uint8_t)~(1 << PRADC))
 882:/usr/lib/avr/include/avr/power.h **** #define power_adc_disable()     (PRR |= (uint8_t)(1 << PRADC))
 883:/usr/lib/avr/include/avr/power.h **** 
 884:/usr/lib/avr/include/avr/power.h **** #define power_spi_enable()      (PRR &= (uint8_t)~(1 << PRSPI))
 885:/usr/lib/avr/include/avr/power.h **** #define power_spi_disable()     (PRR |= (uint8_t)(1 << PRSPI))
 886:/usr/lib/avr/include/avr/power.h **** 
 887:/usr/lib/avr/include/avr/power.h **** #define power_usart0_enable()   (PRR &= (uint8_t)~(1 << PRUSART0))
 888:/usr/lib/avr/include/avr/power.h **** #define power_usart0_disable()  (PRR |= (uint8_t)(1 << PRUSART0))
 889:/usr/lib/avr/include/avr/power.h **** 
 890:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()   (PRR &= (uint8_t)~(1 << PRTIM1))
 891:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()  (PRR |= (uint8_t)(1 << PRTIM1))
 892:/usr/lib/avr/include/avr/power.h **** 
 893:/usr/lib/avr/include/avr/power.h **** #define power_all_enable()      (PRR &= (uint8_t)~((1<<PRADC)|(1<<PRSPI)|(1<<PRUSART0)|(1<<PRTIM1))
 894:/usr/lib/avr/include/avr/power.h **** #define power_all_disable()     (PRR |= (uint8_t)((1<<PRADC)|(1<<PRSPI)|(1<<PRUSART0)|(1<<PRTIM1)))
 895:/usr/lib/avr/include/avr/power.h **** 
 896:/usr/lib/avr/include/avr/power.h **** 
 897:/usr/lib/avr/include/avr/power.h **** #elif defined(__AVR_ATmega169__) \
 898:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega169A__) \
 899:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega169P__) \
 900:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega169PA__) \
 901:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega329__) \
 902:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega329A__) \
 903:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega329P__) \
 904:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega329PA__) \
 905:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3290__) \
 906:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3290A__) \
 907:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3290P__) \
 908:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega649__) \
 909:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega649A__) \
 910:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega649P__) \
 911:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6490__) \
 912:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6490A__) \
 913:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6490P__)
 914:/usr/lib/avr/include/avr/power.h **** 
 915:/usr/lib/avr/include/avr/power.h **** #define power_adc_enable()      (PRR &= (uint8_t)~(1 << PRADC))
 916:/usr/lib/avr/include/avr/power.h **** #define power_adc_disable()     (PRR |= (uint8_t)(1 << PRADC))
 917:/usr/lib/avr/include/avr/power.h **** 
 918:/usr/lib/avr/include/avr/power.h **** #define power_spi_enable()      (PRR &= (uint8_t)~(1 << PRSPI))
 919:/usr/lib/avr/include/avr/power.h **** #define power_spi_disable()     (PRR |= (uint8_t)(1 << PRSPI))
 920:/usr/lib/avr/include/avr/power.h **** 
 921:/usr/lib/avr/include/avr/power.h **** #define power_usart0_enable()   (PRR &= (uint8_t)~(1 << PRUSART0))
 922:/usr/lib/avr/include/avr/power.h **** #define power_usart0_disable()  (PRR |= (uint8_t)(1 << PRUSART0))
 923:/usr/lib/avr/include/avr/power.h **** 
 924:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()   (PRR &= (uint8_t)~(1 << PRTIM1))
 925:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()  (PRR |= (uint8_t)(1 << PRTIM1))
 926:/usr/lib/avr/include/avr/power.h **** 
 927:/usr/lib/avr/include/avr/power.h **** #define power_lcd_enable()      (PRR &= (uint8_t)~(1 << PRLCD))
 928:/usr/lib/avr/include/avr/power.h **** #define power_lcd_disable()     (PRR |= (uint8_t)(1 << PRLCD))
 929:/usr/lib/avr/include/avr/power.h **** 
 930:/usr/lib/avr/include/avr/power.h **** #define power_all_enable()      (PRR &= (uint8_t)~((1<<PRADC)|(1<<PRSPI)|(1<<PRUSART0)|(1<<PRTIM1)|
 931:/usr/lib/avr/include/avr/power.h **** #define power_all_disable()     (PRR |= (uint8_t)((1<<PRADC)|(1<<PRSPI)|(1<<PRUSART0)|(1<<PRTIM1)|(
 932:/usr/lib/avr/include/avr/power.h **** 
 933:/usr/lib/avr/include/avr/power.h **** 
 934:/usr/lib/avr/include/avr/power.h **** #elif defined(__AVR_ATmega164A__) \
 935:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega164P__) \
 936:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega324A__) \
 937:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega324P__) \
 938:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega324PA__) \
 939:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644P__) \
 940:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644A__) \
 941:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644PA__)
 942:/usr/lib/avr/include/avr/power.h **** 
 943:/usr/lib/avr/include/avr/power.h **** #define power_adc_enable()      (PRR0 &= (uint8_t)~(1 << PRADC))
 944:/usr/lib/avr/include/avr/power.h **** #define power_adc_disable()     (PRR0 |= (uint8_t)(1 << PRADC))
 945:/usr/lib/avr/include/avr/power.h **** 
 946:/usr/lib/avr/include/avr/power.h **** #define power_spi_enable()      (PRR0 &= (uint8_t)~(1 << PRSPI))
 947:/usr/lib/avr/include/avr/power.h **** #define power_spi_disable()     (PRR0 |= (uint8_t)(1 << PRSPI))
 948:/usr/lib/avr/include/avr/power.h **** 
 949:/usr/lib/avr/include/avr/power.h **** #define power_usart0_enable()   (PRR0 &= (uint8_t)~(1 << PRUSART0))
 950:/usr/lib/avr/include/avr/power.h **** #define power_usart0_disable()  (PRR0 |= (uint8_t)(1 << PRUSART0))
 951:/usr/lib/avr/include/avr/power.h **** 
 952:/usr/lib/avr/include/avr/power.h **** #define power_usart1_enable()   (PRR0 &= (uint8_t)~(1 << PRUSART1))
 953:/usr/lib/avr/include/avr/power.h **** #define power_usart1_disable()  (PRR0 |= (uint8_t)(1 << PRUSART1))
 954:/usr/lib/avr/include/avr/power.h **** 
 955:/usr/lib/avr/include/avr/power.h **** #define power_timer0_enable()   (PRR0 &= (uint8_t)~(1 << PRTIM0))
 956:/usr/lib/avr/include/avr/power.h **** #define power_timer0_disable()  (PRR0 |= (uint8_t)(1 << PRTIM0))
 957:/usr/lib/avr/include/avr/power.h **** 
 958:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()   (PRR0 &= (uint8_t)~(1 << PRTIM1))
 959:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()  (PRR0 |= (uint8_t)(1 << PRTIM1))
 960:/usr/lib/avr/include/avr/power.h **** 
 961:/usr/lib/avr/include/avr/power.h **** #define power_timer2_enable()   (PRR0 &= (uint8_t)~(1 << PRTIM2))
 962:/usr/lib/avr/include/avr/power.h **** #define power_timer2_disable()  (PRR0 |= (uint8_t)(1 << PRTIM2))
 963:/usr/lib/avr/include/avr/power.h **** 
 964:/usr/lib/avr/include/avr/power.h **** #define power_twi_enable()      (PRR0 &= (uint8_t)~(1 << PRTWI))
 965:/usr/lib/avr/include/avr/power.h **** #define power_twi_disable()     (PRR0 |= (uint8_t)(1 << PRTWI))
 966:/usr/lib/avr/include/avr/power.h **** 
 967:/usr/lib/avr/include/avr/power.h **** #define power_all_enable()      (PRR0 &= (uint8_t)~((1<<PRADC)|(1<<PRSPI)|(1<<PRUSART0)|(1<<PRUSART
 968:/usr/lib/avr/include/avr/power.h **** #define power_all_disable()     (PRR0 |= (uint8_t)((1<<PRADC)|(1<<PRSPI)|(1<<PRUSART0)|(1<<PRUSART1
 969:/usr/lib/avr/include/avr/power.h **** 
 970:/usr/lib/avr/include/avr/power.h **** 
 971:/usr/lib/avr/include/avr/power.h **** #elif defined(__AVR_ATmega644__)
 972:/usr/lib/avr/include/avr/power.h **** 
 973:/usr/lib/avr/include/avr/power.h **** #define power_adc_enable()      (PRR0 &= (uint8_t)~(1 << PRADC))
 974:/usr/lib/avr/include/avr/power.h **** #define power_adc_disable()     (PRR0 |= (uint8_t)(1 << PRADC))
 975:/usr/lib/avr/include/avr/power.h **** 
 976:/usr/lib/avr/include/avr/power.h **** #define power_spi_enable()      (PRR0 &= (uint8_t)~(1 << PRSPI))
 977:/usr/lib/avr/include/avr/power.h **** #define power_spi_disable()     (PRR0 |= (uint8_t)(1 << PRSPI))
 978:/usr/lib/avr/include/avr/power.h **** 
 979:/usr/lib/avr/include/avr/power.h **** #define power_usart0_enable()   (PRR0 &= (uint8_t)~(1 << PRUSART0))
 980:/usr/lib/avr/include/avr/power.h **** #define power_usart0_disable()  (PRR0 |= (uint8_t)(1 << PRUSART0))
 981:/usr/lib/avr/include/avr/power.h **** 
 982:/usr/lib/avr/include/avr/power.h **** #define power_timer0_enable()   (PRR0 &= (uint8_t)~(1 << PRTIM0))
 983:/usr/lib/avr/include/avr/power.h **** #define power_timer0_disable()  (PRR0 |= (uint8_t)(1 << PRTIM0))
 984:/usr/lib/avr/include/avr/power.h **** 
 985:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()   (PRR0 &= (uint8_t)~(1 << PRTIM1))
 986:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()  (PRR0 |= (uint8_t)(1 << PRTIM1))
 987:/usr/lib/avr/include/avr/power.h **** 
 988:/usr/lib/avr/include/avr/power.h **** #define power_timer2_enable()   (PRR0 &= (uint8_t)~(1 << PRTIM2))
 989:/usr/lib/avr/include/avr/power.h **** #define power_timer2_disable()  (PRR0 |= (uint8_t)(1 << PRTIM2))
 990:/usr/lib/avr/include/avr/power.h **** 
 991:/usr/lib/avr/include/avr/power.h **** #define power_twi_enable()      (PRR0 &= (uint8_t)~(1 << PRTWI))
 992:/usr/lib/avr/include/avr/power.h **** #define power_twi_disable()     (PRR0 |= (uint8_t)(1 << PRTWI))
 993:/usr/lib/avr/include/avr/power.h **** 
 994:/usr/lib/avr/include/avr/power.h **** #define power_all_enable()      (PRR0 &= (uint8_t)~((1<<PRADC)|(1<<PRSPI)|(1<<PRUSART0)|(1<<PRTIM0)
 995:/usr/lib/avr/include/avr/power.h **** #define power_all_disable()     (PRR0 |= (uint8_t)((1<<PRADC)|(1<<PRSPI)|(1<<PRUSART0)|(1<<PRTIM0)|
 996:/usr/lib/avr/include/avr/power.h **** 
 997:/usr/lib/avr/include/avr/power.h **** 
 998:/usr/lib/avr/include/avr/power.h **** #elif defined(__AVR_ATmega406__)
 999:/usr/lib/avr/include/avr/power.h **** 
1000:/usr/lib/avr/include/avr/power.h **** #define power_twi_enable()      (PRR0 &= (uint8_t)~(1 << PRTWI))
1001:/usr/lib/avr/include/avr/power.h **** #define power_twi_disable()     (PRR0 |= (uint8_t)(1 << PRTWI))
1002:/usr/lib/avr/include/avr/power.h **** 
1003:/usr/lib/avr/include/avr/power.h **** #define power_timer0_enable()   (PRR0 &= (uint8_t)~(1 << PRTIM0))
1004:/usr/lib/avr/include/avr/power.h **** #define power_timer0_disable()  (PRR0 |= (uint8_t)(1 << PRTIM0))
1005:/usr/lib/avr/include/avr/power.h **** 
1006:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()   (PRR0 &= (uint8_t)~(1 << PRTIM1))
1007:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()  (PRR0 |= (uint8_t)(1 << PRTIM1))
1008:/usr/lib/avr/include/avr/power.h **** 
1009:/usr/lib/avr/include/avr/power.h **** /* Voltage ADC */
1010:/usr/lib/avr/include/avr/power.h **** #define power_vadc_enable()     (PRR0 &= (uint8_t)~(1 << PRVADC))
1011:/usr/lib/avr/include/avr/power.h **** #define power_vadc_disable()    (PRR0 |= (uint8_t)(1 << PRVADC))
1012:/usr/lib/avr/include/avr/power.h **** 
1013:/usr/lib/avr/include/avr/power.h **** #define power_all_enable()      (PRR0 &= (uint8_t)~((1<<PRTWI)|(1<<PRTIM0)|(1<<PRTIM1)|(1<<PRVADC))
1014:/usr/lib/avr/include/avr/power.h **** #define power_all_disable()     (PRR0 |= (uint8_t)((1<<PRTWI)|(1<<PRTIM0)|(1<<PRTIM1)|(1<<PRVADC)))
1015:/usr/lib/avr/include/avr/power.h **** 
1016:/usr/lib/avr/include/avr/power.h **** 
1017:/usr/lib/avr/include/avr/power.h **** #elif defined(__AVR_ATmega48__) \
1018:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega48A__) \
1019:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega48P__) \
1020:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega88__) \
1021:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega88A__) \
1022:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega88P__) \
1023:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega88PA__) \
1024:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega168__) \
1025:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega168A__) \
1026:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega168P__) \
1027:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega328__) \
1028:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega328P__) \
1029:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny48__) \
1030:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny88__)
1031:/usr/lib/avr/include/avr/power.h **** 
1032:/usr/lib/avr/include/avr/power.h **** #define power_adc_enable()      (PRR &= (uint8_t)~(1 << PRADC))
1033:/usr/lib/avr/include/avr/power.h **** #define power_adc_disable()     (PRR |= (uint8_t)(1 << PRADC))
1034:/usr/lib/avr/include/avr/power.h **** 
1035:/usr/lib/avr/include/avr/power.h **** #define power_spi_enable()      (PRR &= (uint8_t)~(1 << PRSPI))
1036:/usr/lib/avr/include/avr/power.h **** #define power_spi_disable()     (PRR |= (uint8_t)(1 << PRSPI))
1037:/usr/lib/avr/include/avr/power.h **** 
1038:/usr/lib/avr/include/avr/power.h **** #define power_usart0_enable()   (PRR &= (uint8_t)~(1 << PRUSART0))
1039:/usr/lib/avr/include/avr/power.h **** #define power_usart0_disable()  (PRR |= (uint8_t)(1 << PRUSART0))
1040:/usr/lib/avr/include/avr/power.h **** 
1041:/usr/lib/avr/include/avr/power.h **** #define power_timer0_enable()   (PRR &= (uint8_t)~(1 << PRTIM0))
1042:/usr/lib/avr/include/avr/power.h **** #define power_timer0_disable()  (PRR |= (uint8_t)(1 << PRTIM0))
1043:/usr/lib/avr/include/avr/power.h **** 
1044:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()   (PRR &= (uint8_t)~(1 << PRTIM1))
1045:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()  (PRR |= (uint8_t)(1 << PRTIM1))
1046:/usr/lib/avr/include/avr/power.h **** 
1047:/usr/lib/avr/include/avr/power.h **** #define power_timer2_enable()   (PRR &= (uint8_t)~(1 << PRTIM2))
1048:/usr/lib/avr/include/avr/power.h **** #define power_timer2_disable()  (PRR |= (uint8_t)(1 << PRTIM2))
1049:/usr/lib/avr/include/avr/power.h **** 
1050:/usr/lib/avr/include/avr/power.h **** #define power_twi_enable()      (PRR &= (uint8_t)~(1 << PRTWI))
1051:/usr/lib/avr/include/avr/power.h **** #define power_twi_disable()     (PRR |= (uint8_t)(1 << PRTWI))
1052:/usr/lib/avr/include/avr/power.h **** 
1053:/usr/lib/avr/include/avr/power.h **** #define power_all_enable()      (PRR &= (uint8_t)~((1<<PRADC)|(1<<PRSPI)|(1<<PRUSART0)|(1<<PRTIM0)|
1054:/usr/lib/avr/include/avr/power.h **** #define power_all_disable()     (PRR |= (uint8_t)((1<<PRADC)|(1<<PRSPI)|(1<<PRUSART0)|(1<<PRTIM0)|(
1055:/usr/lib/avr/include/avr/power.h **** 
1056:/usr/lib/avr/include/avr/power.h **** 
1057:/usr/lib/avr/include/avr/power.h **** #elif defined(__AVR_ATtiny24__) \
1058:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny24A__) \
1059:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny44__) \
1060:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny44A__) \
1061:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny84__) \
1062:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny84A__) \
1063:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny25__) \
1064:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny45__) \
1065:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny85__) \
1066:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny261__) \
1067:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny261A__) \
1068:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny461__) \
1069:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny461A__) \
1070:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny861__) \
1071:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny861A__) \
1072:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny43U__)
1073:/usr/lib/avr/include/avr/power.h **** 
1074:/usr/lib/avr/include/avr/power.h **** #define power_adc_enable()      (PRR &= (uint8_t)~(1 << PRADC))
1075:/usr/lib/avr/include/avr/power.h **** #define power_adc_disable()     (PRR |= (uint8_t)(1 << PRADC))
1076:/usr/lib/avr/include/avr/power.h **** 
1077:/usr/lib/avr/include/avr/power.h **** #define power_timer0_enable()   (PRR &= (uint8_t)~(1 << PRTIM0))
1078:/usr/lib/avr/include/avr/power.h **** #define power_timer0_disable()  (PRR |= (uint8_t)(1 << PRTIM0))
1079:/usr/lib/avr/include/avr/power.h **** 
1080:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()   (PRR &= (uint8_t)~(1 << PRTIM1))
1081:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()  (PRR |= (uint8_t)(1 << PRTIM1))
1082:/usr/lib/avr/include/avr/power.h **** 
1083:/usr/lib/avr/include/avr/power.h **** /* Universal Serial Interface */
1084:/usr/lib/avr/include/avr/power.h **** #define power_usi_enable()      (PRR &= (uint8_t)~(1 << PRUSI))
1085:/usr/lib/avr/include/avr/power.h **** #define power_usi_disable()     (PRR |= (uint8_t)(1 << PRUSI))
1086:/usr/lib/avr/include/avr/power.h **** 
1087:/usr/lib/avr/include/avr/power.h **** #define power_all_enable()      (PRR &= (uint8_t)~((1<<PRADC)|(1<<PRTIM0)|(1<<PRTIM1)|(1<<PRUSI)))
1088:/usr/lib/avr/include/avr/power.h **** #define power_all_disable()     (PRR |= (uint8_t)((1<<PRADC)|(1<<PRTIM0)|(1<<PRTIM1)|(1<<PRUSI)))
1089:/usr/lib/avr/include/avr/power.h **** 
1090:/usr/lib/avr/include/avr/power.h **** 
1091:/usr/lib/avr/include/avr/power.h **** #elif defined(__AVR_ATmega1284P__)
1092:/usr/lib/avr/include/avr/power.h **** 
1093:/usr/lib/avr/include/avr/power.h **** 
1094:/usr/lib/avr/include/avr/power.h **** #define power_adc_enable()      (PRR0 &= (uint8_t)~(1 << PRADC))
1095:/usr/lib/avr/include/avr/power.h **** #define power_adc_disable()     (PRR0 |= (uint8_t)(1 << PRADC))
1096:/usr/lib/avr/include/avr/power.h **** 
1097:/usr/lib/avr/include/avr/power.h **** #define power_spi_enable()      (PRR0 &= (uint8_t)~(1 << PRSPI))
1098:/usr/lib/avr/include/avr/power.h **** #define power_spi_disable()     (PRR0 |= (uint8_t)(1 << PRSPI))
1099:/usr/lib/avr/include/avr/power.h **** 
1100:/usr/lib/avr/include/avr/power.h **** #define power_twi_enable()      (PRR0 &= (uint8_t)~(1 << PRTWI))
1101:/usr/lib/avr/include/avr/power.h **** #define power_twi_disable()     (PRR0 |= (uint8_t)(1 << PRTWI))
1102:/usr/lib/avr/include/avr/power.h **** 
1103:/usr/lib/avr/include/avr/power.h **** #define power_timer0_enable()   (PRR0 &= (uint8_t)~(1 << PRTIM0))
1104:/usr/lib/avr/include/avr/power.h **** #define power_timer0_disable()  (PRR0 |= (uint8_t)(1 << PRTIM0))
1105:/usr/lib/avr/include/avr/power.h **** 
1106:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()   (PRR0 &= (uint8_t)~(1 << PRTIM1))
1107:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()  (PRR0 |= (uint8_t)(1 << PRTIM1))
1108:/usr/lib/avr/include/avr/power.h **** 
1109:/usr/lib/avr/include/avr/power.h **** #define power_timer2_enable()   (PRR0 &= (uint8_t)~(1 << PRTIM2))
1110:/usr/lib/avr/include/avr/power.h **** #define power_timer2_disable()  (PRR0 |= (uint8_t)(1 << PRTIM2))
1111:/usr/lib/avr/include/avr/power.h **** 
1112:/usr/lib/avr/include/avr/power.h **** #define power_timer3_enable()   (PRR1 &= (uint8_t)~(1 << PRTIM3))
1113:/usr/lib/avr/include/avr/power.h **** #define power_timer3_disable()  (PRR1 |= (uint8_t)(1 << PRTIM3))
1114:/usr/lib/avr/include/avr/power.h **** 
1115:/usr/lib/avr/include/avr/power.h **** #define power_usart0_enable()   (PRR0 &= (uint8_t)~(1 << PRUSART0))
1116:/usr/lib/avr/include/avr/power.h **** #define power_usart0_disable()  (PRR0 |= (uint8_t)(1 << PRUSART0))
1117:/usr/lib/avr/include/avr/power.h **** 
1118:/usr/lib/avr/include/avr/power.h **** #define power_usart1_enable()   (PRR0 &= (uint8_t)~(1 << PRUSART1))
1119:/usr/lib/avr/include/avr/power.h **** #define power_usart1_disable()  (PRR0 |= (uint8_t)(1 << PRUSART1))
1120:/usr/lib/avr/include/avr/power.h **** 
1121:/usr/lib/avr/include/avr/power.h **** #define power_all_enable() \
1122:/usr/lib/avr/include/avr/power.h **** do{ \
1123:/usr/lib/avr/include/avr/power.h ****     PRR0 &= (uint8_t)~((1<<PRADC)|(1<<PRSPI)|(1<<PRTWI)|(1<<PRTIM0)|(1<<PRTIM1)|(1<<PRTIM2)|(1<<PRU
1124:/usr/lib/avr/include/avr/power.h ****     PRR1 &= (uint8_t)~(1<<PRTIM3); \
1125:/usr/lib/avr/include/avr/power.h **** }while(0)
1126:/usr/lib/avr/include/avr/power.h **** 
1127:/usr/lib/avr/include/avr/power.h **** #define power_all_disable() \
1128:/usr/lib/avr/include/avr/power.h **** do{ \
1129:/usr/lib/avr/include/avr/power.h ****     PRR0 |= (uint8_t)((1<<PRADC)|(1<<PRSPI)|(1<<PRTWI)|(1<<PRTIM0)|(1<<PRTIM1)|(1<<PRTIM2)|(1<<PRUS
1130:/usr/lib/avr/include/avr/power.h ****     PRR1 |= (uint8_t)(1<<PRTIM3); \
1131:/usr/lib/avr/include/avr/power.h **** }while(0)
1132:/usr/lib/avr/include/avr/power.h **** 
1133:/usr/lib/avr/include/avr/power.h **** 
1134:/usr/lib/avr/include/avr/power.h **** #elif defined(__AVR_ATmega32HVB__) \
1135:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32HVBREVB__) \
1136:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega16HVB__) \
1137:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega16HVBREVB__)
1138:/usr/lib/avr/include/avr/power.h **** 
1139:/usr/lib/avr/include/avr/power.h **** 
1140:/usr/lib/avr/include/avr/power.h **** #define power_twi_enable()      (PRR0 &= (uint8_t)~(1 << PRTWI))
1141:/usr/lib/avr/include/avr/power.h **** #define power_twi_disable()     (PRR0 |= (uint8_t)(1 << PRTWI))
1142:/usr/lib/avr/include/avr/power.h **** 
1143:/usr/lib/avr/include/avr/power.h **** #define power_timer0_enable()   (PRR0 &= (uint8_t)~(1 << PRTIM0))
1144:/usr/lib/avr/include/avr/power.h **** #define power_timer0_disable()  (PRR0 |= (uint8_t)(1 << PRTIM0))
1145:/usr/lib/avr/include/avr/power.h **** 
1146:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()   (PRR0 &= (uint8_t)~(1 << PRTIM1))
1147:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()  (PRR0 |= (uint8_t)(1 << PRTIM1))
1148:/usr/lib/avr/include/avr/power.h **** 
1149:/usr/lib/avr/include/avr/power.h **** /* Voltage ADC */
1150:/usr/lib/avr/include/avr/power.h **** #define power_vadc_enable()     (PRR0 &= (uint8_t)~(1 << PRVADC))
1151:/usr/lib/avr/include/avr/power.h **** #define power_vadc_disable()    (PRR0 |= (uint8_t)(1 << PRVADC))
1152:/usr/lib/avr/include/avr/power.h **** 
1153:/usr/lib/avr/include/avr/power.h **** #define power_spi_enable()      (PRR0 &= (uint8_t)~(1 << PRSPI))
1154:/usr/lib/avr/include/avr/power.h **** #define power_spi_disable()     (PRR0 |= (uint8_t)(1 << PRSPI))
1155:/usr/lib/avr/include/avr/power.h **** 
1156:/usr/lib/avr/include/avr/power.h **** #define power_vrm_enable()      (PRR0 &= (uint8_t)~(1 << PRVRM))
1157:/usr/lib/avr/include/avr/power.h **** #define power_vrm_disable()     (PRR0 |= (uint8_t)(1 << PRVRM))
1158:/usr/lib/avr/include/avr/power.h **** 
1159:/usr/lib/avr/include/avr/power.h **** #define power_all_enable()      (PRR0 &= (uint8_t)~((1<<PRTWI)|(1<<PRTIM0)|(1<<PRTIM1)|(1<<PRVADC)|
1160:/usr/lib/avr/include/avr/power.h **** #define power_all_disable()     (PRR0 |= (uint8_t)((1<<PRTWI)|(1<<PRTIM0)|(1<<PRTIM1)|(1<<PRVADC)|(
1161:/usr/lib/avr/include/avr/power.h **** 
1162:/usr/lib/avr/include/avr/power.h **** 
1163:/usr/lib/avr/include/avr/power.h **** #elif defined(__AVR_ATmega16M1__) \
1164:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32C1__) \
1165:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32M1__) \
1166:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega64C1__) \
1167:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega64M1__)
1168:/usr/lib/avr/include/avr/power.h **** 
1169:/usr/lib/avr/include/avr/power.h **** #define power_adc_enable()      (PRR &= (uint8_t)~(1 << PRADC))
1170:/usr/lib/avr/include/avr/power.h **** #define power_adc_disable()     (PRR |= (uint8_t)(1 << PRADC))
1171:/usr/lib/avr/include/avr/power.h **** 
1172:/usr/lib/avr/include/avr/power.h **** #define power_lin_enable()      (PRR &= (uint8_t)~(1 << PRLIN))
1173:/usr/lib/avr/include/avr/power.h **** #define power_lin_disable()     (PRR |= (uint8_t)(1 << PRLIN))
1174:/usr/lib/avr/include/avr/power.h **** 
1175:/usr/lib/avr/include/avr/power.h **** #define power_spi_enable()      (PRR &= (uint8_t)~(1 << PRSPI))
1176:/usr/lib/avr/include/avr/power.h **** #define power_spi_disable()     (PRR |= (uint8_t)(1 << PRSPI))
1177:/usr/lib/avr/include/avr/power.h **** 
1178:/usr/lib/avr/include/avr/power.h **** #define power_timer0_enable()   (PRR &= (uint8_t)~(1 << PRTIM0))
1179:/usr/lib/avr/include/avr/power.h **** #define power_timer0_disable()  (PRR |= (uint8_t)(1 << PRTIM0))
1180:/usr/lib/avr/include/avr/power.h **** 
1181:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()   (PRR &= (uint8_t)~(1 << PRTIM1))
1182:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()  (PRR |= (uint8_t)(1 << PRTIM1))
1183:/usr/lib/avr/include/avr/power.h **** 
1184:/usr/lib/avr/include/avr/power.h **** #define power_psc_enable()      (PRR &= (uint8_t)~(1 << PRPSC))
1185:/usr/lib/avr/include/avr/power.h **** #define power_psc_disable()     (PRR |= (uint8_t)(1 << PRPSC))
1186:/usr/lib/avr/include/avr/power.h **** 
1187:/usr/lib/avr/include/avr/power.h **** #define power_can_enable()      (PRR &= (uint8_t)~(1 << PRCAN))
1188:/usr/lib/avr/include/avr/power.h **** #define power_can_disable()     (PRR |= (uint8_t)(1 << PRCAN))
1189:/usr/lib/avr/include/avr/power.h **** 
1190:/usr/lib/avr/include/avr/power.h **** #define power_all_enable()      (PRR &= (uint8_t)~((1<<PRADC)|(1<<PRLIN)|(1<<PRSPI)|(1<<PRTIM0)|(1<
1191:/usr/lib/avr/include/avr/power.h **** #define power_all_disable()     (PRR |= (uint8_t)((1<<PRADC)|(1<<PRLIN)|(1<<PRSPI)|(1<<PRTIM0)|(1<<
1192:/usr/lib/avr/include/avr/power.h **** 
1193:/usr/lib/avr/include/avr/power.h **** 
1194:/usr/lib/avr/include/avr/power.h **** #elif defined(__AVR_ATtiny167__) \
1195:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny87__)
1196:/usr/lib/avr/include/avr/power.h **** 
1197:/usr/lib/avr/include/avr/power.h **** 
1198:/usr/lib/avr/include/avr/power.h **** #define power_adc_enable()      (PRR &= (uint8_t)~(1 << PRADC))
1199:/usr/lib/avr/include/avr/power.h **** #define power_adc_disable()     (PRR |= (uint8_t)(1 << PRADC))
1200:/usr/lib/avr/include/avr/power.h **** 
1201:/usr/lib/avr/include/avr/power.h **** #define power_usi_enable()      (PRR &= (uint8_t)~(1 << PRUSI))
1202:/usr/lib/avr/include/avr/power.h **** #define power_usi_disable()     (PRR |= (uint8_t)(1 << PRUSI))
1203:/usr/lib/avr/include/avr/power.h **** 
1204:/usr/lib/avr/include/avr/power.h **** #define power_timer0_enable()   (PRR &= (uint8_t)~(1 << PRTIM0))
1205:/usr/lib/avr/include/avr/power.h **** #define power_timer0_disable()  (PRR |= (uint8_t)(1 << PRTIM0))
1206:/usr/lib/avr/include/avr/power.h **** 
1207:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()   (PRR &= (uint8_t)~(1 << PRTIM1))
1208:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()  (PRR |= (uint8_t)(1 << PRTIM1))
1209:/usr/lib/avr/include/avr/power.h **** 
1210:/usr/lib/avr/include/avr/power.h **** #define power_spi_enable()      (PRR &= (uint8_t)~(1 << PRSPI))
1211:/usr/lib/avr/include/avr/power.h **** #define power_spi_disable()     (PRR |= (uint8_t)(1 << PRSPI))
1212:/usr/lib/avr/include/avr/power.h **** 
1213:/usr/lib/avr/include/avr/power.h **** #define power_lin_enable()      (PRR &= (uint8_t)~(1 << PRLIN))
1214:/usr/lib/avr/include/avr/power.h **** #define power_lin_disable()     (PRR |= (uint8_t)(1 << PRLIN))
1215:/usr/lib/avr/include/avr/power.h **** 
1216:/usr/lib/avr/include/avr/power.h **** #define power_all_enable()      (PRR &= (uint8_t)~((1<<PRADC)|(1<<PRUSI)|(1<<PRTIM0)|(1<<PRTIM1)|(1
1217:/usr/lib/avr/include/avr/power.h **** #define power_all_disable()     (PRR |= (uint8_t)((1<<PRADC)|(1<<PRUSI)|(1<<PRTIM0)|(1<<PRTIM1)|(1<
1218:/usr/lib/avr/include/avr/power.h **** 
1219:/usr/lib/avr/include/avr/power.h **** 
1220:/usr/lib/avr/include/avr/power.h **** #elif defined(__AVR_AT90USB82__) \
1221:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB162__) \
1222:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega8U2__) \
1223:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega16U2__) \
1224:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32U2__)
1225:/usr/lib/avr/include/avr/power.h **** 
1226:/usr/lib/avr/include/avr/power.h **** #define power_spi_enable()      (PRR0 &= (uint8_t)~(1 << PRSPI))
1227:/usr/lib/avr/include/avr/power.h **** #define power_spi_disable()     (PRR0 |= (uint8_t)(1 << PRSPI))
1228:/usr/lib/avr/include/avr/power.h **** 
1229:/usr/lib/avr/include/avr/power.h **** #define power_timer0_enable()   (PRR0 &= (uint8_t)~(1 << PRTIM0))
1230:/usr/lib/avr/include/avr/power.h **** #define power_timer0_disable()  (PRR0 |= (uint8_t)(1 << PRTIM0))
1231:/usr/lib/avr/include/avr/power.h **** 
1232:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()   (PRR0 &= (uint8_t)~(1 << PRTIM1))
1233:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()  (PRR0 |= (uint8_t)(1 << PRTIM1))
1234:/usr/lib/avr/include/avr/power.h **** 
1235:/usr/lib/avr/include/avr/power.h **** #define power_usb_enable()      (PRR1 &= (uint8_t)~(1 << PRUSB))
1236:/usr/lib/avr/include/avr/power.h **** #define power_usb_disable()     (PRR1 |= (uint8_t)(1 << PRUSB))
1237:/usr/lib/avr/include/avr/power.h **** 
1238:/usr/lib/avr/include/avr/power.h **** #define power_usart1_enable()   (PRR1 &= (uint8_t)~(1 << PRUSART1))
1239:/usr/lib/avr/include/avr/power.h **** #define power_usart1_disable()  (PRR1 |= (uint8_t)(1 << PRUSART1))
1240:/usr/lib/avr/include/avr/power.h **** 
1241:/usr/lib/avr/include/avr/power.h **** #define power_all_enable() \
1242:/usr/lib/avr/include/avr/power.h **** do{ \
1243:/usr/lib/avr/include/avr/power.h ****     PRR0 &= (uint8_t)~((1<<PRSPI)|(1<<PRTIM0)|(1<<PRTIM1)); \
1244:/usr/lib/avr/include/avr/power.h ****     PRR1 &= (uint8_t)~((1<<PRUSB)|(1<<PRUSART1)); \
1245:/usr/lib/avr/include/avr/power.h **** }while(0)
1246:/usr/lib/avr/include/avr/power.h **** 
1247:/usr/lib/avr/include/avr/power.h **** #define power_all_disable() \
1248:/usr/lib/avr/include/avr/power.h **** do{ \
1249:/usr/lib/avr/include/avr/power.h ****     PRR0 |= (uint8_t)((1<<PRSPI)|(1<<PRTIM0)|(1<<PRTIM1)); \
1250:/usr/lib/avr/include/avr/power.h ****     PRR1 |= (uint8_t)((1<<PRUSB)|(1<<PRUSART1)); \
1251:/usr/lib/avr/include/avr/power.h **** }while(0)
1252:/usr/lib/avr/include/avr/power.h **** 
1253:/usr/lib/avr/include/avr/power.h **** 
1254:/usr/lib/avr/include/avr/power.h **** #elif defined(__AVR_AT90SCR100__)
1255:/usr/lib/avr/include/avr/power.h **** 
1256:/usr/lib/avr/include/avr/power.h **** #define power_usart0_enable()   (PRR0 &= (uint8_t)~(1 << PRUSART0))
1257:/usr/lib/avr/include/avr/power.h **** #define power_usart0_disable()  (PRR0 |= (uint8_t)(1 << PRUSART0))
1258:/usr/lib/avr/include/avr/power.h **** 
1259:/usr/lib/avr/include/avr/power.h **** #define power_spi_enable()      (PRR0 &= (uint8_t)~(1 << PRSPI))
1260:/usr/lib/avr/include/avr/power.h **** #define power_spi_disable()     (PRR0 |= (uint8_t)(1 << PRSPI))
1261:/usr/lib/avr/include/avr/power.h **** 
1262:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()   (PRR0 &= (uint8_t)~(1 << PRTIM1))
1263:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()  (PRR0 |= (uint8_t)(1 << PRTIM1))
1264:/usr/lib/avr/include/avr/power.h **** 
1265:/usr/lib/avr/include/avr/power.h **** #define power_timer0_enable()   (PRR0 &= (uint8_t)~(1 << PRTIM0))
1266:/usr/lib/avr/include/avr/power.h **** #define power_timer0_disable()  (PRR0 |= (uint8_t)(1 << PRTIM0))
1267:/usr/lib/avr/include/avr/power.h **** 
1268:/usr/lib/avr/include/avr/power.h **** #define power_timer2_enable()   (PRR0 &= (uint8_t)~(1 << PRTIM2))
1269:/usr/lib/avr/include/avr/power.h **** #define power_timer2_disable()  (PRR0 |= (uint8_t)(1 << PRTIM2))
1270:/usr/lib/avr/include/avr/power.h **** 
1271:/usr/lib/avr/include/avr/power.h **** #define power_twi_enable()      (PRR0 &= (uint8_t)~(1 << PRTWI))
1272:/usr/lib/avr/include/avr/power.h **** #define power_twi_disable()     (PRR0 |= (uint8_t)(1 << PRTWI))
1273:/usr/lib/avr/include/avr/power.h **** 
1274:/usr/lib/avr/include/avr/power.h **** #define power_usbh_enable()     (PRR1 &= (uint8_t)~(1 << PRUSBH))
1275:/usr/lib/avr/include/avr/power.h **** #define power_usbh_disable()    (PRR1 |= (uint8_t)(1 << PRUSBH))
1276:/usr/lib/avr/include/avr/power.h **** 
1277:/usr/lib/avr/include/avr/power.h **** #define power_usb_enable()      (PRR1 &= (uint8_t)~(1 << PRUSB))
1278:/usr/lib/avr/include/avr/power.h **** #define power_usb_disable()     (PRR1 |= (uint8_t)(1 << PRUSB))
1279:/usr/lib/avr/include/avr/power.h **** 
1280:/usr/lib/avr/include/avr/power.h **** #define power_hsspi_enable()    (PRR1 &= (uint8_t)~(1 << PRHSSPI))
1281:/usr/lib/avr/include/avr/power.h **** #define power_hsspi_disable()   (PRR1 |= (uint8_t)(1 << PRHSSPI))
1282:/usr/lib/avr/include/avr/power.h **** 
1283:/usr/lib/avr/include/avr/power.h **** #define power_sci_enable()      (PRR1 &= (uint8_t)~(1 << PRSCI))
1284:/usr/lib/avr/include/avr/power.h **** #define power_sci_disable()     (PRR1 |= (uint8_t)(1 << PRSCI))
1285:/usr/lib/avr/include/avr/power.h **** 
1286:/usr/lib/avr/include/avr/power.h **** #define power_aes_enable()      (PRR1 &= (uint8_t)~(1 << PRAES))
1287:/usr/lib/avr/include/avr/power.h **** #define power_aes_disable()     (PRR1 |= (uint8_t)(1 << PRAES))
1288:/usr/lib/avr/include/avr/power.h **** 
1289:/usr/lib/avr/include/avr/power.h **** #define power_kb_enable()       (PRR1 &= (uint8_t)~(1 << PRKB))
1290:/usr/lib/avr/include/avr/power.h **** #define power_kb_disable()      (PRR1 |= (uint8_t)(1 << PRKB))
1291:/usr/lib/avr/include/avr/power.h **** 
1292:/usr/lib/avr/include/avr/power.h **** #define power_all_enable() \
1293:/usr/lib/avr/include/avr/power.h **** do{ \
1294:/usr/lib/avr/include/avr/power.h ****     PRR0 &= (uint8_t)~((1<<PRUSART0)|(1<<PRSPI)|(1<<PRTIM1)|(1<<PRTIM0)|(1<<PRTIM2)|(1<<PRTWI)); \
1295:/usr/lib/avr/include/avr/power.h ****     PRR1 &= (uint8_t)~((1<<PRUSBH)|(1<<PRUSB)|(1<<PRHSSPI)|(1<<PRSCI)|(1<<PRAES)|(1<<PRKB)); \
1296:/usr/lib/avr/include/avr/power.h **** }while(0)
1297:/usr/lib/avr/include/avr/power.h **** 
1298:/usr/lib/avr/include/avr/power.h **** #define power_all_disable() \
1299:/usr/lib/avr/include/avr/power.h **** do{ \
1300:/usr/lib/avr/include/avr/power.h ****     PRR0 |= (uint8_t)((1<<PRUSART0)|(1<<PRSPI)|(1<<PRTIM1)|(1<<PRTIM0)|(1<<PRTIM2)|(1<<PRTWI)); \
1301:/usr/lib/avr/include/avr/power.h ****     PRR1 |= (uint8_t)((1<<PRUSBH)|(1<<PRUSB)|(1<<PRHSSPI)|(1<<PRSCI)|(1<<PRAES)|(1<<PRKB)); \
1302:/usr/lib/avr/include/avr/power.h **** }while(0)
1303:/usr/lib/avr/include/avr/power.h **** 
1304:/usr/lib/avr/include/avr/power.h **** 
1305:/usr/lib/avr/include/avr/power.h **** #elif defined(__AVR_ATtiny4__) \
1306:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny5__) \
1307:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny9__) \
1308:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny10__) \
1309:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny13A__) \
1310:/usr/lib/avr/include/avr/power.h **** 
1311:/usr/lib/avr/include/avr/power.h **** #define power_adc_enable()   (PRR &= (uint8_t)~(1 << PRADC))
1312:/usr/lib/avr/include/avr/power.h **** #define power_adc_disable()  (PRR |= (uint8_t)(1 << PRADC))
1313:/usr/lib/avr/include/avr/power.h **** 
1314:/usr/lib/avr/include/avr/power.h **** #define power_timer0_enable()   (PRR &= (uint8_t)~(1 << PRTIM0))
1315:/usr/lib/avr/include/avr/power.h **** #define power_timer0_disable()  (PRR |= (uint8_t)(1 << PRTIM0))
1316:/usr/lib/avr/include/avr/power.h **** 
1317:/usr/lib/avr/include/avr/power.h **** #define power_all_enable()      (PRR &= (uint8_t)~((1<<PRADC)|(1<<PRTIM0)))
1318:/usr/lib/avr/include/avr/power.h **** #define power_all_disable()     (PRR |= (uint8_t)((1<<PRADC)|(1<<PRTIM0)))
1319:/usr/lib/avr/include/avr/power.h **** 
1320:/usr/lib/avr/include/avr/power.h **** 
1321:/usr/lib/avr/include/avr/power.h **** #elif defined(__AVR_ATtiny20__) \
1322:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny40__)
1323:/usr/lib/avr/include/avr/power.h **** 
1324:/usr/lib/avr/include/avr/power.h **** #define power_adc_enable()   (PRR &= (uint8_t)~(1 << PRADC))
1325:/usr/lib/avr/include/avr/power.h **** #define power_adc_disable()  (PRR |= (uint8_t)(1 << PRADC))
1326:/usr/lib/avr/include/avr/power.h **** 
1327:/usr/lib/avr/include/avr/power.h **** #define power_timer0_enable()   (PRR &= (uint8_t)~(1 << PRTIM0))
1328:/usr/lib/avr/include/avr/power.h **** #define power_timer0_disable()  (PRR |= (uint8_t)(1 << PRTIM0))
1329:/usr/lib/avr/include/avr/power.h **** 
1330:/usr/lib/avr/include/avr/power.h **** #define power_timer1_enable()   (PRR &= (uint8_t)~(1 << PRTIM1))
1331:/usr/lib/avr/include/avr/power.h **** #define power_timer1_disable()  (PRR |= (uint8_t)(1 << PRTIM1))
1332:/usr/lib/avr/include/avr/power.h **** 
1333:/usr/lib/avr/include/avr/power.h **** #define power_spi_enable()   (PRR &= (uint8_t)~(1 << PRSPI))
1334:/usr/lib/avr/include/avr/power.h **** #define power_spi_disable()  (PRR |= (uint8_t)(1 << PRSPI))
1335:/usr/lib/avr/include/avr/power.h **** 
1336:/usr/lib/avr/include/avr/power.h **** #define power_twi_enable()   (PRR &= (uint8_t)~(1 << PRTWI))
1337:/usr/lib/avr/include/avr/power.h **** #define power_twi_disable()  (PRR |= (uint8_t)(1 << PRTWI))
1338:/usr/lib/avr/include/avr/power.h **** 
1339:/usr/lib/avr/include/avr/power.h **** #define power_all_enable()      (PRR &= (uint8_t)~((1<<PRADC)|(1<<PRTIM0)|(1<<PRTIM1)|(1<<PRSPI)|(1
1340:/usr/lib/avr/include/avr/power.h **** #define power_all_disable()     (PRR |= (uint8_t)((1<<PRADC)|(1<<PRTIM0)|(1<<PRTIM1)|(1<<PRSPI)|(1<
1341:/usr/lib/avr/include/avr/power.h **** 
1342:/usr/lib/avr/include/avr/power.h **** #endif
1343:/usr/lib/avr/include/avr/power.h **** 
1344:/usr/lib/avr/include/avr/power.h **** 
1345:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_AT90CAN32__) \
1346:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90CAN64__) \
1347:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90CAN128__) \
1348:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM1__) \
1349:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM2__) \
1350:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM2B__) \
1351:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM3__) \
1352:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM3B__) \
1353:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM216__) \
1354:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90PWM316__) \
1355:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90SCR100__) \
1356:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB646__) \
1357:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB647__) \
1358:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB82__) \
1359:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB1286__) \
1360:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB1287__) \
1361:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_AT90USB162__) \
1362:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega1280__) \
1363:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega1281__) \
1364:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega128RFA1__) \
1365:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega1284P__) \
1366:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega162__) \
1367:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega164A__) \
1368:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega164P__) \
1369:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega165__) \
1370:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega165A__) \
1371:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega165P__) \
1372:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega168__) \
1373:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega168P__) \
1374:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega169__) \
1375:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega169A__) \
1376:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega169P__) \
1377:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega169PA__) \
1378:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega16U4__) \
1379:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega2560__) \
1380:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega2561__) \
1381:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega324A__) \
1382:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega324P__) \
1383:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega325__) \
1384:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega325A__) \
1385:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3250__) \
1386:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3250A__) \
1387:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega328__) \
1388:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega328P__) \
1389:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega329__) \
1390:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega329A__) \
1391:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega329P__) \
1392:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega329PA__) \
1393:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3290__) \
1394:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega3290A__) \
1395:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32C1__) \
1396:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32HVB__) \
1397:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32HVBREVB__) \
1398:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega16HVB__) \
1399:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega16HVBREVB__) \
1400:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32M1__) \
1401:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32U2__) \
1402:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32U4__) \
1403:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32U6__) \
1404:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega48__) \
1405:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega48P__) \
1406:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega640__) \
1407:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega649P__) \
1408:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644__) \
1409:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644A__) \
1410:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644P__) \
1411:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega644PA__) \
1412:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega645__) \
1413:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega645A__) \
1414:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega645P__) \
1415:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6450__) \
1416:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6450A__) \
1417:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6450P__) \
1418:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega649__) \
1419:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega649A__) \
1420:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6490__) \
1421:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6490A__) \
1422:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega6490P__) \
1423:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega88__) \
1424:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega88P__) \
1425:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega8U2__) \
1426:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega16U2__) \
1427:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATmega32U2__) \
1428:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny48__) \
1429:/usr/lib/avr/include/avr/power.h **** || defined(__AVR_ATtiny167__) \
1430:/usr/lib/avr/include/avr/power.h **** || defined(__DOXYGEN__)
1431:/usr/lib/avr/include/avr/power.h **** 
1432:/usr/lib/avr/include/avr/power.h **** 
1433:/usr/lib/avr/include/avr/power.h **** /** \addtogroup avr_power
1434:/usr/lib/avr/include/avr/power.h **** 
1435:/usr/lib/avr/include/avr/power.h **** Some of the newer AVRs contain a System Clock Prescale Register (CLKPR) that
1436:/usr/lib/avr/include/avr/power.h **** allows you to decrease the system clock frequency and the power consumption
1437:/usr/lib/avr/include/avr/power.h **** when the need for processing power is low. Below are two macros and an
1438:/usr/lib/avr/include/avr/power.h **** enumerated type that can be used to interface to the Clock Prescale Register.
1439:/usr/lib/avr/include/avr/power.h **** 
1440:/usr/lib/avr/include/avr/power.h **** \note Not all AVR devices have a Clock Prescale Register. On those devices
1441:/usr/lib/avr/include/avr/power.h **** without a Clock Prescale Register, these macros are not available.
1442:/usr/lib/avr/include/avr/power.h **** */
1443:/usr/lib/avr/include/avr/power.h **** 
1444:/usr/lib/avr/include/avr/power.h **** 
1445:/usr/lib/avr/include/avr/power.h **** /** \addtogroup avr_power
1446:/usr/lib/avr/include/avr/power.h **** \code 
1447:/usr/lib/avr/include/avr/power.h **** typedef enum
1448:/usr/lib/avr/include/avr/power.h **** {
1449:/usr/lib/avr/include/avr/power.h ****     clock_div_1 = 0,
1450:/usr/lib/avr/include/avr/power.h ****     clock_div_2 = 1,
1451:/usr/lib/avr/include/avr/power.h ****     clock_div_4 = 2,
1452:/usr/lib/avr/include/avr/power.h ****     clock_div_8 = 3,
1453:/usr/lib/avr/include/avr/power.h ****     clock_div_16 = 4,
1454:/usr/lib/avr/include/avr/power.h ****     clock_div_32 = 5,
1455:/usr/lib/avr/include/avr/power.h ****     clock_div_64 = 6,
1456:/usr/lib/avr/include/avr/power.h ****     clock_div_128 = 7,
1457:/usr/lib/avr/include/avr/power.h ****     clock_div_256 = 8,
1458:/usr/lib/avr/include/avr/power.h ****     clock_div_1_rc = 15, // ATmega128RFA1 only
1459:/usr/lib/avr/include/avr/power.h **** } clock_div_t;
1460:/usr/lib/avr/include/avr/power.h **** \endcode
1461:/usr/lib/avr/include/avr/power.h **** Clock prescaler setting enumerations.
1462:/usr/lib/avr/include/avr/power.h **** 
1463:/usr/lib/avr/include/avr/power.h **** */
1464:/usr/lib/avr/include/avr/power.h **** typedef enum
1465:/usr/lib/avr/include/avr/power.h **** {
1466:/usr/lib/avr/include/avr/power.h ****     clock_div_1 = 0,
1467:/usr/lib/avr/include/avr/power.h ****     clock_div_2 = 1,
1468:/usr/lib/avr/include/avr/power.h ****     clock_div_4 = 2,
1469:/usr/lib/avr/include/avr/power.h ****     clock_div_8 = 3,
1470:/usr/lib/avr/include/avr/power.h ****     clock_div_16 = 4,
1471:/usr/lib/avr/include/avr/power.h ****     clock_div_32 = 5,
1472:/usr/lib/avr/include/avr/power.h ****     clock_div_64 = 6,
1473:/usr/lib/avr/include/avr/power.h ****     clock_div_128 = 7,
1474:/usr/lib/avr/include/avr/power.h ****     clock_div_256 = 8
1475:/usr/lib/avr/include/avr/power.h **** #if defined(__AVR_ATmega128RFA1__)
1476:/usr/lib/avr/include/avr/power.h ****     , clock_div_1_rc = 15
1477:/usr/lib/avr/include/avr/power.h **** #endif
1478:/usr/lib/avr/include/avr/power.h **** } clock_div_t;
1479:/usr/lib/avr/include/avr/power.h **** 
1480:/usr/lib/avr/include/avr/power.h **** 
1481:/usr/lib/avr/include/avr/power.h **** static __inline__ void clock_prescale_set(clock_div_t) __attribute__((__always_inline__));
1482:/usr/lib/avr/include/avr/power.h **** 
1483:/usr/lib/avr/include/avr/power.h **** /** \addtogroup avr_power
1484:/usr/lib/avr/include/avr/power.h **** \code clock_prescale_set(x) \endcode
1485:/usr/lib/avr/include/avr/power.h **** 
1486:/usr/lib/avr/include/avr/power.h **** Set the clock prescaler register select bits, selecting a system clock
1487:/usr/lib/avr/include/avr/power.h **** division setting. This function is inlined, even if compiler
1488:/usr/lib/avr/include/avr/power.h **** optimizations are disabled.
1489:/usr/lib/avr/include/avr/power.h **** 
1490:/usr/lib/avr/include/avr/power.h **** The type of x is clock_div_t.
1491:/usr/lib/avr/include/avr/power.h **** */
1492:/usr/lib/avr/include/avr/power.h **** void clock_prescale_set(clock_div_t __x)
1493:/usr/lib/avr/include/avr/power.h **** {
1494:/usr/lib/avr/include/avr/power.h ****     uint8_t __tmp = _BV(CLKPCE);
1495:/usr/lib/avr/include/avr/power.h ****     __asm__ __volatile__ (
 1978               		.loc 4 1495 0
 1979 0016 90E0      		ldi r25,0
 1980 0018 80E8      		ldi r24,lo8(-128)
 1981               	/* #APP */
 1982               	 ;  1495 "/usr/lib/avr/include/avr/power.h" 1
 1983 001a 0FB6      		in __tmp_reg__,__SREG__
 1984 001c F894      		cli
 1985 001e 8093 6100 		sts 97, r24
 1986 0022 9093 6100 		sts 97, r25
 1987 0026 0FBE      		out __SREG__, __tmp_reg__
 1988               	 ;  0 "" 2
 1989               	/* #NOAPP */
 1990               	.LBE62:
 1991               	.LBE61:
 176:catboard.c    **** 	init();
 1992               		.loc 2 176 0
 1993 0028 0E94 0000 		call init
 1994               	.LVL135:
 1995               	.L285:
 178:catboard.c    **** 		poll();
 1996               		.loc 2 178 0 discriminator 1
 1997 002c 0E94 0000 		call poll
 1998               	.LVL136:
 1999 0030 00C0      		rjmp .L285
 2000               		.cfi_endproc
 2001               	.LFE9:
 2003               	.global	repeat_time
 2004               		.section .bss
 2007               	repeat_time:
 2008 0000 0000      		.zero	2
 2009               	.global	release_time
 2012               	release_time:
 2013 0002 0000      		.zero	2
 2014               	.global	press_time2
 2017               	press_time2:
 2018 0004 0000      		.zero	2
 2019               	.global	press_time
 2022               	press_time:
 2023 0006 0000      		.zero	2
 2024               	.global	last_key
 2025               		.data
 2028               	last_key:
 2029 0000 FF        		.byte	-1
 2030               	.global	led
 2033               	led:
 2034 0001 01        		.byte	1
 2035               	.global	locked
 2036               		.section .bss
 2039               	locked:
 2040 0008 00        		.zero	1
 2041               	.global	turbo_repeat
 2044               	turbo_repeat:
 2045 0009 00        		.zero	1
 2046               	.global	prev_layer
 2049               	prev_layer:
 2050 000a 0000      		.zero	2
 2051               	.global	mod_keys
 2054               	mod_keys:
 2055 000c 00        		.zero	1
 2056               	.global	queue
 2057               		.data
 2060               	queue:
 2061 0002 FF        		.byte	-1
 2062 0003 FF        		.byte	-1
 2063 0004 FF        		.byte	-1
 2064 0005 FF        		.byte	-1
 2065 0006 FF        		.byte	-1
 2066 0007 FF        		.byte	-1
 2067 0008 FF        		.byte	-1
 2068               		.comm	pressed,60,1
 2069               	.global	layout
 2072               	layout:
 2073 0009 0000      		.word	layer2
 2074               	.global	disable_key_my_shift
 2075               		.section .bss
 2078               	disable_key_my_shift:
 2079 000d 00        		.zero	1
 2080               	.global	caps_lock_led
 2083               	caps_lock_led:
 2084 000e 00        		.zero	1
 2085               	.global	os_mode
 2086               		.data
 2089               	os_mode:
 2090 000b 01        		.byte	1
 2091               	.global	layer_fnlock
 2092               		.section	.rodata
 2095               	layer_fnlock:
 2096 0000 35        		.byte	53
 2097 0001 2B        		.byte	43
 2098 0002 69        		.byte	105
 2099 0003 7D        		.byte	125
 2100 0004 29        		.byte	41
 2101 0005 1E        		.byte	30
 2102 0006 14        		.byte	20
 2103 0007 04        		.byte	4
 2104 0008 68        		.byte	104
 2105 0009 6A        		.byte	106
 2106 000a 1F        		.byte	31
 2107 000b 1A        		.byte	26
 2108 000c 16        		.byte	22
 2109 000d 1B        		.byte	27
 2110 000e 1D        		.byte	29
 2111 000f 20        		.byte	32
 2112 0010 08        		.byte	8
 2113 0011 07        		.byte	7
 2114 0012 06        		.byte	6
 2115 0013 67        		.byte	103
 2116 0014 21        		.byte	33
 2117 0015 15        		.byte	21
 2118 0016 09        		.byte	9
 2119 0017 19        		.byte	25
 2120 0018 65        		.byte	101
 2121 0019 22        		.byte	34
 2122 001a 17        		.byte	23
 2123 001b 0A        		.byte	10
 2124 001c 05        		.byte	5
 2125 001d 2C        		.byte	44
 2126 001e 23        		.byte	35
 2127 001f 1C        		.byte	28
 2128 0020 0B        		.byte	11
 2129 0021 11        		.byte	17
 2130 0022 2C        		.byte	44
 2131 0023 24        		.byte	36
 2132 0024 18        		.byte	24
 2133 0025 0D        		.byte	13
 2134 0026 10        		.byte	16
 2135 0027 7F        		.byte	127
 2136 0028 25        		.byte	37
 2137 0029 0C        		.byte	12
 2138 002a 0E        		.byte	14
 2139 002b 36        		.byte	54
 2140 002c 6B        		.byte	107
 2141 002d 26        		.byte	38
 2142 002e 12        		.byte	18
 2143 002f 0F        		.byte	15
 2144 0030 37        		.byte	55
 2145 0031 38        		.byte	56
 2146 0032 27        		.byte	39
 2147 0033 13        		.byte	19
 2148 0034 33        		.byte	51
 2149 0035 31        		.byte	49
 2150 0036 66        		.byte	102
 2151 0037 2D        		.byte	45
 2152 0038 2F        		.byte	47
 2153 0039 34        		.byte	52
 2154 003a 30        		.byte	48
 2155 003b 2E        		.byte	46
 2156               	.global	layer_fn
 2159               	layer_fn:
 2160 003c 46        		.byte	70
 2161 003d 2B        		.byte	43
 2162 003e 69        		.byte	105
 2163 003f 7D        		.byte	125
 2164 0040 7B        		.byte	123
 2165 0041 3A        		.byte	58
 2166 0042 62        		.byte	98
 2167 0043 57        		.byte	87
 2168 0044 56        		.byte	86
 2169 0045 6D        		.byte	109
 2170 0046 3B        		.byte	59
 2171 0047 59        		.byte	89
 2172 0048 5C        		.byte	92
 2173 0049 5F        		.byte	95
 2174 004a 00        		.byte	0
 2175 004b 3C        		.byte	60
 2176 004c 5A        		.byte	90
 2177 004d 5D        		.byte	93
 2178 004e 60        		.byte	96
 2179 004f 67        		.byte	103
 2180 0050 3D        		.byte	61
 2181 0051 5B        		.byte	91
 2182 0052 5E        		.byte	94
 2183 0053 61        		.byte	97
 2184 0054 65        		.byte	101
 2185 0055 3E        		.byte	62
 2186 0056 35        		.byte	53
 2187 0057 55        		.byte	85
 2188 0058 54        		.byte	84
 2189 0059 77        		.byte	119
 2190 005a 3F        		.byte	63
 2191 005b 79        		.byte	121
 2192 005c 28        		.byte	40
 2193 005d 2A        		.byte	42
 2194 005e 7C        		.byte	124
 2195 005f 40        		.byte	64
 2196 0060 4A        		.byte	74
 2197 0061 50        		.byte	80
 2198 0062 4C        		.byte	76
 2199 0063 7F        		.byte	127
 2200 0064 41        		.byte	65
 2201 0065 52        		.byte	82
 2202 0066 51        		.byte	81
 2203 0067 49        		.byte	73
 2204 0068 7E        		.byte	126
 2205 0069 42        		.byte	66
 2206 006a 4D        		.byte	77
 2207 006b 4F        		.byte	79
 2208 006c 00        		.byte	0
 2209 006d 00        		.byte	0
 2210 006e 43        		.byte	67
 2211 006f 4B        		.byte	75
 2212 0070 4E        		.byte	78
 2213 0071 00        		.byte	0
 2214 0072 7A        		.byte	122
 2215 0073 44        		.byte	68
 2216 0074 29        		.byte	41
 2217 0075 48        		.byte	72
 2218 0076 47        		.byte	71
 2219 0077 45        		.byte	69
 2220               	.global	layer1
 2223               	layer1:
 2224 0078 35        		.byte	53
 2225 0079 2B        		.byte	43
 2226 007a 69        		.byte	105
 2227 007b 7D        		.byte	125
 2228 007c 29        		.byte	41
 2229 007d 1E        		.byte	30
 2230 007e 14        		.byte	20
 2231 007f 04        		.byte	4
 2232 0080 68        		.byte	104
 2233 0081 6D        		.byte	109
 2234 0082 1F        		.byte	31
 2235 0083 1A        		.byte	26
 2236 0084 16        		.byte	22
 2237 0085 1B        		.byte	27
 2238 0086 1D        		.byte	29
 2239 0087 20        		.byte	32
 2240 0088 08        		.byte	8
 2241 0089 07        		.byte	7
 2242 008a 06        		.byte	6
 2243 008b 67        		.byte	103
 2244 008c 21        		.byte	33
 2245 008d 15        		.byte	21
 2246 008e 09        		.byte	9
 2247 008f 19        		.byte	25
 2248 0090 65        		.byte	101
 2249 0091 22        		.byte	34
 2250 0092 17        		.byte	23
 2251 0093 0A        		.byte	10
 2252 0094 05        		.byte	5
 2253 0095 77        		.byte	119
 2254 0096 23        		.byte	35
 2255 0097 1C        		.byte	28
 2256 0098 0B        		.byte	11
 2257 0099 11        		.byte	17
 2258 009a 2C        		.byte	44
 2259 009b 24        		.byte	36
 2260 009c 18        		.byte	24
 2261 009d 0D        		.byte	13
 2262 009e 10        		.byte	16
 2263 009f 7F        		.byte	127
 2264 00a0 25        		.byte	37
 2265 00a1 0C        		.byte	12
 2266 00a2 0E        		.byte	14
 2267 00a3 36        		.byte	54
 2268 00a4 6B        		.byte	107
 2269 00a5 26        		.byte	38
 2270 00a6 12        		.byte	18
 2271 00a7 0F        		.byte	15
 2272 00a8 37        		.byte	55
 2273 00a9 38        		.byte	56
 2274 00aa 27        		.byte	39
 2275 00ab 13        		.byte	19
 2276 00ac 33        		.byte	51
 2277 00ad 31        		.byte	49
 2278 00ae 6E        		.byte	110
 2279 00af 2D        		.byte	45
 2280 00b0 2F        		.byte	47
 2281 00b1 34        		.byte	52
 2282 00b2 30        		.byte	48
 2283 00b3 2E        		.byte	46
 2284               	.global	col_bit
 2287               	col_bit:
 2288 00b4 08        		.byte	8
 2289 00b5 01        		.byte	1
 2290 00b6 10        		.byte	16
 2291 00b7 01        		.byte	1
 2292 00b8 04        		.byte	4
 2293 00b9 20        		.byte	32
 2294 00ba 10        		.byte	16
 2295 00bb 10        		.byte	16
 2296 00bc 04        		.byte	4
 2297 00bd 20        		.byte	32
 2298 00be 80        		.byte	-128
 2299 00bf 80        		.byte	-128
 2300               	.global	col_pin
 2303               	col_pin:
 2304 00c0 2900      		.word	41
 2305 00c2 2900      		.word	41
 2306 00c4 2900      		.word	41
 2307 00c6 2300      		.word	35
 2308 00c8 2600      		.word	38
 2309 00ca 2900      		.word	41
 2310 00cc 2300      		.word	35
 2311 00ce 2600      		.word	38
 2312 00d0 2300      		.word	35
 2313 00d2 2300      		.word	35
 2314 00d4 2600      		.word	38
 2315 00d6 2300      		.word	35
 2316               	.global	row_bit
 2319               	row_bit:
 2320 00d8 20        		.byte	32
 2321 00d9 04        		.byte	4
 2322 00da 40        		.byte	64
 2323 00db 08        		.byte	8
 2324 00dc 02        		.byte	2
 2325               	.global	row_port
 2328               	row_port:
 2329 00dd 2800      		.word	40
 2330 00df 2B00      		.word	43
 2331 00e1 2500      		.word	37
 2332 00e3 2500      		.word	37
 2333 00e5 2500      		.word	37
 2334               	.global	layer2
 2337               	layer2:
 2338 00e7 35        		.byte	53
 2339 00e8 2B        		.byte	43
 2340 00e9 69        		.byte	105
 2341 00ea 7D        		.byte	125
 2342 00eb 29        		.byte	41
 2343 00ec 1E        		.byte	30
 2344 00ed 14        		.byte	20
 2345 00ee 04        		.byte	4
 2346 00ef 68        		.byte	104
 2347 00f0 6D        		.byte	109
 2348 00f1 1F        		.byte	31
 2349 00f2 1A        		.byte	26
 2350 00f3 16        		.byte	22
 2351 00f4 1B        		.byte	27
 2352 00f5 1D        		.byte	29
 2353 00f6 20        		.byte	32
 2354 00f7 08        		.byte	8
 2355 00f8 07        		.byte	7
 2356 00f9 06        		.byte	6
 2357 00fa 67        		.byte	103
 2358 00fb 21        		.byte	33
 2359 00fc 15        		.byte	21
 2360 00fd 09        		.byte	9
 2361 00fe 19        		.byte	25
 2362 00ff 65        		.byte	101
 2363 0100 22        		.byte	34
 2364 0101 17        		.byte	23
 2365 0102 0A        		.byte	10
 2366 0103 05        		.byte	5
 2367 0104 77        		.byte	119
 2368 0105 23        		.byte	35
 2369 0106 1C        		.byte	28
 2370 0107 0B        		.byte	11
 2371 0108 11        		.byte	17
 2372 0109 2C        		.byte	44
 2373 010a 24        		.byte	36
 2374 010b 18        		.byte	24
 2375 010c 0D        		.byte	13
 2376 010d 10        		.byte	16
 2377 010e 7F        		.byte	127
 2378 010f 25        		.byte	37
 2379 0110 0C        		.byte	12
 2380 0111 0E        		.byte	14
 2381 0112 36        		.byte	54
 2382 0113 6B        		.byte	107
 2383 0114 26        		.byte	38
 2384 0115 12        		.byte	18
 2385 0116 0F        		.byte	15
 2386 0117 37        		.byte	55
 2387 0118 38        		.byte	56
 2388 0119 27        		.byte	39
 2389 011a 13        		.byte	19
 2390 011b 33        		.byte	51
 2391 011c 31        		.byte	49
 2392 011d 6E        		.byte	110
 2393 011e 2D        		.byte	45
 2394 011f 2F        		.byte	47
 2395 0120 34        		.byte	52
 2396 0121 30        		.byte	48
 2397 0122 2E        		.byte	46
 2398               		.text
 2399               	.Letext0:
 2400               		.file 5 "/usr/lib/avr/include/stdint.h"
 2401               		.file 6 "usb_keyboard.h"
 2402               		.file 7 "qwerty.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 catboard.c
     /tmp/cccOTF9J.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cccOTF9J.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cccOTF9J.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cccOTF9J.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cccOTF9J.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cccOTF9J.s:13     .text.init_ports:0000000000000000 init_ports
     /tmp/cccOTF9J.s:41     .text.init:0000000000000000 init
     /tmp/cccOTF9J.s:2033   .data:0000000000000001 led
                            *COM*:000000000000003c pressed
     /tmp/cccOTF9J.s:2083   .bss:000000000000000e caps_lock_led
     /tmp/cccOTF9J.s:115    .text.caps_lock_change_layer:0000000000000000 caps_lock_change_layer
     /tmp/cccOTF9J.s:2072   .data:0000000000000009 layout
     /tmp/cccOTF9J.s:2223   .rodata:0000000000000078 layer1
     /tmp/cccOTF9J.s:2159   .rodata:000000000000003c layer_fn
     /tmp/cccOTF9J.s:2049   .bss:000000000000000a prev_layer
     /tmp/cccOTF9J.s:2337   .rodata:00000000000000e7 layer2
     /tmp/cccOTF9J.s:201    .text.change_layout:0000000000000000 change_layout
     /tmp/cccOTF9J.s:2089   .data:000000000000000b os_mode
     /tmp/cccOTF9J.s:281    .text.get_code:0000000000000000 get_code
     /tmp/cccOTF9J.s:354    .text.repeat_tick:0000000000000000 repeat_tick
     /tmp/cccOTF9J.s:2007   .bss:0000000000000000 repeat_time
     /tmp/cccOTF9J.s:2012   .bss:0000000000000002 release_time
     /tmp/cccOTF9J.s:2044   .bss:0000000000000009 turbo_repeat
     /tmp/cccOTF9J.s:2054   .bss:000000000000000c mod_keys
     /tmp/cccOTF9J.s:2028   .data:0000000000000000 last_key
     /tmp/cccOTF9J.s:2017   .bss:0000000000000004 press_time2
     /tmp/cccOTF9J.s:2022   .bss:0000000000000006 press_time
     /tmp/cccOTF9J.s:506    .text.send:0000000000000000 send
     /tmp/cccOTF9J.s:2060   .data:0000000000000002 queue
     /tmp/cccOTF9J.s:570    .text.key_release:0000000000000000 key_release
     /tmp/cccOTF9J.s:1017   .text.restore_leds:0000000000000000 restore_leds
     /tmp/cccOTF9J.s:1070   .text.wait:0000000000000000 wait
     /tmp/cccOTF9J.s:1097   .text.blink_leds:0000000000000000 blink_leds
     /tmp/cccOTF9J.s:1136   .text.key_press:0000000000000000 key_press
     /tmp/cccOTF9J.s:2039   .bss:0000000000000008 locked
     /tmp/cccOTF9J.s:2095   .rodata:0000000000000000 layer_fnlock
     /tmp/cccOTF9J.s:1738   .text.poll:0000000000000000 poll
     /tmp/cccOTF9J.s:2328   .rodata:00000000000000dd row_port
     /tmp/cccOTF9J.s:2319   .rodata:00000000000000d8 row_bit
     /tmp/cccOTF9J.s:2303   .rodata:00000000000000c0 col_pin
     /tmp/cccOTF9J.s:2287   .rodata:00000000000000b4 col_bit
     /tmp/cccOTF9J.s:1950   .text.startup.main:0000000000000000 main
     /tmp/cccOTF9J.s:2078   .bss:000000000000000d disable_key_my_shift

UNDEFINED SYMBOLS
usb_init
usb_configured
keyboard_leds
keyboard_modifier_keys
keyboard_keys
usb_keyboard_send
usb_keyboard_press
__do_copy_data
__do_clear_bss
